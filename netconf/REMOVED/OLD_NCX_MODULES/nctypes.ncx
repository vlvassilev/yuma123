ncx-module nctypes {
  header {
    description 
      "SMIv2 textual conventions converted from
       draft-romascanu-netconf-datatypes-02.txt
      ";
    version 0.1;
    owner ietf;
    application types;
    contact-info 
      "Translated by Andy Bierman.
       Send comments to ietf@andybierman.com.";
    last-update "2007-09-16";
    revision-history {
       0.1 "Initial version.";
    }
    namespace "urn:ietf:params:xml:ns:netmod:datatypes:1.0";
  }

  imports {
    import xsd { anyURI };
  }

  definitions {

    type DisplayString {
      description
     "Represents textual information taken from the NVT ASCII
      character set, as defined in pages 4, 10-11 of RFC 854.
      To summarize RFC 854, the NVT ASCII repertoire specifies:
        - the use of character codes 0-127 (decimal)
        - the graphics characters (32-126) are interpreted as
          US ASCII
        - NUL, LF, CR, BEL, BS, HT, VT and FF have the special
          meanings specified in RFC 854
        - the other 25 codes have no standard interpretation
        - the sequence 'CR LF' means newline
        - the sequence 'CR NUL' means carriage-return
        - an 'LF' not preceded by a 'CR' means moving to the
          same column on the next line.
        - the sequence 'CR x' for any x other than LF or NUL is
          illegal. (Note that this also means that a string may
          end with either 'CR LF' or 'CR NUL', but not with CR.)
      Any object defined using this syntax may not exceed 255
      characters in length.";
      syntax { 
        string (0..255)
          pattern = '((((\p{IsBasicLatin})){0,255})){0,1}';
      }
      appinfo {
        ncx:display-hint "255a";
      }
    }

    type TestAndIncr {
      description
     "Represents integer-valued information used for atomic
      operations.  When the management protocol is used to specify
      that an object instance having this syntax is to be
      modified, the new value supplied via the management protocol
      must precisely match the value presently held by the
      instance.  If not, the management protocol set operation
      fails with an error of `inconsistentValue'.  Otherwise, if
      the current value is the maximum value of 2^31-1 (2147483647
      decimal), then the value held by the instance is wrapped to
      zero; otherwise, the value held by the instance is
      incremented by one.  (Note that regardless of whether the
      management protocol set operation succeeds, the variable-
      binding in the request and response PDUs are identical.)

      The value of the ACCESS clause for objects having this
      syntax is either `read-write' or `read-create'.  When an
      instance of a columnar object having this syntax is created,
      any value may be supplied via the management protocol.

      When the network management portion of the system is re-
      initialized, the value of every object instance having this
      syntax must either be incremented from its value prior to
      the re-initialization, or (if the value prior to the re-
      initialization is unknown) be set to a pseudo-randomly
      generated value.";
      syntax { uint32 (0..2147483647); }
    }

    type RowPointer {
      description
     "Represents a pointer to an element instance.  The value is an
      absolut XPath expression that points to the instance.
      [discuss] Is it allowed that the XPath expression points to
      multiple instances of an element?
      [todo] The pattern of the XPath expression needs to be
      designed.";
      syntax { 
        # should be an s-quote string but contains '
        # okay for d-quote string because no \n or \t or \" or \\
        string pattern = 
           "(/|(/[\w][\w\-]*)+)\[@?[\w][\w\-]*='[\w\-]+'\]"; 
      }
    }

    type RowStatus {
      description "RowStatus TC from RFC 2579, pages 6 - 17.";
      syntax { 
        enum = { 
          active=1 notInService notReady createAndGo createAndWait destroy
        }; 
      }
    }

    type TimeStamp {
      description
     "The value of the sysUpTime object at which a specific
      occurrence happened.  The sysUpTime object is that the time
      (in hundredths of a second) since the network management
      portion of the system was last re-initialized.  The specific
      occurrence must be defined in the description of any object
      defined using this type.

      If sysUpTime is reset to zero as a result of a re-
      initialization of the network management (sub)system, then
      the values of all TimeStamp objects are also reset.
      However, after approximately 497 days without a re-
      initialization, the sysUpTime object will reach 2^^32-1 and
      then increment around to zero; in this case, existing values
      of TimeStamp objects do not change.  This can lead to
      ambiguities in the value of TimeStamp objects.

      [discuss] Is the maximum of 42949672.96 seconds needed?
      The TimeTicks datatype is essentially an integer in SNMP, thus
      it has the maximum.";
      syntax { uint32 (0..2147483647); }
    }
   
    type TimeInterval {
      description
     "A period of time, measured in units of 0.01 seconds.
      [discuss] Is the maximum of 21474836.47 seconds needed?
      The TimeTicks datatype is essentially an integer in SNMP, thus
      it has the maximum.";
      syntax { uint32 (0..2147483647); }
    }

    type StorageType {
      description
     "Describes the memory realization of a conceptual row.  A
      row which is volatile is lost upon reboot.  A row which
      is either nonVolatile, permanent or readOnly, is
      backed up by stable storage.  A row which is permanent
      can be changed but not deleted.  A row which is readOnly
      cannot be changed nor deleted.

      If the value of an object with this syntax is either
      permanent or readOnly, it cannot be written.
      Conversely, if the value is either other, volatile or
      nonVolatile, it cannot be modified to be permanent or
      readOnly.

      Every usage of this datatype is required to
      specify the columnar objects which a permanent row must
      at a minimum allow to be writable.";
      syntax { 
        enum = { 
          other=1 volatile nonVolatile permanent readOnly 
        }; 
      }
    }

    type SnmpAdminString {
      description
     "An octet string containing administrative
      information, preferably in human-readable form.

      To facilitate internationalization, this
      information is represented using the ISO/IEC
      IS 10646-1 character set, encoded as an octet
      string using the UTF-8 transformation format
      described in RFC3629.

      Since additional code points are added by
      amendments to the 10646 standard from time
      to time, implementations must be prepared to
      encounter any code point from 0x00000000 to
      0x7fffffff.  Byte sequences that do not
      correspond to the valid UTF-8 encoding of a
      code point or are outside this range are
      prohibited.

      The use of control codes should be avoided.

      When it is necessary to represent a newline,
      the control code sequence CR LF should be used.

      The use of leading or trailing white space should
      be avoided.

      For code points not directly supported by user
      interface hardware or software, an alternative
      means of entry and display, such as hexadecimal,
      may be provided.

      For information encoded in 7-bit US-ASCII,
      the UTF-8 encoding is identical to the
      US-ASCII encoding.

      UTF-8 may require multiple bytes to represent a
      single character / code point; thus the length
      of this object in octets may be different from
      the number of characters encoded.  Similarly,
      size constraints refer to the number of encoded
      octets, not the number of characters represented
      by an encoding.

      Note that the size of an SnmpAdminString object is
      measured in octets, not characters.";
      syntax { string (0..255); }
    }

    type UtfString {
      description
     "To facilitate internationalization, this datatype
      represents information taken from the ISO/IEC IS
      10646-1 character set, encoded as an octet string
      using the UTF-8 character encoding scheme described
      in RFC 2044. For strings in 7-bit US-ASCII,
      there is no impact since the UTF-8 representation
      is identical to the US-ASCII encoding.";
      syntax { string (0..255); }
    }

    type LongUtfString {
      description
     "To facilitate internationalization, this datatype
      represents information taken from the ISO/IEC IS
      10646-1 character set, encoded as an octet string
      using the UTF-8 character encoding scheme described
      in RFC 2044.  For strings in 7-bit US-ASCII,
      there is no impact since the UTF-8 representation
      is identical to the US-ASCII encoding.";
      syntax { string (0..1024); }
    }

    type ZeroBasedCounter32 {
      description
     "This datatype describes an object which counts events with the
      following semantics: objects of this type will be set to
      zero(0) on creation and will thereafter count appropriate
      events, wrapping back to zero(0) when the value 2^32 is
      reached.

      Provided that an application discovers the new object within
      the minimum time to wrap it can use the initial value as a
      delta since it last polled the table of which this object is
      part.  It is important for a management station to be aware of
      this minimum time and the actual time between polls, and to
      discard data if the actual time is too long or there is no
      defined minimum time.

      Typically this datatype is used in tables where the INDEX space is
      constantly changing and/or the TimeFilter mechanism is in use.";
      syntax { uint32; }
      default "0";
      max-access read-only;
    }

    type ZeroBasedCounter64 {
      description
     "This datatype describes an object which counts events with the
      following semantics: objects of this type will be set to
      zero(0) on creation and will thereafter count appropriate
      events, wrapping back to zero(0) when the value 2^64 is
      reached.

      Provided that an application discovers the new object within
      the minimum time to wrap it can use the initial value as a
      delta since it last polled the table of which this object is
      part.  It is important for a management station to be aware
      of this minimum time and the actual time between polls, and
      to discard data if the actual time is too long or there is
      no defined minimum time.

      Typically this datatype is used in tables where the INDEX space is
      constantly changing and/or the TimeFilter mechanism is in use.

      Note that this datatype does not retain all the
      semantics of the Counter64 base type. Specifically, a
      Counter64 has an arbitrary initial value, but objects
      defined with this datatype are required to start at the value
      zero.  This behavior is not likely to have any adverse
      effects on management applications which are expecting
      Counter64 semantics.";
      syntax { uint64; }
      default "0";
      max-access read-only;
    }

    type CounterBasedGauge64 {
      description
     "This datatype represents a non-negative integer, which may
      increase or decrease, but shall never exceed a maximum value,
      nor fall below a minimum value. The maximum value can not be
      greater than 2^64-1 (18446744073709551615 decimal), and the
      minimum value can not be smaller than 0.  The value of a
      CounterBasedGauge64 has its maximum value whenever the
      information being modeled is greater than or equal to its
      maximum value, and has its minimum value whenever the information
      being modeled is smaller than or equal to its minimum value.
      If the information being modeled subsequently decreases below
      (increases above) the maximum (minimum) value, the
      CounterBasedGauge64 also decreases (increases).

      Note that this datatype is not strictly supported in SMIv2,
      because the 'always increasing' and 'counter wrap' semantics
      associated with the Counter64 base type are not preserved.
      It is possible that management applications which rely
      solely upon the (Counter64) ASN.1 tag to determine object
      semantics will mistakenly operate upon objects of this type
      as they would for Counter64 objects.";
      syntax { uint64; }
    }

    type InterfaceIndex {
      description
     "A unique value, greater than zero, for each interface or
      interface sub-layer in the managed system.  It is
      recommended that values are assigned contiguously starting
      from 1.  The value for each interface sub-layer must remain
      constant at least from one re-initialization of the entity's
      network management system to the next re-initialization.";
      syntax { uint32 (1..2147483647); }
    }

    # this objectSpecific stuff is broken in the current draft

    type objectSpecificType {
      description
     "Object-specific, it be defined as part of the description of
      any object that uses this syntax.";
      syntax { string = { objectSpecific }; }
    }

    type InterfaceIndexOrZero {
      description
     "This datatype is an extension of the
      InterfaceIndex datatype.  The latter defines a greater
      than zero value used to identify an interface or interface
      sub-layer in the managed system.  This extension permits the
      additional value of zero.  the value zero is object-specific
      and must therefore be defined as part of the description of
      any object which uses this syntax.  Examples of the usage of
      zero might include situations where interface was unknown,
      or when none or all interfaces need to be referenced.";
      syntax { 
	union { InterfaceIndex objectSpecificType };
      }
    }

    type PhysicalIndex {
      description
     "An arbitrary value that uniquely identifies the physical
      entity.  The value should be a small, positive integer.
      Index values for different physical entities are not
      necessarily contiguous.";
      syntax { uint32 (1..2147483647); }
    }



    type PhysicalIndexOrZero  {
      description
     "This datatype is an extension of the
      PhysicalIndex datatype, which defines a greater than zero
      value used to identify a physical entity.  This extension
      permits the additional value of zero.  The semantics of the
      value zero are object-specific and must, therefore, be
      defined as part of the description of any object that uses
      this syntax.  Examples of the usage of this extension are
      situations where none or all physical entities need to be
      referenced.";
      syntax { 
	union { PhysicalIndex objectSpecificType };
      }
    }

    type MacAddress {
      description
     "Represents an 802 MAC address represented in the
      `canonical' order defined by IEEE 802.1a, i.e., as if it
      were transmitted least significant bit first, even though
      802.5 (in contrast to other 802.x protocols) requires MAC
      addresses to be transmitted most significant bit first.";
      syntax {
         # draft pattern does not have colon separators 
         # pattern="[0-9a-fA-F]{12}"
         string pattern = 
           '(((([0-9A-Fa-f]{2}):){5,5})([0-9A-Fa-f]{2}))';
      }
      appinfo {
        ncx:display-hint "1x:";
      }
    }

    type InetAddressType {
      description
     "A value that represents a type of Internet address.

      unknown  An unknown address type.  This value MUST
               be used if the value of the corresponding
               InetAddress object is a zero-length string.
               It may also be used to indicate an IP address
               that is not in one of the formats defined
               below.

      ipv4     An IPv4 address as defined by the
               InetAddressIPv4 datatype.

      ipv6     An IPv6 address as defined by the
               InetAddressIPv6 datatype.

      ipv4z    A non-global IPv4 address including a zone
               index as defined by the InetAddressIPv4z
               datatype.

      ipv6z    A non-global IPv6 address including a zone
               index as defined by the InetAddressIPv6z
               datatype.

      dns      A DNS domain name as defined by the
               InetAddressDNS datatype.

      Each definition of a concrete InetAddressType value must be
      accompanied by a definition of a datatype for use
      with that InetAddressType.

      To support future extensions, the InetAddressType datatype
      SHOULD NOT be sub-typed in object type definitions.
      It MAY be sub-typed in compliance statements in order to
      require only a subset of these address types for a compliant
      implementation.

      Implementations must ensure that InetAddressType objects
      and any dependent objects (e.g., InetAddress objects) are
      consistent.  In particular, InetAddressType/InetAddress pairs
      must be changed together if the address type changes (e.g.,
      from ipv6 to ipv4).";
      syntax { 
        enum = { unknown ipv4 ipv6 ipv4z ipv6z dns=16 };
      }
    }

    type InetAddress {
      description
     "Denotes a generic Internet address.

      An InetAddress value is always interpreted within the context
      of an InetAddressType value.  Every usage of the InetAddress
      datatype is required to specify the InetAddressType
      object that provides the context.  It is suggested that the
      InetAddressType object be logically registered before the
      object(s) that use the InetAddress datatype, if
      they appear in the same logical row.

      The value of an InetAddress object must always be
      consistent with the value of the associated InetAddressType
      object.  Attempts to set an InetAddress object to a value
      inconsistent with the associated InetAddressType
      must fail.

      The actual format of the string content is determined by
       the optional 'type' attribute as follows:
         
          unknown: InetAddressUnknown
          ipv4:    InetAddressIPv4
          ipv6:    InetAddressIPv6
          ipv4z:   InetAddressIPv4z 
          ipv6z:   InetAddressIPv6z
          dns:     InetAddressDNS";
      # current draft uses a generic string instead of a union
      syntax { string (0..39); }
    }

    type InetAddressIPv4 {
      description
     "Represents an IPv4 network address.

      This datatype SHOULD NOT be used directly in object
      definitions, as it restricts addresses to a specific format.
      However, if it is used, it MAY be used either on its own or in
      conjunction with InetAddressType, as a pair.";
      syntax { 
        string (7..15) 
          pattern = '((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}' +
                    '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])';
      }
    }

    type InetZoneIndex {
      description
     "A zone index identifies an instance of a zone of a
      specific scope.

      The zone index MUST disambiguate identical address
      values.  For link-local addresses, the zone index will
      typically be the interface index (ifIndex as defined in the
      IF-MIB) of the interface on which the address is configured.
      The zone index may contain the special value 0, which refers
      to the default zone.  The default zone may be used in cases
      where the valid zone index is not known (e.g., when a
      management application has to write a link-local IPv6
      address without knowing the interface index value).  The
      default zone SHOULD NOT be used as an easy way out in
      cases where the zone index for a non-global IPv6 address
      is known.";
      syntax { 
        uint32 (1..65535);
      }
    }

    type InetAddressIPv4z {
      description
     "Represents a non-global IPv4 network address, together
      with its zone index.

      The corresponding InetAddressType value is 'ipv4z'.

      The zone index is used to disambiguate identical
      address values on nodes that have interfaces attached to
      different zones of the same scope.  The zone index may contain
      the special value 0, which refers to the default zone for each
      scope.

      This datatype SHOULD NOT be used directly in object
      definitions, as it restricts addresses to a specific format.
      However, if it is used, it MAY be used either on its own or in
      conjunction with InetAddressType, as a pair.";
      syntax { 
        container {
          InetAddressIPv4 ipv4Address;
          InetZoneIndex   zoneIndex;
        }
      }
    }
    
    type InetAddressIPv6Full {
      description
      "InetAddressIPv6 TC from RFC 4001, page 8., 
       Full Address Form from
       draft-romascanu-netconf-datatypes-02.txt, page 19.";
      syntax {
        string pattern = 
          '(([0-9a-fA-F]{1,4}:){7})([0-9a-fA-F]{1,4})';
      }
    }

    type InetAddressIPv6Mixed {
      description
      "InetAddressIPv6 TC from RFC 4001, page 8., 
       Mixed Address Form from
       draft-romascanu-netconf-datatypes-02.txt, page 20.";
      syntax {
        string pattern = 
          '(([0-9a-fA-F]{1,4}:){6})' +
          '(([0-9a-fA-F]{1,4}:[0-9a-fA-F]{1,4})|' +
          '([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}))';
      }
    }

    type InetAddressIPv6Shortened {
      description
      "InetAddressIPv6 TC from RFC 4001, page 8., 
       Short Address Form from
       draft-romascanu-netconf-datatypes-02.txt, page 20.";
      syntax {
        string pattern = 
          '(([0-9a-fA-F]{1,4}:)*|([0-9a-fA-F]{1,4}))*(::)' +
          '(([0-9a-fA-F]{1,4}:)*|([0-9a-fA-F]{1,4}))*';
      }
    }

    type InetAddressIPv6 {
      description
     "Represents an IPv6 network address.

      The corresponding InetAddressType value is 'ipv6'.

      This datatype SHOULD NOT be used directly in object
      definitions, as it restricts addresses to a specific format.
      However, if it is used, it MAY be used either on its own or in
      conjunction with InetAddressType, as a pair.";
      syntax { 
        union { InetAddressIPv6Full
                InetAddressIPv6Mixed
                InetAddressIPv6Shortened };
      }
    }

    type InetAddressIPv6z {
      description
     "Represents a non-global IPv6 network address, together
      with its zone index.

      The corresponding InetAddressType value is 'ipv6z'.

      The zone index is used to disambiguate
      identical address values on nodes that have interfaces
      attached to different zones of the same scope.  The zone index
      may contain the special value 0, which refers to the default
      zone for each scope.

      This datatype SHOULD NOT be used directly in object
      definitions, as it restricts addresses to a specific format.
      However, if it is used, it MAY be used either on its own or in
      conjunction with InetAddressType, as a pair.";
      syntax {
        container {
          InetAddressIPv6 ipv6Address;
          InetZoneIndex   zoneIndex;
        }
      }
    }

    type InetAddressDNS {
      description
     "Represents a DNS domain name.  The name SHOULD be fully
      qualified whenever possible.

      The corresponding InetAddressType is dns.

      The DESCRIPTION clause of InetAddress objects that may have
      InetAddressDNS values MUST fully describe how (and when)
      these names are to be resolved to IP addresses.

      The resolution of an InetAddressDNS value may require to
      query multiple DNS records (e.g., A for IPv4 and AAAA for
      IPv6).  The order of the resolution process and which DNS
      record takes precedence depends on the configuration of the
      resolver.

      This datatype SHOULD NOT be used directly in object
      definitions, as it restricts addresses to a specific format.
      However, if it is used, it MAY be used either on its own or in
      conjunction with InetAddressType, as a pair.";
      syntax { 
        string pattern = '([\p{L}\p{N}]*\.)*[\p{L}\p{N}]?';
      }
    }

    type InetAddressPrefixLength {
      description
     "Denotes the length of a generic Internet network address
      prefix.  A value of n corresponds to an IP address mask
      that has n contiguous 1-bits from the most significant
      bit (MSB), with all other bits set to 0.

      An InetAddressPrefixLength value is always interpreted within
      the context of an InetAddressType value.  Every usage of the
      InetAddressPrefixLength datatype is required to
      specify the InetAddressType object that provides the
      context.  It is suggested that the InetAddressType object be
      logically registered before the object(s) that use the
      InetAddressPrefixLength datatype, if they appear
      in the same logical row.

      InetAddressPrefixLength values larger than
      the maximum length of an IP address for a specific
      InetAddressType are treated as the maximum significant
      value applicable for the InetAddressType.  The maximum
      significant value is 32 for the InetAddressType
      'ipv4' and 'ipv4z' and 128 for the InetAddressType
      'ipv6' and 'ipv6z'.  The maximum significant value
      for the InetAddressType 'dns' is 0.

      The value zero is object-specific and must be defined as
      part of the description of any object that uses this
      syntax.  Examples of the usage of zero might include
      situations where the Internet network address prefix
      is unknown or does not apply.

      The upper bound of the prefix length has been chosen to
      be consistent with the maximum size of an InetAddress.";
      syntax { uint32 (0..2040); }
      # draft has a range of 0 .. 65535
    }

    type InetPortNumber {
      description
     "Represents a 16 bit port number of an Internet transport
      layer protocol.  Port numbers are assigned by IANA.  A
      current list of all assignments is available from
      &lt;http://www.iana.org/&gt;.
      The value zero is object-specific and must be defined as
      part of the description of any object that uses this
      syntax.  Examples of the usage of zero might include
      situations where a port number is unknown, or when the
      value zero is used as a wildcard in a filter.";
      syntax { uint32 (0..65535); }
      # current draft has range 1..65535
    }

    type InetAutonomousSystemNumber {
      description
     "Represents an autonomous system number that identifies an
      Autonomous System (AS).  An AS is a set of routers under a
      single technical administration, using an interior gateway
      protocol and common metrics to route packets within the AS,
      and using an exterior gateway protocol to route packets to
      other ASes'.  IANA maintains the AS number space and has
      delegated large parts to the regional registries.

      Autonomous system numbers are currently limited to 16 bits
      (0..65535).  There is, however, work in progress to enlarge the
      autonomous system number space to 32 bits.  Therefore, this
      datatype uses an unsignedInt value without a
      range restriction in order to support a larger autonomous
      system number space.";
      # draft has range 1..65535
      syntax { uint32; }
    }

    type InetScopeType {
      description
     "Represents a scope type.  This datatype can be used
      in cases where a MIB has to represent different scope types
      and there is no context information, such as an InetAddress
      object, that implicitly defines the scope type.

      Note that not all possible values have been assigned yet, but
      they may be assigned in future revisions of this specification.
      Applications should therefore be able to deal with values
      not yet assigned.";
      syntax { 
        enum = { interfaceLocal=1
                 linkLocal
                 subnetLocal
                 adminLocal
                 siteLocal
                 organizationLocal=8
                 global=14 
        };
      }
    }

    type InetVersion {
      description
     "A value representing a version of the IP protocol.

      unknown  An unknown or unspecified version of the IP
               protocol.

      ipv4     The IPv4 protocol as defined in RFC 791 (STD 5).

      ipv6     The IPv6 protocol as defined in RFC 2460.

      Note that this datatype SHOULD NOT be used to
      distinguish different address types associated with IP
      protocols.  The InetAddressType has been designed for this
      purpose.";
      syntax { 
        string = { unknown ipv4 ipv6 };
      }
    }

    type TransportDomain {
      description "An URI that represents a transport domain.";
      syntax { anyURI; }
    }

    type TransportAddressType {
      description
     "A value that represents a transport domain.  The enumerated
      values have the following meaning:

      unknown     unknown transport address type
      udpIpv4     transportDomainUdpIpv4
      udpIpv6     transportDomainUdpIpv6
      udpIpv4z    transportDomainUdpIpv4z
      udpIpv6z    transportDomainUdpIpv6z
      tcpIpv4     transportDomainTcpIpv4
      tcpIpv6     transportDomainTcpIpv6
      tcpIpv4z    transportDomainTcpIpv4z
      tcpIpv6z    transportDomainTcpIpv6z
      sctpIpv4    transportDomainSctpIpv4
      sctpIpv6    transportDomainSctpIpv6
      sctpIpv4z   transportDomainSctpIpv4z
      sctpIpv6z   transportDomainSctpIpv6z
      local       transportDomainLocal
      udpDns      transportDomainUdpDns
      tcpDns      transportDomainTcpDns
      sctpDns     transportDomainSctpDns

      This datatype can be used to represent transport
      domains in situations where a syntax of TransportDomain is
      unwieldy (for example, when used as an index).

      The usage of this textual convention implies that additional
      transport domains can only be supported by updating this MIB
      module. This extensibility restriction does not apply for the
      TransportDomain datatype which allows data model authors
      to define additional transport domains independently in
      other data model modules.";
      syntax { 
        string = { unknown
                   udpIpv4
                   udpIpv6
                   udpIpv4z
                   udpIpv6z
                   tcpIpv4
                   tcpIpv6
                   tcpIpv4z
                   tcpIpv6z 
                   sctpIpv4
                   sctpIpv6
                   sctpIpv4z
                   sctpIpv6z 
                   local
                   udpDns
                   tcpDns
                   sctpDns };
      }
    }

    type TransportAddress {
      description
     "Denotes a generic transport address.

      A TransportAddress value is always interpreted within the
      context of a TransportAddressType or TransportDomain value.
      Every usage of the TransportAddress datatype MUST
      specify the TransportAddressType or TransportDomain object which
      provides the context. Furthermore, data model authors SHOULD
      define a separate TransportAddressType or TransportDomain
      object for each TransportAddress object. It is suggested that
      the TransportAddressType or TransportDomain is logically
      registered before the object(s) which use the
      TransportAddress datatype if they appear in the
      same logical row.

      The value of a TransportAddress object must always be
      consistent with the value of the associated
      TransportAddressType or TransportDomain object. Attempts
      to set a TransportAddress object to a value which is
      inconsistent with the associated TransportAddressType or
      TransportDomain must fail with an error.";
      syntax { string (0..255); }
    }

    type MD5 {
      description "MD5 Message Digest";
      syntax { 
        string pattern = '[0-9a-zA-Z]{32}';
      }
    }

    type E164CountryCode {
      description "ITU-T E.164 Number";
      syntax { 
        string pattern = '[0-9]{3}';
      }
    }

    type E164SubscriberNumber {
      description "E.164 Subscriber Number";
      syntax { string pattern = '[0-9]{15}'; }
    }

    type PerfCurrentCount {
      description
     "A counter associated with a
      performance measurement in a current 15
      minute measurement interval.  The value
      of this counter starts from zero and is
      increased when associated events occur,
      until the end of the 15 minute interval.
      At that time the value of the counter is
      stored in the first 15 minute history
      interval, and the CurrentCount is
      restarted at zero.  In the
      case where the agent has no valid data
      available for the current interval the
      corresponding object instance is not
      available and upon a retrieval request
      a corresponding error message shall be
      returned to indicate that this instance
      does not exist.";
      syntax { uint32; }
    }

    type PerfIntervalCount {
      description
     "A counter associated with a
      performance measurement in a previous
      15 minute measurement interval.  In the
      case where the agent has no valid data
      available for a particular interval the
      corresponding object instance is not
      available and upon a retrieval request
      a corresponding error message shall be
      returned to indicate that this instance
      does not exist.
      In a system supporting
      a history of n intervals with
      IntervalCount(1) and IntervalCount(n) the
      most and least recent intervals
      respectively, the following applies at
      the end of a 15 minute interval:
      - discard the value of IntervalCount(n)
      - the value of IntervalCount(i) becomes that
        of IntervalCount(i-1) for n >= i > 1
      - the value of IntervalCount(1) becomes that
        of CurrentCount
      - the TotalCount, if supported, is adjusted.";
      syntax { uint32; }
    }


    type PerfTotalCount {
      description
     "A counter associated with a
      performance measurements aggregating the
      previous valid 15 minute measurement
      intervals.  (Intervals for which no valid
      data was available are not counted.";
      syntax { uint32; }
    }

    type HCPerfValidIntervals {
      description
     "The number of near end intervals for which data was
      collected.  The value of an object with an
      HCPerfValidIntervals syntax will be 96 unless the
      measurement was (re-)started within the last 1440 minutes,
      in which case the value will be the number of complete 15
      minute intervals for which the agent has at least some data.
      In certain cases (e.g., in the case where the agent is a
      proxy) it is possible that some intervals are unavailable.
      In this case, this interval is the maximum interval number
      for which data is available.";
      syntax { uint32 (0..96); }
    }

    type HCPerfInvalidIntervals {
      description
     "The number of near end intervals for which no data is
      available.  The value of an object with an
      HCPerfInvalidIntervals syntax will typically be zero except
      in cases where the data for some intervals are not available
      (e.g., in proxy situations).";
      syntax { uint32 (0..96); }
    }

    type HCPerfTimeElapsed {
      description
     "The number of seconds that have elapsed since the beginning
      of the current measurement period.  If, for some reason,
      such as an adjustment in the system's time-of-day clock or
      the addition of a leap second, the duration of the current
      interval exceeds the maximum value, the agent will return
      the maximum value.

      For 15 minute intervals, the range is limited to (0..899).
      For 24 hour intervals, the range is limited to (0..86399).";
      syntax { uint32 (0..86399); }
    }

    type HCPerfIntervalThreshold {
      description
     "This convention defines a range of values that may be set
      in a fault threshold alarm control.  As the number of
      seconds in a 15-minute interval numbers at most 900,
      objects of this type may have a range of 0...900, where the
      value of 0 disables the alarm.";
      syntax { uint32 (0..900); }
    }

    type HCPerfCurrentCount {
      description
     "A gauge associated with a performance measurement in a
      current 15 minute measurement interval.  The value of an
      object with an HCPerfCurrentCount syntax starts from zero
      and is increased when associated events occur, until the
      end of the 15 minute interval.  At that time the value of
      the gauge is stored in the first 15 minute history
      interval, and the gauge is restarted at zero.  In the case
      where the agent has no valid data available for the
      current interval, the corresponding object instance is not
      available and upon a retrieval request a corresponding
      error message shall be returned to indicate that this
      instance does not exist.

      This count represents a non-negative integer, which
      may increase or decrease, but shall never exceed 2^64-1
      (18446744073709551615 decimal), nor fall below 0.  The
      value of an object with HCPerfCurrentCount syntax
      assumes its maximum value whenever the underlying count
      exceeds 2^64-1.  If the underlying count subsequently
      decreases below 2^64-1 (due, e.g., to a retroactive
      adjustment as a result of entering or exiting unavailable
      time), then the object's value also decreases.";
      syntax { uint64; }
    }

    type HCPerfIntervalCount {
      description
     "A gauge associated with a performance measurement in
      a previous 15 minute measurement interval.  In the case
      where the agent has no valid data available for a
      particular interval, the corresponding object instance is
      not available and upon a retrieval request a corresponding
      error message shall be returned to indicate that this
      instance does not exist.

      Let X be an object with HCPerfIntervalCount syntax.
      Let Y be an object with HCPerfCurrentCount syntax.
      Let Z be an object with HCPerfTotalCount syntax.
      Then, in a system supporting a history of n intervals with
      X(1) and X(n) the most and least recent intervals
      respectively, the following applies at the end of a 15
      minute interval:
         - discard the value of X(n)
         - the value of X(i) becomes that of X(i-1)
           for n >= i > 1
         - the value of X(1) becomes that of Y.
         - the value of Z, if supported, is adjusted.

      This count represents a non-negative integer, which
      may increase or decrease, but shall never exceed 2^64-1
      (18446744073709551615 decimal), nor fall below 0.  The
      value of an object with HCPerfIntervalCount syntax
      assumes its maximum value whenever the underlying count
      exceeds 2^64-1.  If the underlying count subsequently
      decreases below 2^64-1 (due, e.g., to a retroactive
      adjustment as a result of entering or exiting unavailable
      time), then the value of the object also decreases.";
      syntax { uint64; }
    }

    type HCPerfTotalCount {
      description
     "A gauge representing the aggregate of previous valid 15
      minute measurement intervals.  Intervals for which no
      valid data was available are not counted.

      This count represents a non-negative integer, which
      may increase or decrease, but shall never exceed 2^64-1
      (18446744073709551615 decimal), nor fall below 0.  The
      value of an object with HCPerfTotalCount syntax
      assumes its maximum value whenever the underlying count
      exceeds 2^64-1.  If the underlying count subsequently
      decreases below 2^64-1 (due, e.g., to a retroactive
      adjustment as a result of entering or exiting unavailable
      time), then the object's value also decreases.";
      syntax { uint64; }
    }

    type ItuPerceivedSeverity {
      description "ITU perceived severity values.";
      syntax {
        string = { cleared
                   indeterminate
                   critical
                   major
                   minor
                   warning };
      }
    }

    type ItuTrendIndication {
      description "ITU trend indication values for alarms.";
      syntax {
        string = { moreSevere noChange lessSevere };
      }
    }


    type EntityAdminState {
      description
     "Represents the various possible administrative states.

      A value of 'locked' means the resource is administratively
      prohibited from use.  A value of 'shuttingDown' means that
      usage is administratively limited to current instances of
      use.  A value of 'unlocked' means the resource is not
      administratively prohibited from use.  A value of
      'unknown' means that this resource is unable to
      report administrative state.";
      syntax { 
        string = { unknown locked shuttingDown unlocked };
      }
    }

    type EntityOperState {
      description
     "Represents the possible values of operational states.

      A value of 'disabled' means the resource is totally
      inoperable.  A value of 'enabled' means the resource
      is partially or fully operable.  A value of 'testing'
      means the resource is currently being tested
      and cannot therefore report whether it is operational
      or not.  A value of 'unknown' means that this
      resource is unable to report operational state.";
      syntax {
        string = { unknown disabled enabled testing };
      }
    }

    type EntityUsageState {
      description
     "Represents the possible values of usage states.
      A value of 'idle' means the resource is servicing no
      users.  A value of 'active' means the resource is
      currently in use and it has sufficient spare capacity
      to provide for additional users.  A value of 'busy'
      means the resource is currently in use, but it
      currently has no spare capacity to provide for
      additional users.  A value of 'unknown' means
      that this resource is unable to report usage state.";
      syntax {
        string = { unknown idle active busy };
      }
    }

    type EntityAlarmStatusType {
      description
     "Enumerated values for EntityAlarmStatus list type";
      syntax {
        string = { unknown
                   underRepair
                   critical
                   major
                   minor
                   warning
                   indeterminate };
      }
    }

    type EntityAlarmStatus {
      description
     "Represents the possible values of alarm status.
      An Alarm , as defined in RFC3877, is a persistent indication
      of an error or warning condition.

      When no bits of this attribute are set, then no active
      alarms are known against this entity and it is not under
      repair.

      When the 'value of underRepair' is set, the resource is
      currently being repaired, which, depending on the
      implementation, may make the other values in this bit
      string not meaningful.

      When the value of 'critical' is set, one or more critical
      alarms are active against the resource.  When the value
      of 'major' is set, one or more major alarms are active
      against the resource.  When the value of 'minor' is set,
      one or more minor alarms are active against the resource.
      When the value of 'warning' is set, one or more warning
      alarms are active against the resource.  When the value
      of 'indeterminate' is set, one or more alarms of whose
      perceived severity cannot be determined are active
      against this resource.
      A value of 'unknown' means that this resource is
      unable to report alarm state.";
      syntax { 
        slist (7) { EntityAlarmStatusType }; 
      }
    }

    type EntityStandbyStatus {
      description
     "Represents the possible values of standby status.

      A value of 'hotStandby' means the resource is not
      providing service, but it will be immediately able to
      take over the role of the resource to be backed up,
      without the need for initialization activity, and will
      contain the same information as the resource to be
      backed up.  A value of 'coldStandy' means that the
      resource is to back up another resource, but will not
      be immediately able to take over the role of a resource
      to be backed up, and will require some initialization
      activity.  A value of 'providingService' means the
      resource is providing service.  A value of
      'unknown' means that this resource is unable to
      report standby state.";
      syntax {
        string = { unknown 
                   hotStandby
                   coldStandby
                   providingService };
      }
    }
 
    type VlanId {
      description
     "The VLAN-ID that uniquely identifies a VLAN.  This
      is the 12-bit VLAN-ID used in the VLAN Tag header.";
      syntax { uint32 (1..4094); }
    }

    type anyVlanType {
      description "Any VLAN";
      syntax { string = { any }; }
    }

    type VlanIdOrAny {
      description
     "The VLAN-ID that uniquely identifies a specific VLAN,
      or any VLAN.  The value of 'any' is used to
      indicate a wildcard, i.e., any VLAN.  This can be used
      in any situation where an object or table entry must
      refer either to a specific VLAN or to any VLAN.

      Note that a managed object that is defined using this
      datatype should clarify the meaning of 'any VLAN'.";
      syntax {
        union { VlanId anyVlanType };
      }
    }

    type noneVlanType {
      description "No VLAN.";
      syntax { string = { none }; }
    }

    type VlanIdOrNone {
      description
     "The VLAN-ID that uniquely identifies a specific VLAN,
      or no VLAN.  The value of 'none' is used to
      indicate that no VLAN-ID is present or used.  This can
      be used in any situation where an object or a table entry
      must refer either to a specific VLAN, or to no VLAN.

      Note that a managed object that is defined using this
      datatype should clarify the meaning of 'no VLAN'.";
      syntax { 
        union { VlanId noneVlanType };
      }
    }

    # added on my own
    type TruthValue {
      description "SMIv2 TruthValue enumeration.";
      syntax {
        enum = { true=1 false };
      }
    }

  }
}







