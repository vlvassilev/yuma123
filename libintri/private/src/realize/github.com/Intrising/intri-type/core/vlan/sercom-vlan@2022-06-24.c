// Code generated by protoc-gen-yang(*.c) DO NOT EDIT.

/*****************************************************************************************************
 * Copyright (C) 2017-2022 by Intrising
 *  - ian0113@intrising.com.tw
 * 
 * Generated by protoc-gen-yang@gen-yang
 * 
 *****************************************************************************************************/

#include <libxml/xmlstring.h>
#include "agt.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "procdefs.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"

#include "sercom-vlan@2022-06-24.h"
#include "../../../../../../../../.libintrishare/libintrishare.h"

#include "../../../../../../realize/github.com/Intrising/intri-type/device/sercom-device@2022-06-24.h"
#include "../../../../../../realize/github.com/golang/protobuf/ptypes/empty/sercom-empty@2022-06-24.h"

#include "../../../../../../genc-trans/github.com/Intrising/intri-type/core/vlan/intri-vlan-trans.h"
#include "../../../../../../genc-trans/github.com/Intrising/intri-type/device/intri-device-trans.h"
#include "../../../../../../genc-trans/github.com/golang/protobuf/ptypes/empty/intri-empty-trans.h"

static ncx_module_t *intri_vlan_mod;

static status_t intri_vlan_VLAN_GetConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct vlanpb_Config *out = malloc(sizeof(*out));

  vlan_VLAN_GetConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_vlan,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_vlan_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_GetStatus_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_Used *in = malloc(sizeof(*in));
  struct vlanpb_StatusMapping *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_Used(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_GetStatus(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_vlan,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_vlan_StatusMapping(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_GetManagementConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct vlanpb_ManagementConfig *out = malloc(sizeof(*out));

  vlan_VLAN_GetManagementConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_vlan,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_vlan_ManagementConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_UpdateManagementConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_ManagementConfig *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  vlan_VLAN_GetManagementConfig(out, in);
  res = build_to_priv_vlan_ManagementConfig(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_UpdateManagementConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_GetVoiceConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct vlanpb_VoiceConfig *out = malloc(sizeof(*out));

  vlan_VLAN_GetVoiceConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_vlan,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_vlan_VoiceConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_UpdateVoiceConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_VoiceConfig *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  vlan_VLAN_GetVoiceConfig(out, in);
  res = build_to_priv_vlan_VoiceConfig(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_UpdateVoiceConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_GetFiltersConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct vlanpb_FiltersConfig *out = malloc(sizeof(*out));

  vlan_VLAN_GetFiltersConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_vlan,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_vlan_FiltersConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_AddFilter_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_FilterEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_FilterEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_AddFilter(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_UpdateFilter_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_FilterEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_vlan_FilterEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_UpdateFilter(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_DeleteFilter_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_FilterEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_FilterEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_DeleteFilter(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_GetPortsConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct vlanpb_PortsConfig *out = malloc(sizeof(*out));

  vlan_VLAN_GetPortsConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_vlan,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_vlan_PortsConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_UpdatePortsConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_PortsConfig *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  vlan_VLAN_GetPortsConfig(out, in);
  res = build_to_priv_vlan_PortsConfig(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_UpdatePortsConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_GetMappingConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct vlanpb_MappingConfig *out = malloc(sizeof(*out));

  vlan_VLAN_GetMappingConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_vlan,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_vlan_MappingConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_AddMapping_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_MappingEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_MappingEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_AddMapping(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_DeleteMapping_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_MappingEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_MappingEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_DeleteMapping(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_UpdateMappingPortEntry_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_MappingPortEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_vlan_MappingPortEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_UpdateMappingPortEntry(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_GetSelectiveQinQConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct vlanpb_SelectiveQinQConfig *out = malloc(sizeof(*out));

  vlan_VLAN_GetSelectiveQinQConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_vlan,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_vlan_SelectiveQinQConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_AddSelectiveQinQ_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_SelectiveQinQTranslatedEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_SelectiveQinQTranslatedEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_AddSelectiveQinQ(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_UpdateSelectiveQinQ_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_SelectiveQinQTranslatedEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_vlan_SelectiveQinQTranslatedEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_UpdateSelectiveQinQ(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_DeleteSelectiveQinQ_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_SelectiveQinQTranslatedEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_SelectiveQinQTranslatedEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_DeleteSelectiveQinQ(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_GetProtocolBasedConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct vlanpb_ProtocolBasedConfig *out = malloc(sizeof(*out));

  vlan_VLAN_GetProtocolBasedConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_vlan,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_vlan_ProtocolBasedConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_AddProtocolBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_ProtocolBasedGroupEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_ProtocolBasedGroupEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_AddProtocolBasedGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_UpdateProtocolBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_ProtocolBasedGroupEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_vlan_ProtocolBasedGroupEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_UpdateProtocolBasedGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_DeleteProtocolBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_ProtocolBasedGroupEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_ProtocolBasedGroupEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_DeleteProtocolBasedGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_AddProtocolBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_ProtocolBasedGroupMemberEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_ProtocolBasedGroupMemberEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_AddProtocolBasedGroupMember(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_UpdateProtocolBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_ProtocolBasedGroupMemberEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_vlan_ProtocolBasedGroupMemberEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_UpdateProtocolBasedGroupMember(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_DeleteProtocolBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_ProtocolBasedGroupMemberEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_ProtocolBasedGroupMemberEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_DeleteProtocolBasedGroupMember(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_GetMACBasedConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct vlanpb_MACBasedConfig *out = malloc(sizeof(*out));

  vlan_VLAN_GetMACBasedConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_vlan,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_vlan_MACBasedConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_AddMACBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_MACBasedGroupEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_MACBasedGroupEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_AddMACBasedGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_UpdateMACBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_MACBasedGroupEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_vlan_MACBasedGroupEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_UpdateMACBasedGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_DeleteMACBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_MACBasedGroupEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_MACBasedGroupEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_DeleteMACBasedGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_AddMACBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_MACBasedGroupMemberEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_MACBasedGroupMemberEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_AddMACBasedGroupMember(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_UpdateMACBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_MACBasedGroupMemberEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_vlan_MACBasedGroupMemberEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_UpdateMACBasedGroupMember(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_DeleteMACBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_MACBasedGroupMemberEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_MACBasedGroupMemberEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_DeleteMACBasedGroupMember(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_GetSubnetBasedConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct vlanpb_SubnetBasedConfig *out = malloc(sizeof(*out));

  vlan_VLAN_GetSubnetBasedConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_vlan,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_vlan_SubnetBasedConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_AddSubnetBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_SubnetBasedGroupEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_SubnetBasedGroupEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_AddSubnetBasedGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_UpdateSubnetBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_SubnetBasedGroupEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_vlan_SubnetBasedGroupEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_UpdateSubnetBasedGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_DeleteSubnetBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_SubnetBasedGroupEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_SubnetBasedGroupEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_DeleteSubnetBasedGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_AddSubnetBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_SubnetBasedGroupMemberEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_SubnetBasedGroupMemberEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_AddSubnetBasedGroupMember(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_UpdateSubnetBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_SubnetBasedGroupMemberEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_vlan_SubnetBasedGroupMemberEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_UpdateSubnetBasedGroupMember(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_DeleteSubnetBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_SubnetBasedGroupMemberEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_vlan_SubnetBasedGroupMemberEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  vlan_VLAN_DeleteSubnetBasedGroupMember(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_vlan_VLAN_GetManagementVlanPorts_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct devicepb_PortList *out = malloc(sizeof(*out));

  vlan_VLAN_GetManagementVlanPorts(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_vlan,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_device_PortList(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}

status_t y_sercom_vlan_init(
    const xmlChar *modname,
    const xmlChar *revision) {
  status_t res = NO_ERR;
  agt_profile_t *agt_profile = agt_get_profile();

  if (xml_strcmp(modname, y_M_intri_vlan)) {
    return ERR_NCX_UNKNOWN_MODULE;
  }
  if (revision && xml_strcmp(revision, y_R_intri_vlan)) {
    return ERR_NCX_WRONG_VERSION;
  }

  res = agt_load_sil_code(
    y_M_intri_device,
    y_R_intri_device,
    true);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_load_sil_code(
    y_M_intri_empty,
    y_R_intri_empty,
    true);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = ncxmod_load_module(
      y_M_intri_vlan,
      y_R_intri_vlan,
      &agt_profile->agt_savedevQ,
      &intri_vlan_mod);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetConfig",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_GetConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetStatus",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_GetStatus_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetManagementConfig",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_GetManagementConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateManagementConfig",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_UpdateManagementConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetVoiceConfig",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_GetVoiceConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateVoiceConfig",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_UpdateVoiceConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetFiltersConfig",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_GetFiltersConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddFilter",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_AddFilter_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateFilter",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_UpdateFilter_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteFilter",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_DeleteFilter_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetPortsConfig",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_GetPortsConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdatePortsConfig",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_UpdatePortsConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetMappingConfig",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_GetMappingConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddMapping",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_AddMapping_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteMapping",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_DeleteMapping_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateMappingPortEntry",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_UpdateMappingPortEntry_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetSelectiveQinQConfig",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_GetSelectiveQinQConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddSelectiveQinQ",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_AddSelectiveQinQ_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateSelectiveQinQ",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_UpdateSelectiveQinQ_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteSelectiveQinQ",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_DeleteSelectiveQinQ_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetProtocolBasedConfig",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_GetProtocolBasedConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddProtocolBasedGroup",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_AddProtocolBasedGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateProtocolBasedGroup",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_UpdateProtocolBasedGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteProtocolBasedGroup",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_DeleteProtocolBasedGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddProtocolBasedGroupMember",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_AddProtocolBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateProtocolBasedGroupMember",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_UpdateProtocolBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteProtocolBasedGroupMember",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_DeleteProtocolBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetMACBasedConfig",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_GetMACBasedConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddMACBasedGroup",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_AddMACBasedGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateMACBasedGroup",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_UpdateMACBasedGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteMACBasedGroup",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_DeleteMACBasedGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddMACBasedGroupMember",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_AddMACBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateMACBasedGroupMember",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_UpdateMACBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteMACBasedGroupMember",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_DeleteMACBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetSubnetBasedConfig",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_GetSubnetBasedConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddSubnetBasedGroup",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_AddSubnetBasedGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateSubnetBasedGroup",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_UpdateSubnetBasedGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteSubnetBasedGroup",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_DeleteSubnetBasedGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddSubnetBasedGroupMember",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_AddSubnetBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateSubnetBasedGroupMember",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_UpdateSubnetBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteSubnetBasedGroupMember",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_DeleteSubnetBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetManagementVlanPorts",
      AGT_RPC_PH_INVOKE,
      intri_vlan_VLAN_GetManagementVlanPorts_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  return res;
}

status_t y_sercom_vlan_init2(void) {
  status_t res = NO_ERR;
  return res;
}

void y_sercom_vlan_cleanup(void) {
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetConfig");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetStatus");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetManagementConfig");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateManagementConfig");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetVoiceConfig");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateVoiceConfig");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetFiltersConfig");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddFilter");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateFilter");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteFilter");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetPortsConfig");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdatePortsConfig");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetMappingConfig");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddMapping");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteMapping");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateMappingPortEntry");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetSelectiveQinQConfig");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddSelectiveQinQ");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateSelectiveQinQ");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteSelectiveQinQ");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetProtocolBasedConfig");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddProtocolBasedGroup");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateProtocolBasedGroup");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteProtocolBasedGroup");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddProtocolBasedGroupMember");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateProtocolBasedGroupMember");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteProtocolBasedGroupMember");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetMACBasedConfig");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddMACBasedGroup");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateMACBasedGroup");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteMACBasedGroup");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddMACBasedGroupMember");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateMACBasedGroupMember");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteMACBasedGroupMember");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetSubnetBasedConfig");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddSubnetBasedGroup");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateSubnetBasedGroup");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteSubnetBasedGroup");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-AddSubnetBasedGroupMember");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-UpdateSubnetBasedGroupMember");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-DeleteSubnetBasedGroupMember");
  agt_rpc_unregister_method(
      y_M_intri_vlan,
      "sercom-vlan-VLAN-GetManagementVlanPorts");
}
