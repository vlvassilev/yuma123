// Code generated by protoc-gen-yang. DO NOT EDIT.


/* ****************************************************************************************************
 * Import Path : "github.com/envoyproxy/protoc-gen-validate/validate"                                 *
 * Dir Path    : github.com/envoyproxy/protoc-gen-validate/validate                                   *
 * Go Package  : validate                                                                             *
 * Files       : 1                                                                                    *
 **************************************************************************************************** */
module intri-validate {

  namespace "intri:intri-validate";

  prefix "intri-validate";

  organization "
    Intrising Inc.";

  contact "
    intrising@intrising.com.tw";

  revision 2022-06-24 {
    description "Build date.";
  }

  import intri-duration {
    prefix intri-duration;
  }
  import intri-timestamp {
    prefix intri-timestamp;
  }


  /* **************************************************************************************************
   * Enums       : 1                                                                                  *
   ************************************************************************************************** */
  /* validate.proto */
  typedef KnownRegex {
    type enumeration {
      enum UNKNOWN {
        description "";
        value 0;
      }
      enum HTTP_HEADER_NAME {
        description "HTTP header name as defined by RFC 7230.";
        value 1;
      }
      enum HTTP_HEADER_VALUE {
        description "HTTP header value as defined by RFC 7230.";
        value 2;
      }
    }
  }


  /* **************************************************************************************************
   * Msgs        : 23                                                                                 *
   ************************************************************************************************** */
  /* validate.proto */
  grouping FieldRules {
    container Message {
      uses MessageRules;
    }
    choice Type {
      container Float {
        uses FloatRules;
      }
      container Double {
        uses DoubleRules;
      }
      container Int32 {
        uses Int32Rules;
      }
      container Int64 {
        uses Int64Rules;
      }
      container Uint32 {
        uses UInt32Rules;
      }
      container Uint64 {
        uses UInt64Rules;
      }
      container Sint32 {
        uses SInt32Rules;
      }
      container Sint64 {
        uses SInt64Rules;
      }
      container Fixed32 {
        uses Fixed32Rules;
      }
      container Fixed64 {
        uses Fixed64Rules;
      }
      container Sfixed32 {
        uses SFixed32Rules;
      }
      container Sfixed64 {
        uses SFixed64Rules;
      }
      container Bool {
        uses BoolRules;
      }
      container String_ {
        uses StringRules;
      }
      container Bytes {
        uses BytesRules;
      }
      container Enum {
        uses EnumRules;
      }
      container Repeated {
        uses RepeatedRules;
      }
      container Map {
        uses MapRules;
      }
      container Any {
        uses AnyRules;
      }
      container Duration {
        uses DurationRules;
      }
      container Timestamp {
        uses TimestampRules;
      }
    }
  }
  /* validate.proto */
  grouping FloatRules {
    leaf Const {
      type decimal64 {
        fraction-digits 2;
      }
    }
    leaf Lt {
      type decimal64 {
        fraction-digits 2;
      }
    }
    leaf Lte {
      type decimal64 {
        fraction-digits 2;
      }
    }
    leaf Gt {
      type decimal64 {
        fraction-digits 2;
      }
    }
    leaf Gte {
      type decimal64 {
        fraction-digits 2;
      }
    }
    container In {
      leaf-list In_Entry {
        type decimal64 {
          fraction-digits 2;
        }
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type decimal64 {
          fraction-digits 2;
        }
      }
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping DoubleRules {
    leaf Const {
      type decimal64 {
        fraction-digits 2;
      }
    }
    leaf Lt {
      type decimal64 {
        fraction-digits 2;
      }
    }
    leaf Lte {
      type decimal64 {
        fraction-digits 2;
      }
    }
    leaf Gt {
      type decimal64 {
        fraction-digits 2;
      }
    }
    leaf Gte {
      type decimal64 {
        fraction-digits 2;
      }
    }
    container In {
      leaf-list In_Entry {
        type decimal64 {
          fraction-digits 2;
        }
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type decimal64 {
          fraction-digits 2;
        }
      }
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping Int32Rules {
    leaf Const {
      type int32;
    }
    leaf Lt {
      type int32;
    }
    leaf Lte {
      type int32;
    }
    leaf Gt {
      type int32;
    }
    leaf Gte {
      type int32;
    }
    container In {
      leaf-list In_Entry {
        type int32;
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type int32;
      }
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping Int64Rules {
    leaf Const {
      type int64;
    }
    leaf Lt {
      type int64;
    }
    leaf Lte {
      type int64;
    }
    leaf Gt {
      type int64;
    }
    leaf Gte {
      type int64;
    }
    container In {
      leaf-list In_Entry {
        type int64;
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type int64;
      }
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping UInt32Rules {
    leaf Const {
      type uint32;
    }
    leaf Lt {
      type uint32;
    }
    leaf Lte {
      type uint32;
    }
    leaf Gt {
      type uint32;
    }
    leaf Gte {
      type uint32;
    }
    container In {
      leaf-list In_Entry {
        type uint32;
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type uint32;
      }
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping UInt64Rules {
    leaf Const {
      type uint64;
    }
    leaf Lt {
      type uint64;
    }
    leaf Lte {
      type uint64;
    }
    leaf Gt {
      type uint64;
    }
    leaf Gte {
      type uint64;
    }
    container In {
      leaf-list In_Entry {
        type uint64;
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type uint64;
      }
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping SInt32Rules {
    leaf Const {
      type int32;
    }
    leaf Lt {
      type int32;
    }
    leaf Lte {
      type int32;
    }
    leaf Gt {
      type int32;
    }
    leaf Gte {
      type int32;
    }
    container In {
      leaf-list In_Entry {
        type int32;
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type int32;
      }
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping SInt64Rules {
    leaf Const {
      type int64;
    }
    leaf Lt {
      type int64;
    }
    leaf Lte {
      type int64;
    }
    leaf Gt {
      type int64;
    }
    leaf Gte {
      type int64;
    }
    container In {
      leaf-list In_Entry {
        type int64;
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type int64;
      }
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping Fixed32Rules {
    leaf Const {
      type uint32;
    }
    leaf Lt {
      type uint32;
    }
    leaf Lte {
      type uint32;
    }
    leaf Gt {
      type uint32;
    }
    leaf Gte {
      type uint32;
    }
    container In {
      leaf-list In_Entry {
        type uint32;
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type uint32;
      }
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping Fixed64Rules {
    leaf Const {
      type uint64;
    }
    leaf Lt {
      type uint64;
    }
    leaf Lte {
      type uint64;
    }
    leaf Gt {
      type uint64;
    }
    leaf Gte {
      type uint64;
    }
    container In {
      leaf-list In_Entry {
        type uint64;
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type uint64;
      }
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping SFixed32Rules {
    leaf Const {
      type int32;
    }
    leaf Lt {
      type int32;
    }
    leaf Lte {
      type int32;
    }
    leaf Gt {
      type int32;
    }
    leaf Gte {
      type int32;
    }
    container In {
      leaf-list In_Entry {
        type int32;
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type int32;
      }
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping SFixed64Rules {
    leaf Const {
      type int64;
    }
    leaf Lt {
      type int64;
    }
    leaf Lte {
      type int64;
    }
    leaf Gt {
      type int64;
    }
    leaf Gte {
      type int64;
    }
    container In {
      leaf-list In_Entry {
        type int64;
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type int64;
      }
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping BoolRules {
    leaf Const {
      type boolean;
    }
  }
  /* validate.proto */
  grouping StringRules {
    leaf Const {
      type string;
    }
    leaf Len {
      type uint64;
    }
    leaf MinLen {
      type uint64;
    }
    leaf MaxLen {
      type uint64;
    }
    leaf LenBytes {
      type uint64;
    }
    leaf MinBytes {
      type uint64;
    }
    leaf MaxBytes {
      type uint64;
    }
    leaf Pattern {
      type string;
    }
    leaf Prefix {
      type string;
    }
    leaf Suffix {
      type string;
    }
    leaf Contains {
      type string;
    }
    leaf NotContains {
      type string;
    }
    container In {
      leaf-list In_Entry {
        type string;
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type string;
      }
    }
    choice WellKnown {
      leaf Email {
        type boolean;
      }
      leaf Hostname {
        type boolean;
      }
      leaf Ip {
        type boolean;
      }
      leaf Ipv4 {
        type boolean;
      }
      leaf Ipv6 {
        type boolean;
      }
      leaf Uri {
        type boolean;
      }
      leaf UriRef {
        type boolean;
      }
      leaf Address {
        type boolean;
      }
      leaf Uuid {
        type boolean;
      }
      leaf WellKnownRegex {
        type KnownRegex;
      }
    }
    leaf Strict {
      type boolean;
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping BytesRules {
    leaf Const {
      type uint8;
    }
    leaf Len {
      type uint64;
    }
    leaf MinLen {
      type uint64;
    }
    leaf MaxLen {
      type uint64;
    }
    leaf Pattern {
      type string;
    }
    leaf Prefix {
      type uint8;
    }
    leaf Suffix {
      type uint8;
    }
    leaf Contains {
      type uint8;
    }
    container In {
      leaf-list In_Entry {
        type uint8;
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type uint8;
      }
    }
    choice WellKnown {
      leaf Ip {
        type boolean;
      }
      leaf Ipv4 {
        type boolean;
      }
      leaf Ipv6 {
        type boolean;
      }
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping EnumRules {
    leaf Const {
      type int32;
    }
    leaf DefinedOnly {
      type boolean;
    }
    container In {
      leaf-list In_Entry {
        type int32;
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type int32;
      }
    }
  }
  /* validate.proto */
  grouping MessageRules {
    leaf Skip {
      type boolean;
    }
    leaf Required {
      type boolean;
    }
  }
  /* validate.proto */
  grouping RepeatedRules {
    leaf MinItems {
      type uint64;
    }
    leaf MaxItems {
      type uint64;
    }
    leaf Unique {
      type boolean;
    }
    container Items {
      uses FieldRules;
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping MapRules {
    leaf MinPairs {
      type uint64;
    }
    leaf MaxPairs {
      type uint64;
    }
    leaf NoSparse {
      type boolean;
    }
    container Keys {
      uses FieldRules;
    }
    container Values {
      uses FieldRules;
    }
    leaf IgnoreEmpty {
      type boolean;
    }
  }
  /* validate.proto */
  grouping AnyRules {
    leaf Required {
      type boolean;
    }
    container In {
      leaf-list In_Entry {
        type string;
      }
    }
    container NotIn {
      leaf-list NotIn_Entry {
        type string;
      }
    }
  }
  /* validate.proto */
  grouping DurationRules {
    leaf Required {
      type boolean;
    }
    container Const {
      uses intri-duration:Duration;
    }
    container Lt {
      uses intri-duration:Duration;
    }
    container Lte {
      uses intri-duration:Duration;
    }
    container Gt {
      uses intri-duration:Duration;
    }
    container Gte {
      uses intri-duration:Duration;
    }
    container In {
      list In_Entry {
        uses intri-duration:Duration;
      }
    }
    container NotIn {
      list NotIn_Entry {
        uses intri-duration:Duration;
      }
    }
  }
  /* validate.proto */
  grouping TimestampRules {
    leaf Required {
      type boolean;
    }
    container Const {
      uses intri-timestamp:Timestamp;
    }
    container Lt {
      uses intri-timestamp:Timestamp;
    }
    container Lte {
      uses intri-timestamp:Timestamp;
    }
    container Gt {
      uses intri-timestamp:Timestamp;
    }
    container Gte {
      uses intri-timestamp:Timestamp;
    }
    leaf LtNow {
      type boolean;
    }
    leaf GtNow {
      type boolean;
    }
    container Within {
      uses intri-duration:Duration;
    }
  }

}
