// Code generated by protoc-gen-yang(*.c) DO NOT EDIT.

/*****************************************************************************************************
 * Copyright (C) 2017-2022 by Intrising
 *  - ian0113@intrising.com.tw
 * 
 * Generated by protoc-gen-yang@gen-yang
 * 
 *****************************************************************************************************/

#include <libxml/xmlstring.h>
#include "agt.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "procdefs.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"

#include "intri-multicast-trans.h"
#include "../../../../../../../../.libintrishare/libintrishare.h"

#include "../../../../../github.com/Intrising/intri-type/common/intri-common-trans.h"
#include "../../../../../github.com/Intrising/intri-type/device/intri-device-trans.h"
#include "../../../../../github.com/golang/protobuf/ptypes/empty/intri-empty-trans.h"

status_t build_to_xml_multicast_Config(
    val_value_t *parentval,
    struct multicastpb_Config *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "IGMPSnoopingGlobalEnabled",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->IGMPSnoopingGlobalEnabled;
  childval = agt_make_object(
      parentval->obj,
      "MLDSnoopingGlobalEnabled",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->MLDSnoopingGlobalEnabled;
  childval = agt_make_object(
      parentval->obj,
      "IGMPConfig",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_multicast_Snooping(
      childval,
      entry->IGMPConfig);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "MLDConfig",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_multicast_Snooping(
      childval,
      entry->MLDConfig);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "RouterConfig",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_multicast_RouterPort(
      childval,
      entry->RouterConfig);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "UnregisterConfig",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_multicast_UnregisterFlood(
      childval,
      entry->UnregisterConfig);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "StaticGroups",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_multicast_Static(
      childval,
      entry->StaticGroups);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_multicast_Snooping(
    val_value_t *parentval,
    struct multicastpb_Snooping *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VlanList",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->VlanList_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "VlanList_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_multicast_SnoopingConfigEntry(
        listval,
        entry->VlanList[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_multicast_SnoopingConfigEntry(
    val_value_t *parentval,
    struct multicastpb_SnoopingConfigEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VlanID",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->VlanID;
  childval = agt_make_object(
      parentval->obj,
      "SnoopingEnabled",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->SnoopingEnabled;
  childval = agt_make_object(
      parentval->obj,
      "QuerierVersion",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->QuerierVersion) {
    case multicastpb_VersionTypeOptions_VERSION_TYPE_IGMP_V1:
      enum_str = "VERSION_TYPE_IGMP_V1";
      break;
    case multicastpb_VersionTypeOptions_VERSION_TYPE_IGMP_V2:
      enum_str = "VERSION_TYPE_IGMP_V2";
      break;
    case multicastpb_VersionTypeOptions_VERSION_TYPE_IGMP_V3:
      enum_str = "VERSION_TYPE_IGMP_V3";
      break;
    case multicastpb_VersionTypeOptions_VERSION_TYPE_MLD_V1:
      enum_str = "VERSION_TYPE_MLD_V1";
      break;
    case multicastpb_VersionTypeOptions_VERSION_TYPE_MLD_V2:
      enum_str = "VERSION_TYPE_MLD_V2";
      break;
    case multicastpb_VersionTypeOptions_VERSION_TYPE_DISABLED:
      enum_str = "VERSION_TYPE_DISABLED";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "MulticastRouterDetection",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->MulticastRouterDetection) {
    case multicastpb_RouterDetectionTypeOptions_ROUTER_DETECTION_TYPE_QUERY_MESSAGE:
      enum_str = "ROUTER_DETECTION_TYPE_QUERY_MESSAGE";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "EnableFastLeave",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->EnableFastLeave;
  childval = agt_make_object(
      parentval->obj,
      "EnableReportSuppression",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->EnableReportSuppression;
  childval = agt_make_object(
      parentval->obj,
      "GroupLimit",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->GroupLimit;
  childval = agt_make_object(
      parentval->obj,
      "GroupMembershipInterval",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->GroupMembershipInterval;
  childval = agt_make_object(
      parentval->obj,
      "LastMemberQueryTime",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->LastMemberQueryTime;
  childval = agt_make_object(
      parentval->obj,
      "MaxResponseTime",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->MaxResponseTime;
  childval = agt_make_object(
      parentval->obj,
      "RouterAgingTime",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->RouterAgingTime;
  childval = agt_make_object(
      parentval->obj,
      "StartQueryCount",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->StartQueryCount;
  childval = agt_make_object(
      parentval->obj,
      "StartQueryInterval",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->StartQueryInterval;
  childval = agt_make_object(
      parentval->obj,
      "QueryInterval",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->QueryInterval;
  childval = agt_make_object(
      parentval->obj,
      "Robustness",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->Robustness;
  childval = agt_make_object(
      parentval->obj,
      "IdentifyiesConfig",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->IdentifyiesConfig_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "IdentifyiesConfig_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_multicast_PortEnabledEntry(
        listval,
        entry->IdentifyiesConfig[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_multicast_UnregisterFlood(
    val_value_t *parentval,
    struct multicastpb_UnregisterFlood *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VlanList",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->VlanList_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "VlanList_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_multicast_UnregisterFloodVlan(
        listval,
        entry->VlanList[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_multicast_UnregisterFloodVlan(
    val_value_t *parentval,
    struct multicastpb_UnregisterFloodVlan *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VlanID",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->VlanID;
  childval = agt_make_object(
      parentval->obj,
      "Enabled",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->Enabled;
  return res;
}
status_t build_to_xml_multicast_RouterPort(
    val_value_t *parentval,
    struct multicastpb_RouterPort *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VlanList",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->VlanList_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "VlanList_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_multicast_RouterPortVlanEntry(
        listval,
        entry->VlanList[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_multicast_RouterPortVlanEntry(
    val_value_t *parentval,
    struct multicastpb_RouterPortVlanEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VlanID",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->VlanID;
  childval = agt_make_object(
      parentval->obj,
      "PortList",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->PortList_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "PortList_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_multicast_PortEnabledEntry(
        listval,
        entry->PortList[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_multicast_PortEnabledEntry(
    val_value_t *parentval,
    struct multicastpb_PortEnabledEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "IdentifyNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_InterfaceIdentify(
      childval,
      entry->IdentifyNo);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Enabled",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->Enabled;
  return res;
}
status_t build_to_xml_multicast_Static(
    val_value_t *parentval,
    struct multicastpb_Static *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "List",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->List_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "List_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_multicast_StaticGroupsConfigEntry(
        listval,
        entry->List[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_multicast_StaticGroupsConfigEntry(
    val_value_t *parentval,
    struct multicastpb_StaticGroupsConfigEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VlanID",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->VlanID;
  childval = agt_make_object(
      parentval->obj,
      "Name",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Name;
  childval = agt_make_object(
      parentval->obj,
      "MulticastAddress",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->MulticastAddress;
  childval = agt_make_object(
      parentval->obj,
      "ForwardingPort",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_PortList(
      childval,
      entry->ForwardingPort);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_multicast_IGMPStatistics(
    val_value_t *parentval,
    struct multicastpb_IGMPStatistics *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "List",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->List_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "List_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_multicast_IGMPStatisticEntry(
        listval,
        entry->List[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_multicast_IGMPStatisticEntry(
    val_value_t *parentval,
    struct multicastpb_IGMPStatisticEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VlanID",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->VlanID;
  childval = agt_make_object(
      parentval->obj,
      "RxGeneralQueries",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->RxGeneralQueries;
  childval = agt_make_object(
      parentval->obj,
      "RxV3Reports",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->RxV3Reports;
  childval = agt_make_object(
      parentval->obj,
      "RxV2Reports",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->RxV2Reports;
  childval = agt_make_object(
      parentval->obj,
      "RxV2Leaves",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->RxV2Leaves;
  childval = agt_make_object(
      parentval->obj,
      "RxV1Reports",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->RxV1Reports;
  childval = agt_make_object(
      parentval->obj,
      "Querier",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->Querier;
  return res;
}
status_t build_to_xml_multicast_RouterStatus(
    val_value_t *parentval,
    struct multicastpb_RouterStatus *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VlanList",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->VlanList_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "VlanList_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_multicast_RouterStatusEntry(
        listval,
        entry->VlanList[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_multicast_RouterStatusEntry(
    val_value_t *parentval,
    struct multicastpb_RouterStatusEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VlanID",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->VlanID;
  childval = agt_make_object(
      parentval->obj,
      "List",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->List_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "List_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_multicast_RouterPortStatusEntry(
        listval,
        entry->List[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_multicast_RouterPortStatusEntry(
    val_value_t *parentval,
    struct multicastpb_RouterPortStatusEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Type",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->Type) {
    case multicastpb_ProtocolTypeOptions_PROTOCOL_TYPE_NONE:
      enum_str = "PROTOCOL_TYPE_NONE";
      break;
    case multicastpb_ProtocolTypeOptions_PROTOCOL_TYPE_IGMP:
      enum_str = "PROTOCOL_TYPE_IGMP";
      break;
    case multicastpb_ProtocolTypeOptions_PROTOCOL_TYPE_MLD:
      enum_str = "PROTOCOL_TYPE_MLD";
      break;
    case multicastpb_ProtocolTypeOptions_PROTOCOL_TYPE_BOTH:
      enum_str = "PROTOCOL_TYPE_BOTH";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "Status",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->Status) {
    case multicastpb_RouterStatusTypeOptions_ROUTER_STATUS_TYPE_DISABLED:
      enum_str = "ROUTER_STATUS_TYPE_DISABLED";
      break;
    case multicastpb_RouterStatusTypeOptions_ROUTER_STATUS_TYPE_DYNAMIC:
      enum_str = "ROUTER_STATUS_TYPE_DYNAMIC";
      break;
    case multicastpb_RouterStatusTypeOptions_ROUTER_STATUS_TYPE_STATIC:
      enum_str = "ROUTER_STATUS_TYPE_STATIC";
      break;
    case multicastpb_RouterStatusTypeOptions_ROUTER_STATUS_TYPE_BOTH:
      enum_str = "ROUTER_STATUS_TYPE_BOTH";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "IdentifyNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_InterfaceIdentify(
      childval,
      entry->IdentifyNo);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_multicast_DynamicGroups(
    val_value_t *parentval,
    struct multicastpb_DynamicGroups *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "List",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->List_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "List_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_multicast_DynamicGroupEntry(
        listval,
        entry->List[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_multicast_DynamicGroupEntry(
    val_value_t *parentval,
    struct multicastpb_DynamicGroupEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VlanID",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->VlanID;
  childval = agt_make_object(
      parentval->obj,
      "Address",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Address;
  childval = agt_make_object(
      parentval->obj,
      "TTL",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->TTL;
  childval = agt_make_object(
      parentval->obj,
      "IdentifyList",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->IdentifyList_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "IdentifyList_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_InterfaceIdentify(
        listval,
        entry->IdentifyList[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_multicast_MLDStatistics(
    val_value_t *parentval,
    struct multicastpb_MLDStatistics *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "List",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->List_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "List_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_multicast_MLDStatisticEntry(
        listval,
        entry->List[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_multicast_MLDStatisticEntry(
    val_value_t *parentval,
    struct multicastpb_MLDStatisticEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VlanID",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->VlanID;
  childval = agt_make_object(
      parentval->obj,
      "RxGeneralQueries",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->RxGeneralQueries;
  childval = agt_make_object(
      parentval->obj,
      "RxV2Reports",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->RxV2Reports;
  childval = agt_make_object(
      parentval->obj,
      "RxV1Reports",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->RxV1Reports;
  childval = agt_make_object(
      parentval->obj,
      "RxV1Leaves",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->RxV1Leaves;
  childval = agt_make_object(
      parentval->obj,
      "Querier",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->Querier;
  return res;
}
status_t build_to_xml_multicast_VlanList(
    val_value_t *parentval,
    struct multicastpb_VlanList *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "List",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->List_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "List_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* int32 */
    VAL_INT(listval) = entry->List[i];
  }
  return res;
}

status_t build_to_priv_multicast_Config(
    val_value_t *parentval,
    struct multicastpb_Config *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "IGMPSnoopingGlobalEnabled");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->IGMPSnoopingGlobalEnabled = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MLDSnoopingGlobalEnabled");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->MLDSnoopingGlobalEnabled = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "IGMPConfig");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->IGMPConfig = malloc(sizeof(*(entry->IGMPConfig)));
    res = build_to_priv_multicast_Snooping(
        childval,
        entry->IGMPConfig);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "MLDConfig");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->MLDConfig = malloc(sizeof(*(entry->MLDConfig)));
    res = build_to_priv_multicast_Snooping(
        childval,
        entry->MLDConfig);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "RouterConfig");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->RouterConfig = malloc(sizeof(*(entry->RouterConfig)));
    res = build_to_priv_multicast_RouterPort(
        childval,
        entry->RouterConfig);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "UnregisterConfig");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->UnregisterConfig = malloc(sizeof(*(entry->UnregisterConfig)));
    res = build_to_priv_multicast_UnregisterFlood(
        childval,
        entry->UnregisterConfig);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "StaticGroups");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->StaticGroups = malloc(sizeof(*(entry->StaticGroups)));
    res = build_to_priv_multicast_Static(
        childval,
        entry->StaticGroups);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_multicast_Snooping(
    val_value_t *parentval,
    struct multicastpb_Snooping *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VlanList");
  entry->VlanList_Len = 0;
  entry->VlanList = malloc(sizeof(*entry->VlanList));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->VlanList_Len = dlq_count(&childval->v.childQ);
    entry->VlanList = malloc((entry->VlanList_Len + 1) * sizeof(*entry->VlanList));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->VlanList[cnt] = malloc(sizeof(*(entry->VlanList[cnt])));
      res = build_to_priv_multicast_SnoopingConfigEntry(
          listval,
          entry->VlanList[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_multicast_SnoopingConfigEntry(
    val_value_t *parentval,
    struct multicastpb_SnoopingConfigEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VlanID");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->VlanID = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "SnoopingEnabled");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->SnoopingEnabled = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "QuerierVersion");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->QuerierVersion = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MulticastRouterDetection");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->MulticastRouterDetection = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "EnableFastLeave");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->EnableFastLeave = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "EnableReportSuppression");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->EnableReportSuppression = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "GroupLimit");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->GroupLimit = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "GroupMembershipInterval");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->GroupMembershipInterval = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "LastMemberQueryTime");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->LastMemberQueryTime = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MaxResponseTime");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->MaxResponseTime = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "RouterAgingTime");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->RouterAgingTime = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "StartQueryCount");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->StartQueryCount = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "StartQueryInterval");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->StartQueryInterval = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "QueryInterval");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->QueryInterval = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Robustness");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->Robustness = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "IdentifyiesConfig");
  entry->IdentifyiesConfig_Len = 0;
  entry->IdentifyiesConfig = malloc(sizeof(*entry->IdentifyiesConfig));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->IdentifyiesConfig_Len = dlq_count(&childval->v.childQ);
    entry->IdentifyiesConfig = malloc((entry->IdentifyiesConfig_Len + 1) * sizeof(*entry->IdentifyiesConfig));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->IdentifyiesConfig[cnt] = malloc(sizeof(*(entry->IdentifyiesConfig[cnt])));
      res = build_to_priv_multicast_PortEnabledEntry(
          listval,
          entry->IdentifyiesConfig[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_multicast_UnregisterFlood(
    val_value_t *parentval,
    struct multicastpb_UnregisterFlood *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VlanList");
  entry->VlanList_Len = 0;
  entry->VlanList = malloc(sizeof(*entry->VlanList));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->VlanList_Len = dlq_count(&childval->v.childQ);
    entry->VlanList = malloc((entry->VlanList_Len + 1) * sizeof(*entry->VlanList));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->VlanList[cnt] = malloc(sizeof(*(entry->VlanList[cnt])));
      res = build_to_priv_multicast_UnregisterFloodVlan(
          listval,
          entry->VlanList[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_multicast_UnregisterFloodVlan(
    val_value_t *parentval,
    struct multicastpb_UnregisterFloodVlan *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VlanID");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->VlanID = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Enabled");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->Enabled = VAL_BOOL(childval);
  }
  return res;
}
status_t build_to_priv_multicast_RouterPort(
    val_value_t *parentval,
    struct multicastpb_RouterPort *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VlanList");
  entry->VlanList_Len = 0;
  entry->VlanList = malloc(sizeof(*entry->VlanList));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->VlanList_Len = dlq_count(&childval->v.childQ);
    entry->VlanList = malloc((entry->VlanList_Len + 1) * sizeof(*entry->VlanList));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->VlanList[cnt] = malloc(sizeof(*(entry->VlanList[cnt])));
      res = build_to_priv_multicast_RouterPortVlanEntry(
          listval,
          entry->VlanList[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_multicast_RouterPortVlanEntry(
    val_value_t *parentval,
    struct multicastpb_RouterPortVlanEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VlanID");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->VlanID = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "PortList");
  entry->PortList_Len = 0;
  entry->PortList = malloc(sizeof(*entry->PortList));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->PortList_Len = dlq_count(&childval->v.childQ);
    entry->PortList = malloc((entry->PortList_Len + 1) * sizeof(*entry->PortList));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->PortList[cnt] = malloc(sizeof(*(entry->PortList[cnt])));
      res = build_to_priv_multicast_PortEnabledEntry(
          listval,
          entry->PortList[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_multicast_PortEnabledEntry(
    val_value_t *parentval,
    struct multicastpb_PortEnabledEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "IdentifyNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->IdentifyNo = malloc(sizeof(*(entry->IdentifyNo)));
    res = build_to_priv_device_InterfaceIdentify(
        childval,
        entry->IdentifyNo);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Enabled");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->Enabled = VAL_BOOL(childval);
  }
  return res;
}
status_t build_to_priv_multicast_Static(
    val_value_t *parentval,
    struct multicastpb_Static *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "List");
  entry->List_Len = 0;
  entry->List = malloc(sizeof(*entry->List));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->List_Len = dlq_count(&childval->v.childQ);
    entry->List = malloc((entry->List_Len + 1) * sizeof(*entry->List));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->List[cnt] = malloc(sizeof(*(entry->List[cnt])));
      res = build_to_priv_multicast_StaticGroupsConfigEntry(
          listval,
          entry->List[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_multicast_StaticGroupsConfigEntry(
    val_value_t *parentval,
    struct multicastpb_StaticGroupsConfigEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VlanID");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->VlanID = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Name");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Name = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MulticastAddress");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->MulticastAddress = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "ForwardingPort");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->ForwardingPort = malloc(sizeof(*(entry->ForwardingPort)));
    res = build_to_priv_device_PortList(
        childval,
        entry->ForwardingPort);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_multicast_IGMPStatistics(
    val_value_t *parentval,
    struct multicastpb_IGMPStatistics *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "List");
  entry->List_Len = 0;
  entry->List = malloc(sizeof(*entry->List));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->List_Len = dlq_count(&childval->v.childQ);
    entry->List = malloc((entry->List_Len + 1) * sizeof(*entry->List));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->List[cnt] = malloc(sizeof(*(entry->List[cnt])));
      res = build_to_priv_multicast_IGMPStatisticEntry(
          listval,
          entry->List[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_multicast_IGMPStatisticEntry(
    val_value_t *parentval,
    struct multicastpb_IGMPStatisticEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VlanID");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->VlanID = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "RxGeneralQueries");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->RxGeneralQueries = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "RxV3Reports");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->RxV3Reports = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "RxV2Reports");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->RxV2Reports = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "RxV2Leaves");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->RxV2Leaves = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "RxV1Reports");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->RxV1Reports = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Querier");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->Querier = VAL_BOOL(childval);
  }
  return res;
}
status_t build_to_priv_multicast_RouterStatus(
    val_value_t *parentval,
    struct multicastpb_RouterStatus *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VlanList");
  entry->VlanList_Len = 0;
  entry->VlanList = malloc(sizeof(*entry->VlanList));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->VlanList_Len = dlq_count(&childval->v.childQ);
    entry->VlanList = malloc((entry->VlanList_Len + 1) * sizeof(*entry->VlanList));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->VlanList[cnt] = malloc(sizeof(*(entry->VlanList[cnt])));
      res = build_to_priv_multicast_RouterStatusEntry(
          listval,
          entry->VlanList[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_multicast_RouterStatusEntry(
    val_value_t *parentval,
    struct multicastpb_RouterStatusEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VlanID");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->VlanID = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "List");
  entry->List_Len = 0;
  entry->List = malloc(sizeof(*entry->List));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->List_Len = dlq_count(&childval->v.childQ);
    entry->List = malloc((entry->List_Len + 1) * sizeof(*entry->List));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->List[cnt] = malloc(sizeof(*(entry->List[cnt])));
      res = build_to_priv_multicast_RouterPortStatusEntry(
          listval,
          entry->List[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_multicast_RouterPortStatusEntry(
    val_value_t *parentval,
    struct multicastpb_RouterPortStatusEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Type");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->Type = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Status");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->Status = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "IdentifyNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->IdentifyNo = malloc(sizeof(*(entry->IdentifyNo)));
    res = build_to_priv_device_InterfaceIdentify(
        childval,
        entry->IdentifyNo);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_multicast_DynamicGroups(
    val_value_t *parentval,
    struct multicastpb_DynamicGroups *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "List");
  entry->List_Len = 0;
  entry->List = malloc(sizeof(*entry->List));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->List_Len = dlq_count(&childval->v.childQ);
    entry->List = malloc((entry->List_Len + 1) * sizeof(*entry->List));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->List[cnt] = malloc(sizeof(*(entry->List[cnt])));
      res = build_to_priv_multicast_DynamicGroupEntry(
          listval,
          entry->List[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_multicast_DynamicGroupEntry(
    val_value_t *parentval,
    struct multicastpb_DynamicGroupEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VlanID");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->VlanID = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Address");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Address = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "TTL");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->TTL = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "IdentifyList");
  entry->IdentifyList_Len = 0;
  entry->IdentifyList = malloc(sizeof(*entry->IdentifyList));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->IdentifyList_Len = dlq_count(&childval->v.childQ);
    entry->IdentifyList = malloc((entry->IdentifyList_Len + 1) * sizeof(*entry->IdentifyList));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->IdentifyList[cnt] = malloc(sizeof(*(entry->IdentifyList[cnt])));
      res = build_to_priv_device_InterfaceIdentify(
          listval,
          entry->IdentifyList[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_multicast_MLDStatistics(
    val_value_t *parentval,
    struct multicastpb_MLDStatistics *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "List");
  entry->List_Len = 0;
  entry->List = malloc(sizeof(*entry->List));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->List_Len = dlq_count(&childval->v.childQ);
    entry->List = malloc((entry->List_Len + 1) * sizeof(*entry->List));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->List[cnt] = malloc(sizeof(*(entry->List[cnt])));
      res = build_to_priv_multicast_MLDStatisticEntry(
          listval,
          entry->List[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_multicast_MLDStatisticEntry(
    val_value_t *parentval,
    struct multicastpb_MLDStatisticEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VlanID");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->VlanID = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "RxGeneralQueries");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->RxGeneralQueries = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "RxV2Reports");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->RxV2Reports = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "RxV1Reports");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->RxV1Reports = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "RxV1Leaves");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->RxV1Leaves = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Querier");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->Querier = VAL_BOOL(childval);
  }
  return res;
}
status_t build_to_priv_multicast_VlanList(
    val_value_t *parentval,
    struct multicastpb_VlanList *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "List");
  entry->List_Len = 0;
  entry->List = malloc(sizeof(*entry->List));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->List_Len = dlq_count(&childval->v.childQ);
    entry->List = malloc((entry->List_Len + 1) * sizeof(*entry->List));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* int32 */
      entry->List[cnt] = VAL_INT(listval);
      cnt++;
    }
  }
  return res;
}
