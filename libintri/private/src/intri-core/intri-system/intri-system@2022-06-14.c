
/*
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.13-0

  Combined SIL module
  module intri-system
  revision 2022-06-14
  namespace intri:intri-system
  organization Intrising Inc.

 */

#include <libxml/xmlstring.h>

#include "../../../../.libintrishare/libintrishare.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "intri-system.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "procdefs.h"
#include "status.h"

/* module static variables */
static ncx_module_t *intri_system_mod;
static obj_template_t *intri_system_obj;
static val_value_t *intri_system_val;

/* put your static variables here */

/********************************************************************
 * FUNCTION y_intri_system_init_static_vars
 *
 * initialize module static variables
 *
 ********************************************************************/
static void y_intri_system_init_static_vars(void) {
  intri_system_mod = NULL;
  intri_system_obj = NULL;
  intri_system_val = NULL;

  /* init your static variables here */

} /* y_intri_system_init_static_vars */

/********************************************************************
 * FUNCTION intri_system_intri_system_status_get
 *
 * Get database object callback
 * Path: /intri-system/status/Status_Uptime
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_system_intri_system_status_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_system_intri_system_status_get");
  }

  /* calls the private api */
  struct emptypb_Empty in;
  struct systempb_Status out;
  system_System_GetStatus(&in, &out);

  val_value_t *child_val;

  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_system_N_Status_LastBootTime,
      out.LastBootTime,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }

  child_val = agt_make_int64_leaf(
      dstval->obj,
      y_intri_system_N_Status_Uptime,
      out.Uptime,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }

  return res;
} /* intri_system_intri_system_status_get */

/********************************************************************
 * FUNCTION intri_system_intri_system_status_mro
 *
 * Make read-only child nodes
 * Path: /intri-system/status
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_system_intri_system_status_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* init /intri-system/intri-system/status */
  val_init_virtual(
      parentval,
      intri_system_intri_system_status_get,
      parentval->obj);

  return res;

} /* intri_system_intri_system_status_mro */

/********************************************************************
 * FUNCTION intri_system_intri_system_config_get
 *
 * Get database object callback
 * Path: /intri-system/status/Status_Uptime
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_system_intri_system_config_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_system_intri_system_config_get");
  }

  /* calls the private api */
  struct emptypb_Empty in;
  struct systempb_Config out;
  system_System_GetConfig(&in, &out);

  val_value_t *child_val;

  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_system_N_Config_SysContact,
      out.SysContact,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }

  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_system_N_Config_SysGroup,
      out.SysGroup,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }

  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_system_N_Config_SysLocation,
      out.SysLocation,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }

  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_system_N_Config_SysName,
      out.SysName,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }

  return res;
} /* intri_system_intri_system_config_get */

/********************************************************************
 * FUNCTION intri_system_intri_system_config_mro
 *
 * Make read-only child nodes
 * Path: /intri-system/status
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_system_intri_system_config_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* init /intri-system/intri-system/config */
  val_init_virtual(
      parentval,
      intri_system_intri_system_config_get,
      parentval->obj);

  return res;

} /* intri_system_intri_system_config_mro */

/********************************************************************
 * FUNCTION intri_system_intri_system_mro
 *
 * Make read-only child nodes
 * Path: /intri-system
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_system_intri_system_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-system/intri-system/status */
  res = agt_add_container(
      y_intri_system_M_intri_system,
      y_intri_system_N_status,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_system_intri_system_status_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-system/intri-system/config */
  res = agt_add_container(
      y_intri_system_M_intri_system,
      y_intri_system_N_config,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_system_intri_system_config_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;
} /* intri_system_intri_system_mro */

/********************************************************************
 * FUNCTION intri_system_intri_system_config_Config_SysName_edit
 *
 * Edit database object callback
 * Path: /intri-system/config/Config_SysName
 * Add object instrumentation in COMMIT phase.
 *
 * INPUTS:
 *     see agt/agt_cb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_system_intri_system_config_Config_SysName_edit(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval) {
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\n >>>>> ian: func = intri_system_intri_system_config_Config_SysGroup_edit");
    log_debug("\n cb = %s , op = %s", agt_cbtype_name(cbtyp), op_editop_name(editop));
    log_debug("\n newval = %d, curval = %d", newval == NULL, curval == NULL);
    val_dump_value(newval, 0);
    val_dump_value(curval, 0);
  }

  struct emptypb_Empty epty;
  struct systempb_Config cfg;

  switch (cbtyp) {
    case AGT_CB_VALIDATE:
      /* description-stmt validation here */
      break;
    case AGT_CB_APPLY:
      /* database manipulation done here */
      break;
    case AGT_CB_COMMIT:
      /* device instrumentation done here */
      switch (editop) {
        case OP_EDITOP_LOAD:
          break;
        case OP_EDITOP_MERGE:
          break;
        case OP_EDITOP_REPLACE:
          system_System_GetConfig(&epty, &cfg);
          cfg.SysName = VAL_STRING(newval);
          system_System_SetConfig(&cfg, &epty);
          break;
        case OP_EDITOP_CREATE:
          break;
        case OP_EDITOP_DELETE:
          break;
        default:
          res = SET_ERROR(ERR_INTERNAL_VAL);
      }
      break;
    case AGT_CB_ROLLBACK:
      /* undo device instrumentation here */
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_CONTENT,
        res,
        NULL,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* intri_system_intri_system_config_Config_SysName_edit */

/********************************************************************
 * FUNCTION intri_system_intri_system_config_Config_SysLocation_edit
 *
 * Edit database object callback
 * Path: /intri-system/config/Config_SysLocation
 * Add object instrumentation in COMMIT phase.
 *
 * INPUTS:
 *     see agt/agt_cb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_system_intri_system_config_Config_SysLocation_edit(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval) {
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\n >>>>> ian: func = intri_system_intri_system_config_Config_SysGroup_edit");
    log_debug("\n cb = %s , op = %s", agt_cbtype_name(cbtyp), op_editop_name(editop));
    log_debug("\n newval = %d, curval = %d", newval == NULL, curval == NULL);
    val_dump_value(newval, 0);
    val_dump_value(curval, 0);
  }

  struct emptypb_Empty epty;
  struct systempb_Config cfg;

  switch (cbtyp) {
    case AGT_CB_VALIDATE:
      /* description-stmt validation here */
      break;
    case AGT_CB_APPLY:
      /* database manipulation done here */
      break;
    case AGT_CB_COMMIT:
      /* device instrumentation done here */
      switch (editop) {
        case OP_EDITOP_LOAD:
          break;
        case OP_EDITOP_MERGE:
          break;
        case OP_EDITOP_REPLACE:
          system_System_GetConfig(&epty, &cfg);
          cfg.SysLocation = VAL_STRING(newval);
          system_System_SetConfig(&cfg, &epty);
          break;
        case OP_EDITOP_CREATE:
          break;
        case OP_EDITOP_DELETE:
          break;
        default:
          res = SET_ERROR(ERR_INTERNAL_VAL);
      }
      break;
    case AGT_CB_ROLLBACK:
      /* undo device instrumentation here */
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_CONTENT,
        res,
        NULL,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* intri_system_intri_system_config_Config_SysLocation_edit */

/********************************************************************
 * FUNCTION intri_system_intri_system_config_Config_SysGroup_edit
 *
 * Edit database object callback
 * Path: /intri-system/config/Config_SysGroup
 * Add object instrumentation in COMMIT phase.
 *
 * INPUTS:
 *     see agt/agt_cb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_system_intri_system_config_Config_SysGroup_edit(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval) {
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\n >>>>> ian: func = intri_system_intri_system_config_Config_SysGroup_edit");
    log_debug("\n cb = %s , op = %s", agt_cbtype_name(cbtyp), op_editop_name(editop));
    log_debug("\n newval = %d, curval = %d", newval == NULL, curval == NULL);
    val_dump_value(newval, 0);
    val_dump_value(curval, 0);
  }

  struct emptypb_Empty epty;
  struct systempb_Config cfg;

  switch (cbtyp) {
    case AGT_CB_VALIDATE:
      /* description-stmt validation here */
      break;
    case AGT_CB_APPLY:
      /* database manipulation done here */
      break;
    case AGT_CB_COMMIT:
      /* device instrumentation done here */
      switch (editop) {
        case OP_EDITOP_LOAD:
          break;
        case OP_EDITOP_MERGE:
          break;
        case OP_EDITOP_REPLACE:
          system_System_GetConfig(&epty, &cfg);
          cfg.SysGroup = VAL_STRING(newval);
          system_System_SetConfig(&cfg, &epty);
          break;
        case OP_EDITOP_CREATE:
          break;
        case OP_EDITOP_DELETE:
          break;
        default:
          res = SET_ERROR(ERR_INTERNAL_VAL);
      }
      break;
    case AGT_CB_ROLLBACK:
      /* undo device instrumentation here */
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_CONTENT,
        res,
        NULL,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* intri_system_intri_system_config_Config_SysGroup_edit */

/********************************************************************
 * FUNCTION intri_system_intri_system_config_Config_SysContact_edit
 *
 * Edit database object callback
 * Path: /intri-system/config/Config_SysContact
 * Add object instrumentation in COMMIT phase.
 *
 * INPUTS:
 *     see agt/agt_cb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_system_intri_system_config_Config_SysContact_edit(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval) {
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\n >>>>> ian: func = intri_system_intri_system_config_Config_SysContact_edit");
    log_debug("\n cb = %s , op = %s", agt_cbtype_name(cbtyp), op_editop_name(editop));
    log_debug("\n newval = %d, curval = %d", newval == NULL, curval == NULL);
    val_dump_value(newval, 0);
    val_dump_value(curval, 0);
  }

  struct emptypb_Empty epty;
  struct systempb_Config cfg;

  switch (cbtyp) {
    case AGT_CB_VALIDATE:
      /* description-stmt validation here */
      break;
    case AGT_CB_APPLY:
      /* database manipulation done here */
      break;
    case AGT_CB_COMMIT:
      /* device instrumentation done here */
      switch (editop) {
        case OP_EDITOP_LOAD:
          break;
        case OP_EDITOP_MERGE:
          break;
        case OP_EDITOP_REPLACE:
          system_System_GetConfig(&epty, &cfg);
          cfg.SysContact = VAL_STRING(newval);
          system_System_SetConfig(&cfg, &epty);
          break;
        case OP_EDITOP_CREATE:
          break;
        case OP_EDITOP_DELETE:
          break;
        default:
          res = SET_ERROR(ERR_INTERNAL_VAL);
      }
      break;
    case AGT_CB_ROLLBACK:
      /* undo device instrumentation here */
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_CONTENT,
        res,
        NULL,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* intri_system_intri_system_config_Config_SysContact_edit */

/********************************************************************
 * FUNCTION intri_system_intri_system_config_edit
 *
 * Edit database object callback
 * Path: /intri-system/config
 * Add object instrumentation in COMMIT phase.
 *
 * INPUTS:
 *     see agt/agt_cb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_system_intri_system_config_edit(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval) {
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_system_intri_system_config_edit callback for %s phase",
              agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
    case AGT_CB_VALIDATE:
      /* description-stmt validation here */
      break;
    case AGT_CB_APPLY:
      /* database manipulation done here */
      break;
    case AGT_CB_COMMIT:
      /* device instrumentation done here */
      switch (editop) {
        case OP_EDITOP_LOAD:
          break;
        case OP_EDITOP_MERGE:
          break;
        case OP_EDITOP_REPLACE:
          break;
        case OP_EDITOP_CREATE:
          break;
        case OP_EDITOP_DELETE:
          break;
        default:
          res = SET_ERROR(ERR_INTERNAL_VAL);
      }

      break;
    case AGT_CB_ROLLBACK:
      /* undo device instrumentation here */
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_CONTENT,
        res,
        NULL,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* intri_system_intri_system_config_edit */

/********************************************************************
 * FUNCTION intri_system_intri_system_edit
 *
 * Edit database object callback
 * Path: /intri-system
 * Add object instrumentation in COMMIT phase.
 *
 * INPUTS:
 *     see agt/agt_cb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_system_intri_system_edit(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval) {
  status_t res = NO_ERR;
  val_value_t *errorval = (curval) ? curval : newval;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_system_intri_system_edit callback for %s phase",
              agt_cbtype_name(cbtyp));
  }

  switch (cbtyp) {
    case AGT_CB_VALIDATE:
      /* description-stmt validation here */
      break;
    case AGT_CB_APPLY:
      /* database manipulation done here */
      break;
    case AGT_CB_COMMIT:
      /* device instrumentation done here */
      switch (editop) {
        case OP_EDITOP_LOAD:
          break;
        case OP_EDITOP_MERGE:
          break;
        case OP_EDITOP_REPLACE:
          break;
        case OP_EDITOP_CREATE:
          break;
        case OP_EDITOP_DELETE:
          break;
        default:
          res = SET_ERROR(ERR_INTERNAL_VAL);
      }

      if (res == NO_ERR) {
        res = agt_check_cache(&intri_system_val, newval, curval, editop);
      }
      if (res == NO_ERR && curval == NULL) {
        res = intri_system_intri_system_mro(newval);
      }
      break;
    case AGT_CB_ROLLBACK:
      /* undo device instrumentation here */
      break;
    default:
      res = SET_ERROR(ERR_INTERNAL_VAL);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_CONTENT,
        res,
        NULL,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* intri_system_intri_system_edit */

/********************************************************************
 * FUNCTION y_intri_system_init
 *
 * initialize the intri-system server instrumentation library
 *
 * INPUTS:
 *    modname == requested module name
 *    revision == requested version (NULL for any)
 *
 * RETURNS:
 *     error status
 ********************************************************************/
status_t y_intri_system_init(
    const xmlChar *modname,
    const xmlChar *revision) {
  status_t res = NO_ERR;
  agt_profile_t *agt_profile = agt_get_profile();

  y_intri_system_init_static_vars();

  /* change if custom handling done */
  if (xml_strcmp(modname, y_intri_system_M_intri_system)) {
    return ERR_NCX_UNKNOWN_MODULE;
  }

  if (revision && xml_strcmp(revision, y_intri_system_R_intri_system)) {
    return ERR_NCX_WRONG_VERSION;
  }
  res = ncxmod_load_module(
      y_intri_system_M_intri_system,
      y_intri_system_R_intri_system,
      &agt_profile->agt_savedevQ,
      &intri_system_mod);
  if (res != NO_ERR) {
    return res;
  }

  intri_system_obj = ncx_find_object(
      intri_system_mod,
      y_intri_system_N_intri_system);
  if (intri_system_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  res = agt_cb_register_callback(
      y_intri_system_M_intri_system,
      (const xmlChar *)"/intri-system",
      y_intri_system_R_intri_system,
      intri_system_intri_system_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
      y_intri_system_M_intri_system,
      (const xmlChar *)"/intri-system/config",
      y_intri_system_R_intri_system,
      intri_system_intri_system_config_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
      y_intri_system_M_intri_system,
      (const xmlChar *)"/intri-system/config/Config_SysName",
      y_intri_system_R_intri_system,
      intri_system_intri_system_config_Config_SysName_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
      y_intri_system_M_intri_system,
      (const xmlChar *)"/intri-system/config/Config_SysLocation",
      y_intri_system_R_intri_system,
      intri_system_intri_system_config_Config_SysLocation_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
      y_intri_system_M_intri_system,
      (const xmlChar *)"/intri-system/config/Config_SysGroup",
      y_intri_system_R_intri_system,
      intri_system_intri_system_config_Config_SysGroup_edit);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_cb_register_callback(
      y_intri_system_M_intri_system,
      (const xmlChar *)"/intri-system/config/Config_SysContact",
      y_intri_system_R_intri_system,
      intri_system_intri_system_config_Config_SysContact_edit);
  if (res != NO_ERR) {
    return res;
  }

  /* put your module initialization code here */

  return res;
} /* y_intri_system_init */

/********************************************************************
 * FUNCTION y_intri_system_init2
 *
 * SIL init phase 2: non-config data structures
 * Called after running config is loaded
 *
 * RETURNS:
 *     error status
 ********************************************************************/
status_t y_intri_system_init2(void) {
  status_t res = NO_ERR;

  intri_system_val = agt_init_cache(
      y_intri_system_M_intri_system,
      y_intri_system_N_intri_system,
      &res);
  if (res != NO_ERR) {
    return res;
  }
  if (intri_system_val == NULL) {
    res = agt_add_top_container(intri_system_obj, &intri_system_val);
    if (res != NO_ERR) {
      return res;
    }
  }

  /* put your init2 code here */
  res = intri_system_intri_system_mro(intri_system_val);
  if (res != NO_ERR) {
    return res;
  }

  return res;
} /* y_intri_system_init2 */

/********************************************************************
 * FUNCTION y_intri_system_cleanup
 *    cleanup the server instrumentation library
 *
 ********************************************************************/
void y_intri_system_cleanup(void) {
  agt_cb_unregister_callbacks(
      y_intri_system_M_intri_system,
      (const xmlChar *)"/intri-system");

  agt_cb_unregister_callbacks(
      y_intri_system_M_intri_system,
      (const xmlChar *)"/intri-system/config");

  agt_cb_unregister_callbacks(
      y_intri_system_M_intri_system,
      (const xmlChar *)"/intri-system/config/Config_SysName");

  agt_cb_unregister_callbacks(
      y_intri_system_M_intri_system,
      (const xmlChar *)"/intri-system/config/Config_SysLocation");

  agt_cb_unregister_callbacks(
      y_intri_system_M_intri_system,
      (const xmlChar *)"/intri-system/config/Config_SysGroup");

  agt_cb_unregister_callbacks(
      y_intri_system_M_intri_system,
      (const xmlChar *)"/intri-system/config/Config_SysContact");

  /* put your cleanup code here */

} /* y_intri_system_cleanup */

/* END intri_system.c */
