


<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc ipr="full3978" category="info" strict="yes" docName="draft-ietf-netconf-prot-09">
  <front>
    <title abbrev="NETCONF Protocol">NETCONF Configuration Protocol</title>
    <author initials="R." surname="Enns" fullname="Rob Enns" role="editor">
      <organization>Juniper Networks</organization>
      <address>
        <postal>
          <street>1194 North Mathilda Ave</street>
          <city>Sunnyvale</city>
          <region>CA</region>
          <code>94089</code>
          <country>US</country>
        </postal>
        <email>rpe@juniper.net</email>
      </address>
    </author>
    <date month="October" year="2005" />
    <area>Operations</area>
    <keyword>XML</keyword>
    <keyword>Configuration</keyword>
    <keyword>Network Management</keyword>
    <keyword>Extensible Markup Language</keyword>
    <abstract>
      <t>
The NETCONF configuration protocol defined in this document 
provides mechanisms to install, manipulate, and delete the 
configuration of network devices. It uses an Extensible
Markup Language (XML) based data 
encoding for the configuration data as well as the protocol
messages. The NETCONF protocol operations are realized on top 
of a simple Remote Procedure Call (RPC) layer.
      </t>
        <t>
          Please send comments to netconf@ops.ietf.org.
          To subscribe, use netconf-request@ops.ietf.org.
        </t>
    </abstract>
  </front>
  <middle>
    <section title="Introduction">
        <t>The NETCONF protocol defines a simple mechanism through
which a network device can be managed, configuration data
information can be retrieved, and new configuration data can be
uploaded and manipulated. The protocol allows the device to expose a
full, formal, application programming interface (API). Applications
can use this straight-forward API to send and receive full and partial
configuration data sets.
        </t>
        <t>
The NETCONF protocol uses a remote procedure call (RPC) paradigm.
A client encodes an RPC in XML
<xref target="W3C.REC-xml-20001006" /> and
sends it to a server using a secure, connection-oriented
session. The server responds with a reply encoded in XML. The contents
of both the request and the response are fully described in XML DTDs
or XML schemas, or both, allowing both parties to recognize the
syntax constraints imposed on the exchange.
        </t>
        <t>
A key aspect of NETCONF is that it allows the functionality of the
management protocol to closely mirror the native functionality of
the device.  This reduces implementation costs
and allows timely access to new features.  In addition, applications
can access both the syntactic and semantic content of
the device's native user interface.
        </t>
        <t>
NETCONF allows a client to discover the set of protocol
extensions supported by a server. These "capabilities" permit the
client to adjust its behavior to take advantage of the features
exposed by the device. The capability definitions can be easily
extended in a noncentralized manner. Standard and non-standard
capabilities can be defined with semantic and syntactic rigor.
Capabilities are discussed in <xref target="capabilities" />.
        </t>
      <t>
The NETCONF protocol is a building block in a system of automated
configuration. XML is the lingua franca of interchange, providing a
flexible but fully specified encoding mechanism for hierarchical
content. NETCONF can be used in concert with XML-based transformation
technologies such as XSLT <xref target="W3C.REC-xslt-19991116" />
to provide a system for automated generation of
full and partial configurations.
The system can query one or more databases for data about networking
topologies, links, policies, customers, and services.  This data can
be transformed using one or more XSLT
scripts from a task-oriented,
vendor-independent data schema into a form that
is specific to the vendor, product, operating system, and software
release. The resulting data can be passed to the device using the
NETCONF protocol.
      </t>
      <t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
"OPTIONAL" in this document are to be interpreted as described in
<xref target="RFC2119">RFC 2119</xref>.
      </t>
      <section title="Protocol Overview">
        <t>
NETCONF uses a simple RPC-based mechanism to facilitate communication
between a client and a server.  The client can be a script or
application typically running as part of a network manager.  The
server is typically
a network device. The terms "device" and "server" are used
interchangeably in this document, as are "client" and "application".
        </t>
        <t>
A NETCONF session is the logical connection between a network administrator or
network configuration application and a network device.
A device MUST support at least one NETCONF session, and
SHOULD support multiple sessions.
Global configuration attributes can be changed 
during any authorized session, and the effects are visible in all sessions.
Session-specific attributes affect only the session in which
they are changed.
        </t>
        <t>
NETCONF can be conceptually partitioned into four layers:
          <figure>
            <artwork><![CDATA[
           Layer                      Example
      +-------------+      +-----------------------------+
  (4) |   Content   |      |     Configuration data      |
      +-------------+      +-----------------------------+
             |                           |
      +-------------+      +-----------------------------+
  (3) | Operations  |      | <get-config>, <edit-config> |
      +-------------+      +-----------------------------+
             |                           |
      +-------------+      +-----------------------------+
  (2) |     RPC     |      |    <rpc>, <rpc-reply>       |
      +-------------+      +-----------------------------+
             |                           |
      +-------------+      +-----------------------------+
  (1) | Application |      |   BEEP, SSH, SSL, console   |
      |   Protocol  |      |                             |
      +-------------+      +-----------------------------+
              ]]></artwork>
          </figure>
        </t>
        <t>
        <list style="numbers">
        <t>
            The application protocol layer provides a communication path between
            the client and server.
            NETCONF can be layered over any application protocol that provides a set
            of basic requirements.  <xref target="transportRequirements"/>
            discusses these requirements.
        </t>
        <t>       
The RPC layer provides a simple, transport-independent framing
mechanism for encoding RPCs. <xref target="rpcModel" /> documents this protocol.
        </t>
        <t>
The operations layer defines a set of base operations invoked as RPC
methods with XML-encoded parameters. <xref target="protocolOperations" />
details the list of base operations.
        </t>
        <t>
The content layer is outside the scope of this document. Given the
current proprietary nature of the configuration data being manipulated,
the specification of this content depends on the NETCONF implementation.
It is expected that a separate effort to specify a standard data 
definition language and standard content will be undertaken.
        </t>
        </list>
        </t>
      </section>
      <section title="Capabilities">
          <t>
            A NETCONF capability is a set of functionality that supplements
            the base NETCONF specification. The capability is
            identified by a uniform resource identifier (URI).
            These URIs should follow the guidelines as
            described in <xref target="capabilities" />. 
          </t>
          <t>
Capabilities augment the base operations of the device, describing
both additional operations and the content allowed inside operations.
The client can discover the server's capabilities and use any
additional operations, parameters, and content defined by those
capabilities.
          </t>
          <t>
The capability definition may name one or more dependent capabilities.
To support a capability, the server
MUST support any capabilities upon which it depends.
          </t>
          <t>
<xref target="capabilities" /> defines the capabilities exchange that allows
the client to discover the server's capabilities.
<xref target="capabilities" /> also lists
the set of capabilities defined in this document.
          </t>
          <t>
Additional capabilities can be defined at any time in external
documents, allowing the set of capabilities to expand over
time. Standards bodies may define standardized capabilities and
implementations
may define proprietary ones. A capability URI MUST sufficiently
distinguish the naming authority to avoid naming collisions.
          </t>
      </section>

      <section title="Separation of Configuration and State Data" anchor="state">
        <t>
          The information that can be retrieved from a running system is
          separated into two classes, configuration data and state
          data. Configuration data is the set of writable data that is required
          to transform a system from its initial default state into its current
          state. State data is the additional data on a system that is not
          configuration data such as read-only status information and collected
          statistics. When a device is performing configuration operations a
          number of problems would arise if state data were
          included:
          <list style="symbols">
            <t>Comparisons of configuration data sets would be dominated by irrelevant
              entries such as different statistics.</t>
            <t>Incoming data could contain nonsensical
            requests, such as attempts to write read-only data.</t>
            <t>The data sets would be large.</t>
            <t>Archived data could contain values for read-only data
              items, complicating the processing required to restore
              archived data.
            </t>
          </list>
        </t>
        <t>
          To account for these issues, the NETCONF protocol recognizes the difference
          between configuration data and state data and provides
          operations for
          each. The &lt;get-config&gt; operation
          retrieves configuration data only while the &lt;get&gt; operation
          retrieves configuration and state data.
        </t>
        <t>
          Note that the NETCONF protocol is focused on the information
          required to get the device into its desired running state.
          The inclusion of other important, persistent data is
          implementation specific.  For example, user files and
          databases are not treated as configuration data by the NETCONF
          protocol. 
        </t>
        <t>
          If a local database of user authentication data is stored on
          the device, whether it is included in configuration data is an
          implementation dependent matter.
        </t>
      </section>
    </section>


    <section title="Application Protocol Requirements" anchor="transportRequirements">
      <t>NETCONF uses an RPC-based communication paradigm. A client
        sends a series of one or more RPC request operations, which
        cause the server to respond with a corresponding series of
        RPC replies.
      </t>
      <t> The NETCONF protocol can be layered on any application protocol that
        provides the required set of functionality. It is not bound to
        any particular application protocol, but allows a mapping to define how it
        can be implemented over any specific protocol.
      </t>
      <t>
        The application protocol MUST provide a mechanism to indicate the
        session type (client or server) to the NETCONF protocol layer.
      </t>
      <t>
        This section details the characteristics that NETCONF requires
        from the underlying application protocol.
      </t>

      <section title="Connection-oriented operation">
        <t>NETCONF is connection-oriented, requiring a persistent
          connection between peers. This connection must provide
          reliable, sequenced data delivery.
        </t>
        <t>NETCONF connections are long-lived, persisting between
          protocol operations. This allows the client to make changes to the state of
          the connection that will persist for the lifetime of the
          connection.  For example, authentication information
          specified for a connection remains in effect until the
          connection is closed.
        </t>
        <t> In addition, resources requested from the server for a
          particular connection MUST be automatically released when the
          connection closes, making failure recovery simpler and more
          robust. For example, when a lock is acquired by a client, the
          lock persists until either explicitly released or the server
          determines that the connection has been terminated. If a
          connection is terminated while the client holds a lock, the
          server can perform any appropriate recovery.
          The lock operation is further discussed in <xref target="lock" />.
        </t>
      </section>

      <section title="Authentication, Integrity, and Privacy">
        <t>
NETCONF connections must provide authentication, data integrity, and privacy. NETCONF depends
on the application protocol for this capability. A NETCONF peer
assumes that an appropriate level of security and privacy are provided
independent of this document. For example, connections may be
encrypted in TLS <xref target="RFC2246" />
or SSH <xref target="I-D.ietf-secsh-architecture" />,
depending on the underlying protocol.
        </t>
      </section>

      <section title="Authentication">
        <t>
NETCONF connections must be authenticated. The application protocol is
responsible for authentication. The peer assumes that the
connection's authentication information has been validated by the
underlying protocol using sufficiently trustworthy mechanisms and that
the peer's identity has been sufficiently proven.
        </t>
        <t>
One goal of NETCONF is to provide a programmatic
interface to the device that closely follows the functionality of the
device's native interface. Therefore, it is expected that the underlying
protocol uses existing authentication mechanisms defined by the
device. For example, a device that supports RADIUS
<xref target="RFC2865" /> should allow the use of
RADIUS to authenticate NETCONF sessions.
        </t>
        <t>
The authentication process should result in an identity whose
permissions are known to the device. These
permissions MUST be enforced during
the remainder of the NETCONF session.
        </t>
      </section>

      <section title="Mandatory Application Protocol">
        <t>
A NETCONF implementation MUST support <xref
target="I-D.ietf-netconf-ssh">the SSH application protocol
mapping</xref>.
        </t>
      </section>

    </section> <!-- Application Protocol Requirements -->

    <section title="XML Considerations" anchor="xmlConsiderations">
       <t>
         XML serves as the encoding format for NETCONF, allowing complex
         hierarchical data to be expressed in a text format that can be
         read, saved, and manipulated with both traditional text tools and
         tools specific to XML.
       </t>
       <t>
         This section discusses a small number of XML-related considerations
         pertaining to NETCONF.
       </t>
      <section title="Namespace" anchor="namespace">
        <t>
          All NETCONF protocol elements are defined in the following namespace:
          <list style="empty">
            <t>urn:ietf:params:xml:ns:netconf:base:1.0</t>
          </list>
        </t>
        <t>
					 NETCONF capability names MUST be URIs <xref target="RFC1630" />,
					 and SHOULD be URNs <xref target="RFC2141" />. NETCONF capabilities
					 are discussed in <xref target="capabilities" />.
        </t>
      </section>
      <section title="No Document Type Declarations" anchor="nodtd">
        <t>
          Document type declarations MUST NOT appear in
          NETCONF content.
        </t>
      </section>
    </section> <!-- XML Considerations -->

    <section title="RPC Model" anchor="rpcModel">
      <t>
        The NETCONF protocol uses an RPC-based communication
        model. NETCONF peers use &lt;rpc&gt; and &lt;rpc-reply&gt;
        elements to provide application protocol-independent framing of
        NETCONF requests and responses.
      </t>
      <section title="&lt;rpc&gt; Element">
        <t>
          The &lt;rpc&gt; element is used to enclose a NETCONF request sent from
          the client to the server.
        </t>
        <t>
The &lt;rpc&gt; element has a mandatory attribute
"message-id", which is an arbitrary string chosen by the sender
of the RPC that will commonly encode a monotonically increasing
integer. The receiver of the RPC does not decode or interpret this
string but simply saves it to use as a "message-id" attribute in any
resulting &lt;rpc-reply&gt; message. For example:
        </t>
        <figure>
          <artwork><![CDATA[
    <rpc message-id="101"
         xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <some-method>
        <!-- method parameters here... -->
      </some-method>
    </rpc>
            ]]></artwork>
        </figure>
        <t>
          If additional attributes are present in an &lt;rpc&gt;
          element, a NETCONF peer MUST return them unmodified in the
          &lt;rpc-reply&gt; element.
        </t>
        <t>
The name and parameters of an RPC are encoded as the contents
of the &lt;rpc&gt; element. The name of the RPC is an element
directly inside the &lt;rpc&gt; element, and any parameters are
encoded inside this element.
        </t>
        <t>
The following example invokes a method called &lt;my-own-method&gt;
which has two
parameters, &lt;my-first-parameter&gt;, with a value of "14", and
&lt;another-parameter&gt;, with a value of "fred":
        </t>
        <figure>
          <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <my-own-method xmlns="http://example.net/me/my-own/1.0">
      <my-first-parameter>14</my-first-parameter>
      <another-parameter>fred</another-parameter>
    </my-own-method>
  </rpc>
            ]]></artwork>
        </figure>
        <t>
The following example invokes a &lt;rock-the-house&gt; method with a
&lt;zip-code&gt; parameter of "27606-0100":
        </t>
        <figure>
          <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <rock-the-house xmlns="http://example.net/rock/1.0">
      <zip-code>27606-0100</zip-code>
    </rock-the-house>
  </rpc>
            ]]></artwork>
        </figure>
        <t>
The following example invokes the NETCONF &lt;get&gt;
method with no parameters:
        </t>
        <figure>
          <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get/>
  </rpc>
            ]]></artwork>
        </figure>
      </section>
      <section title="&lt;rpc-reply&gt; Element">
        <t>
The &lt;rpc-reply&gt; message is sent in response to a &lt;rpc&gt; operation.
        </t>
        <t>
The &lt;rpc-reply&gt; element has a mandatory attribute "message-id",
which is equal to the "message-id" attribute of the &lt;rpc&gt; for
which this is a response.
        </t>
        <t>
A NETCONF peer MUST also return any additional attributes
included in the &lt;rpc&gt; element unmodified in the
&lt;rpc-reply&gt; element.
        </t>
        <t>
The response name and response data are encoded as the contents
of the &lt;rpc-reply&gt; element. The name of the reply is an element
directly inside the &lt;rpc-reply&gt; element, and any data is encoded
inside this element.
        </t>
        <t>For example:</t>
        <t>The following &lt;rpc&gt; element invokes the NETCONF &lt;get&gt;
        method and includes an additional attribute called "user-id".
        Note that the "user-id" attribute is not in the NETCONF namespace.
        The returned &lt;rpc-reply&gt; element returns the "user-id"
        attribute, as well as the requested content.</t>
        <figure>
          <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:ex="http://example.net/content/1.0"
       ex:user-id="fred">
    <get/>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:ex="http://example.net/content/1.0"
       ex:user-id="fred">
    <data>
      <!-- contents here... -->
    </data>
  </rpc-reply>
            ]]></artwork>
        </figure>
      </section>
      <section title="&lt;rpc-error&gt; Element" anchor="rpcError">
        <t>
          The &lt;rpc-error&gt; element is sent in &lt;rpc-reply&gt; messages
          if an error occurs during the processing of an &lt;rpc&gt;
          request.
        </t>
        <t>
          If a server encounters multiple errors during the processing of an
          &lt;rpc&gt; request, the &lt;rpc-reply&gt; MAY contain multiple
          &lt;rpc-error&gt; elements.  However, a server is not required to
          detect or report more than one &lt;rpc-error&gt; element, if a
          request contains multiple errors.  A server is not required to
          check for particular error conditions in a specific sequence.  A
          server MUST return an &lt;rpc-error&gt; element if any error
          conditions occur during processing, and SHOULD return an
          &lt;rpc-error&gt; element if any warning conditions occur during
          processing.
        </t>
	<t>
          A server MUST NOT return application level or data model-specific
          error information in an &lt;rpc-error&gt; element for which the
          client does not have sufficient access rights.
	</t>
        <t>
          The &lt;rpc-error&gt; element includes the following
          information:
        </t>
        <t>
         <list style="hanging">
            <t hangText="error-type:">
              Defines the conceptual layer that the error occurred.
              Enumeration. One of:
              <list style="symbols">
                <t>transport</t>
                <t>rpc</t>
                <t>protocol</t>
                <t>application</t>
              </list>
           </t>
            <t hangText="error-tag:">
              Contains a string identifying the error condition.
              See <xref target="errorList" /> for allowed values.
            </t>
            <t hangText="error-severity:">
              Contains a string identifying the error severity, 
              as determined by the device. 
              One of:
              <list style="symbols">
                <t>error</t>
                <t>warning</t>
              </list>
            </t>
            <t hangText="error-app-tag:">
              Contains a string identifying the data model-specific
              or implementation-specific error condition, if 
              one exists.  This element will not be present if no 
              appropriate application error tag can be associated 
              with a particular error condition.
            </t>
            <t hangText="error-path:">
              Contains the absolute
              XPath <xref target="W3C.REC-xpath-19991116" />
              expression identifying the element
              path to the node which is associated with the error being
              reported in a particular rpc-error element.
              This element will not be present if no appropriate payload
              element can be associated with a particular error condition,
              or if the 'bad-element' QString returned in the 'error-info'
              container is sufficient to identify the node associated with
              the error.
            </t>
            <t hangText="error-message:">
              Contains a string suitable for human display which
              describes the error condition.  This
              element will not be present if no appropriate message
              is provided for a particular error condition.
              This element SHOULD include an xml:lang attribute as
              defined in <xref target="W3C.REC-xml-20001006" /> and
              discussed in <xref target="RFC3470" />.
            </t>
            <t hangText="error-info:">
              Contains protocol-or data model-specific 
              error content.  This element will not be present if no 
              such error content is provided for a particular error condition.
              The list in <xref target="errorList" /> 
              defines any mandatory error-info content
              for each error.  After any protocol-mandated content,
              a data model definition may mandate certain application layer
              error information be included in the error-info container.
              An implementation may include additional elements
              to provide extended and/or 
              implementation-specific debugging information.
            </t>
         </list>
        </t>
        <t>
          <xref target="errorList" /> enumerates the standard NETCONF errors.
        </t>
        <list style="hanging">
        <t hangText="Example:">
          <t>
            An error is returned if an &lt;rpc&gt;
            element is received without a message-id attribute.
            Note that only in this case is it acceptable for the NETCONF peer to
            omit the message-id attribute in the &lt;rpc-reply&gt; element.
        <figure>
          <artwork><![CDATA[
  <rpc xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get-config>
      <source>
        <running/>
      </source>
    </get-config>
  </rpc>

  <rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <rpc-error>
      <error-type>rpc</error-type>
      <error-tag>missing-attribute</error-tag>
      <error-severity>error</error-severity>
      <error-info>
        <bad-attribute>message-id</bad-attribute>
        <bad-element>rpc</bad-element>
      </error-info>
    </rpc-error>
  </rpc-reply>
            ]]></artwork>
        </figure>
          </t>
          <t>
            The following &lt;rpc-reply&gt; illustrates the case
            of returning multiple &lt;rpc-error&gt; elements.
        <figure>
          <artwork><![CDATA[
  <rpc-reply message-id="101"
    xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
    xmlns:xc="urn:ietf:params:xml:ns:netconf:base:1.0">
    <rpc-error>
      <error-type>application</error-type>
      <error-tag>invalid-value</error-tag>
      <error-severity>error</error-severity>
      <error-message xml:lang="en">
        MTU value 25000 is not within range 256..9192
      </error-message>
      <error-info>
        <top xmlns="http://example.com/schema/1.2/config">
          <interface>
            <name>Ethernet0/0</name>
            <mtu>25000</mtu>
          </interface>
        </top>
      </error-info>
    </rpc-error>
    <rpc-error>
      <error-type>application</error-type>
      <error-tag>invalid-value</error-tag>
      <error-severity>error</error-severity>
      <error-message xml:lang="en">
        Invalid IP address for interface Ethernet1/0
      </error-message>
      <error-info>
        <top xmlns="http://example.com/schema/1.2/config">
          <interface xc:operation="replace">
            <name>Ethernet1/0</name>
            <address>
              <name>1.4</name>
              <prefix-length>24</prefix-length>
            </address>
          </interface>
        </top>
      </error-info>
    </rpc-error>
  </rpc-reply>
            ]]></artwork>
        </figure>
          </t>
          </t>
        </list>
      </section>
      <section title="&lt;ok&gt; Element">
        <t>
          The &lt;ok&gt; element is sent in &lt;rpc-reply&gt; messages
          if no error occurred during the processing of an &lt;rpc&gt;
          request. For example:
        <figure>
          <artwork><![CDATA[
  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
            ]]></artwork>
        </figure>
        </t>
      </section>
      <section title="Pipelining">
        <t>
NETCONF &lt;rpc&gt; requests MUST be processed serially by the managed device.
Additional &lt;rpc&gt; requests MAY be sent before previous ones
have been completed. The managed device MUST send responses only in
the order the requests were received.
        </t>
      </section>
    </section> <!-- RPC Model -->

    <section title="Configuration Model">
      <t> NETCONF provides an initial set of
        operations and a number of capabilities that can be used to
        extend the base. NETCONF peers exchange device capabilities
        when the session is initiated as described in
        <xref target="capabilityExchange"/>.
      </t>
      <section title="Configuration Datastores">
        <t>NETCONF defines the existence of one or more configuration
          datastores and allows configuration operations on them.
          A configuration datastore is defined as
          the complete set of configuration data that is required to get a
          device from its initial default state into a desired operational state.
          The configuration datastore does not include state data or executive
          commands.
        </t>
        <t>
          Only the &lt;running&gt; configuration datastore is present in the
          base model. Additional configuration datastores may be
          defined by capabilities. Such configuration datastores
          are available only on devices that advertise the
          capabilities.
          <list style="symbols">
            <t>
              Running: The complete configuration
              currently active on the network device.
              Only one configuration datastore of this type exists on
              the device, and it is always present. NETCONF protocol
              operations refer to this datastore using the
              &lt;running&gt; element.
            </t>
          </list>
        </t>
        <t>
          The capabilities in
          <xref target="candidate" /> and <xref target="startup" />
          define the &lt;candidate&gt; and &lt;startup&gt;
          configuration datastores, respectively.
        </t>
      </section>
    </section> <!-- Configuration Model -->

    <section title="Subtree Filtering" anchor="subtree">
      <section title="Overview">
        <t>
          XML subtree filtering is a mechanism that allows an application to
          select particular XML subtrees to include in the &lt;rpc-reply&gt; for a
          &lt;get&gt; or &lt;get-config&gt; operation.  A small set of filters for
          inclusion, simple content exact-match, and selection is provided,
          which allows some useful, but also very limited, selection mechanisms.
          The agent does not need to utilize any data model-specific semantics
          during processing, allowing for simple and centralized implementation
          strategies.
        </t>
        <t>
          Conceptually, a subtree filter is comprised of zero or more element
          subtrees, which represent the filter selection criteria.  At each
          containment level within a subtree, the set of sibling nodes is
          logically processed by the server to determine if its subtree (and
          path to the root) are included in the filter output.
        </t>
        <t>
          All elements present in a particular subtree within a filter must 
          match associated nodes present in the server's conceptual data model.
          XML namespaces may be specified (via 'xmlns' declarations) within the
          filter data model.  If so, the declared namespace must first exactly
          match a namespace supported by the server.  Note that prefix values
          for qualified namespaces are not relevant when comparing filter 
          elements to elements in the underlying data model.  Only data 
          associated with a specified namespace will be included in the 
          filter output.  
        </t>
        <t>
          Each node specified in a subtree filter represents an inclusive
          filter.  Only associated nodes in underlying data model(s) within
          the specified configuration datastore on the server are selected 
          by the filter.  A node must exactly match the namespace and absolute 
          path name of the filter data, except the filter absolute path name is 
          adjusted to start from the layer below &lt;filter&gt;.  
        </t>
        <t>
          Response messages contain only the subtrees selected by the filter.
          Any selection criteria that were present in the request, within a
          particular selected subtree, is also included in the response.
          Note that some elements expressed in the filter as leaf nodes
          will be expanded (i.e., subtrees included) in the filter output.
          Specific data instances are not duplicated in the response in the
          event the request contains multiple filter subtree expressions which
          select the same data.
        </t>
      </section>
      <section title="Subtree Filter Components">
        <t>
          A subtree filter is comprised of XML elements and their XML
          attributes.  There are five types of components that may be 
          present in a subtree filter:
          <list style="symbols">
            <t>Namespace Selection</t>
            <t>Attribute Match Expressions</t>
            <t>Containment Nodes</t>
            <t>Selection Nodes</t>
            <t>Content Match Nodes</t>
          </list>
        </t>
        <section title="Namespace Selection">
          <t>
            If namespaces are used then the filter output will only include
            elements from the specified namespace.  A namespace is considered
            to match (for filter purposes) if the content of the 'xmlns'
            attributes are the same in the filter and the underlying data model.
            Note that namespace selection cannot be used by itself.
            At least one element must be specified in the filter
            any elements to be included in the filter output.
          </t>
          <t>
            Example:
            <figure>
              <artwork><![CDATA[
  <filter type="subtree">
    <top xmlns="http://example.com/schema/1.2/config"/>
  </filter>
              ]]></artwork>
            </figure>
          </t>
          <t>
            In this example the &lt;top&gt; element is a selection node, and only
            this node and any child nodes (from the underlying data model) in 
            the 'http://example.com/schema/1.2/config' namespace will be 
            included in the filter output.
          </t>
        </section>
        <section title="Attribute Match Expressions" anchor="attribute-match">
          <t>
            An attribute that appears in a subtree filter is part of
            an "attribute match expression".  Any number of (unqualified 
            or qualified) XML attributes may be present in any type of 
            filter node.  In addition to the selection criteria normally 
            applicable to that node, the selected data must have matching 
            values for every attribute specified in the node.  If an element 
            is not defined to include a specified attribute, then it is not 
            selected in the filter output.
          </t>
          <t>
            Example:
            <figure>
              <artwork><![CDATA[
  <filter type="subtree">
    <t:top xmlns:t="http://example.com/schema/1.2/config">
      <t:interfaces>
        <t:interface t:ifName="eth0"/>
      </t:interfaces>
    </t:top>
  </filter>
              ]]></artwork>
            </figure>
          </t>
          <t>
            In this example the &lt;top&gt;, &lt;interfaces&gt; and
            &lt;interface&gt; elements are 
            containment nodes, and 'ifName' is an attribute match expression.  
            Only nodes in the 'http://example.com/schema/1.2/config' namespace, 
            that match the absolute path '/top/interfaces/interface', and
            for which the
            &lt;interface&gt; element has an 'ifName' attribute defined with the 
            value 'eth0', will be included in the filter output, 
          </t>
        </section>
        <section title="Containment Nodes" anchor="containment-nodes">
          <t>
            Nodes which contain child elements within a subtree filter
            are called "containment nodes".  Each child element can be
            any type of node, including another containment node.  For
            each containment node specified in a subtree filter, all
            data model instances which exactly match the specified 
            namespaces, absolute path, and any attribute match expressions 
            within this node, are included in the filter output.
          </t>
          <t>
            Example:
            <figure>
              <artwork><![CDATA[
  <filter type="subtree">
    <top xmlns="http://example.com/schema/1.2/config">
      <users/>
    </top>
  </filter>
              ]]></artwork>
            </figure>
          </t>
          <t>
            In this example the &lt;top&gt; element is a containment node.
          </t>
        </section>
        <section title="Selection Nodes">
          <t>
            An empty leaf node within a filter is called a "selection node",
            and it represents an "explicit selection" filter on the underlying
            data model.  Presence of any selection nodes within a set of sibling
            nodes will cause the filter to select the specified subtree(s),
            and suppress automatic selection of the entire set of sibling nodes
            in the underlying data model.  For filtering purposes, an empty
            leaf node can be declared with either an empty tag (e.g., &lt;foo/&gt;) 
            or with explicit start and end tags (e.g., &lt;foo&gt;  &lt;/foo&gt;).  Any
            whitespace characters are ignored in this form.
          </t>
          <t>
            Example:
            <figure>
              <artwork><![CDATA[
  <filter type="subtree">
    <top xmlns="http://example.com/schema/1.2/config">
      <users/>
    </top>
  </filter>
              ]]></artwork>
            </figure>
          </t>
          <t>
            In this example the &lt;top&gt; element is a containment node, and 
            the &lt;users&gt; element is a selection node.  Only nodes in the 
            'http://example.com/schema/1.2/config' namespace, which match the 
            absolute path '/top/users' will be included in the filter output.
          </t>
        </section>
        <section title="Content Match Nodes">
          <t>
            A leaf node which contains simple content is called a "content
            match node".  It is used to select some or all of its sibling 
            nodes for filter output, and represents an exact-match filter on 
            the leaf node element content.  The following constraints apply to 
            content match nodes:
            <list style="symbols">
              <t>A content match node must not contain nested elements (i.e., 
              must resolve to a simpleType in XSD).</t>
              <t>Multiple content match nodes (i.e., sibling nodes) are logically
              combined in an "AND" expression.</t>
              <t>Filtering of mixed content is not supported.</t>
              <t>Filtering of list content is not supported.</t>
              <t>Filtering of whitespace-only content is not supported.</t>
              <t>A content match node must contain non-whitespace characters.
              An empty element (e.g., &lt;foo&gt;&lt;/foo&gt;) will be interpreted as a
              selection node (e.g., &lt;foo/&gt;).</t>
              <t>Leading and trailing whitespace characters are ignored, but any 
              whitespace characters within a block of text characters are not 
              ignored or modified.</t>
            </list>
          </t>
          <t>
            If all specified sibling content match nodes in a subtree filter
            expression are 'true', then the filter output nodes are selected 
            in the following manner:
            <list style="symbols">
              <t>Each content match node in the sibling set is included in 
              the filter output.</t>
              <t>If any containment nodes are present in the sibling set then
              they are processed further, and included if any nested filter
              criteria are also met.</t>
              <t>If any selection nodes are present in the sibling set then all
              of them are included in the filter output.  </t>
              <t>Otherwise (i.e., there are no selection or containment nodes
              in the filter sibling set) all the nodes defined at this level
              in the underlying data model (and their subtrees, if any) are
              returned in the filter output.</t>
            </list>
          </t>
          <t>
            If any of the sibling content match node tests are 'false', then no
            further filter processing is performed on that sibling set, and none
            of the sibling subtrees are selected by the filter, including the
            content match node(s).
          </t>
          <t>
            Example:
            <figure>
              <artwork><![CDATA[
  <filter type="subtree">
    <top xmlns="http://example.com/schema/1.2/config">
      <users>
        <user>
          <name>fred</name>
        </user>
      </users>
    </top>
  </filter>
              ]]></artwork>
            </figure>
          </t>
          <t>
            In this example the &lt;users&gt; and &lt;user&gt; nodes are both containment
            nodes, and &lt;name&gt; is a content match node.  Since no sibling nodes
            of &lt;name&gt; are specified (and therefore no containment or selection 
            nodes) all of the sibling nodes of &lt;name&gt; are returned in the
            filter output.  Only nodes in the 'http://example.com/schema/1.2/config' 
            namespace, that match the absolute path '/top/users/user', and
            for which the &lt;name&gt; element is equal to 'fred', will be included in 
            the filter output.
          </t>
        </section>
      </section>
      <section title="Subtree Filter Processing">
        <t>
          The filter output (the set of selected nodes) is initially empty.
        </t>
        <t>
          Each subtree filter can contain one or more data model fragments,
          which represent portions of the data model that should be selected
          (with all child nodes) in the filter output.
        </t>
        <t>
          Each subtree data fragment is compared by the server to the internal
          data models supported by the server.  If the entire subtree
          data-fragment filter (starting from the root to the innermost element
          specified in the filter) exactly matches a corresponding portion of
          the supported data model, then that node and all its children are
          included in the result data.
        </t>
        <t>
          The server processes all nodes with the same parent node (sibling
          set) together, starting from the root to the leaf nodes.  The root
          elements in the filter are considered to be in the same sibling set
          (assuming they are in the same namespace), even though they do not
          have a common parent.
        </t>
        <t>
          For each sibling set, the server determines which nodes are included
          (or potentially included) in the filter output, and which sibling
          subtrees are excluded (pruned) from the filter output.  The server
          first determines which types of nodes are present in the sibling set,
          and processes the nodes according to the rules for their type.  If
          any nodes in the sibling set are selected, then the process is
          recursively applied to the sibling sets of each selected node.  The
          algorithm continues until all sibling sets in all subtrees specified
          in the filter have been processed.
        </t>
      </section>
      <section title="Subtree Filtering Examples">
        <section title="No filter">
          <t>
            Leaving out the filter on the get operation returns the entire data
            model.
            <figure>
              <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get/>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
      <!-- ... entire set of data returned ... -->
    </data>
  </rpc-reply>
              ]]></artwork>
            </figure>
          </t>
        </section>
        <section title="Empty filter">
          <t>
            An empty filter will select nothing because no content match or
            selection nodes are present.  This is not an error.  The filter type
            attribute used in these examples is discussed further in Section 7.1.
            <figure>
              <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get>
      <filter type="subtree">
      </filter>
    </get>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
    </data>
  </rpc-reply>
              ]]></artwork>
            </figure>
          </t>
        </section>
        <section title="Select the entire &lt;users&gt; subtree">
          <t>
            This filter in this example contains one selection node (&lt;users&gt;), so
            just that subtree is selected by the filter.  This example represents
            the fully-populated &lt;users&gt; data model in most of the filter examples
            that follow.  In a real data model, the &lt;company-info&gt; would not
            likely be returned with the list of users for a particular host or
            network.
          </t>
          <t>
            NOTE: The filtering and configuration examples used in this document
            appear in the namespace "http://example.com/schema/1.2/config".  The
            root element of this namespace is &lt;top&gt;.  The &lt;top&gt; element
            and its descendents represent an example configuration data model only.
            <figure>
              <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get-config>
      <source>
        <running/>
      </source>
      <filter type="subtree">
        <top xmlns="http://example.com/schema/1.2/config">
          <users/>
        </top>
      </filter>
    </get-config>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
      <top xmlns="http://example.com/schema/1.2/config">
        <users>
          <user>
            <name>root</name>
            <type>superuser</type>
            <full-name>Charlie Root</full-name>
            <company-info>
              <dept>1</dept>
              <id>1</id>
            </company-info>
          </user>
          <user>
            <name>fred</name>
            <type>admin</type>
            <full-name>Fred Flintstone</full-name>
            <company-info>
              <dept>2</dept>
              <id>2</id>
            </company-info>
          </user>
          <user>
            <name>barney</name>
            <type>admin</type>
            <full-name>Barney Rubble</full-name>
            <company-info>
              <dept>2</dept>
              <id>3</id>
            </company-info>
          </user>
        </users>
      </top>
    </data>
  </rpc-reply>
              ]]></artwork>
            </figure>
          </t>
          <t>
            The following filter request would have produced the same result, but
            only because the container &lt;users&gt; defines one child element
            (&lt;user&gt;).
            <figure>
              <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get-config>
      <source>
        <running/>
      </source>
      <filter type="subtree">
        <top xmlns="http://example.com/schema/1.2/config">
          <users>
            <user/>
          </users>
        </top>
      </filter>
    </get-config>
  </rpc>
              ]]></artwork>
            </figure>
          </t>
        </section>
        <section title="Select all &lt;name&gt; elements within the &lt;users&gt; subtree">
          <t>
            This filter contains two containment nodes (&lt;users&gt;, &lt;user&gt;), and one
            selector node (&lt;name&gt;).  All instances of the &lt;name&gt; element in the
            same sibling set are selected in the filter output.  The manager may
            need to know that &lt;name&gt; is used as an instance identifier in this
            particular data structure, but the server does not need to know that
            meta-data in order to process the request.
            <figure>
              <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get-config>
      <source>
        <running/>
      </source>
      <filter type="subtree">
        <top xmlns="http://example.com/schema/1.2/config">
          <users>
            <user>
              <name/>
            </user>
          </users>
        </top>
      </filter>
    </get-config>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
      <top xmlns="http://example.com/schema/1.2/config">
        <users>
          <user>
            <name>root</name>
          </user>
          <user>
            <name>fred</name>
          </user>
          <user>
            <name>barney</name>
          </user>
        </users>
      </top>
    </data>
  </rpc-reply>
              ]]></artwork>
            </figure>
          </t>
        </section>
        <section title="One specific &lt;user&gt; entry">
          <t>
            This filter contains two containment nodes (&lt;users&gt;, &lt;user&gt;) and one
            content match node (&lt;name&gt;).  All instances of the sibling set
            containing &lt;name&gt; for which the value of &lt;name&gt; equals "fred" are
            selected in the filter output.
            <figure>
              <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get-config>
      <source>
        <running/>
      </source>
      <filter type="subtree">
        <top xmlns="http://example.com/schema/1.2/config">
          <users>
            <user>
              <name>fred</name>
            </user>
          </users>
        </top>
      </filter>
    </get-config>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
      <top xmlns="http://example.com/schema/1.2/config">
        <users>
          <user>
            <name>fred</name>
            <type>admin</type>
            <full-name>Fred Flintstone</full-name>
            <company-info>
              <dept>2</dept>
              <id>2</id>
            </company-info>
          </user>
        </users>
      </top>
    </data>
  </rpc-reply>
              ]]></artwork>
            </figure>
          </t>
        </section>
        <section title="Specific elements from a specific &lt;user&gt; entry">
          <t>
            This filter contains two containment nodes (&lt;users&gt;, &lt;user&gt;), one
            content match node (&lt;name&gt;), and two selector nodes (&lt;type&gt;,
            &lt;full-name&gt;).  All instances of the &lt;type&gt; and &lt;full-name&gt; elements
            in the same sibling set containing &lt;name&gt; for which the value of
            &lt;name&gt; equals "fred" are selected in the filter output.  The
            &lt;company-info&gt; element is not included because the sibling set
            contains selection nodes.
            <figure>
              <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get-config>
      <source>
        <running/>
      </source>
      <filter type="subtree">
        <top xmlns="http://example.com/schema/1.2/config">
          <users>
            <user>
              <name>fred</name>
              <type/>
              <full-name/>
            </user>
          </users>
        </top>
      </filter>
    </get-config>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
      <top xmlns="http://example.com/schema/1.2/config">
        <users>
          <user>
            <name>fred</name>
            <type>admin</type>
            <full-name>Fred Flintstone</full-name>
          </user>
        </users>
      </top>
    </data>
  </rpc-reply>
              ]]></artwork>
            </figure>
          </t>
        </section>
        <section title="Multiple Subtrees">
          <t>
            This filter contains three subtrees (name=root, fred, barney)
          </t>
          <t>
            The "root" subtree filter contains two containment nodes (&lt;users&gt;,
            &lt;user&gt;), one content match node (&lt;name&gt;), and one selector node
            (&lt;company-info&gt;).  The subtree selection criteria is met, and just
            the company-info subtree for "root" is selected in the filter output.
          </t>
          <t>
            The "fred" subtree filter contains three containment nodes (&lt;users&gt;,
            &lt;user&gt;, &lt;company-info&gt;), one content match node (&lt;name&gt;), and one
            selector node (&lt;id&gt;).  The subtree selection criteria is met, and
            just the &lt;id&gt; element within the company-info subtree for "fred" is
            selected in the filter output.
          </t>
          <t>
            The "barney" subtree filter contains three containment nodes
            (&lt;users&gt;, &lt;user&gt;, &lt;company-info&gt;), two content match nodes (&lt;name&gt;,
            &lt;type&gt;), and one selector node (&lt;dept&gt;).  The subtree selection
            criteria is not met because user "barney" is not a "superuser", and
            the entire subtree for "barney" (including its parent &lt;user&gt; entry)
            is excluded from the filter output.
            <figure>
              <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get-config>
      <source>
        <running/>
      </source>
      <filter type="subtree">
        <top xmlns="http://example.com/schema/1.2/config">
          <users>
            <user>
              <name>root</name>
              <company-info/>
            </user>
            <user>
              <name>fred</name>
              <company-info>
                <id/>
              </company-info>
            </user>
            <user>
              <name>barney</name>
              <type>superuser</type>
              <company-info>
                <dept/>
              </company-info>
            </user>
          </users>
        </top>
      </filter>
    </get-config>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
      <top xmlns="http://example.com/schema/1.2/config">
        <users>
          <user>
            <name>root</name>
            <company-info>
              <dept>1</dept>
              <id>1</id>
            </company-info>
          </user>
          <user>
            <name>fred</name>
            <company-info>
              <id>2</id>
            </company-info>
          </user>
        </users>
      </top>
    </data>
  </rpc-reply>
              ]]></artwork>
            </figure>
          </t>
        </section>
        <section title="Elements with attribute naming">
          <t>
            In this example, the filter contains one containment node
            (&lt;interfaces&gt;), one attribute match expression (ifName), and one
            selector node (&lt;interface&gt;).  All instances of the &lt;interface&gt;
            subtree that have an ifName attribute equal to "eth0" are selected
            in the filter output.  The filter data elements and attributes must
            be qualified because the ifName attribute will not be considered part
            of the 'schema/1.2' namespace if it is unqualified.
            <figure>
              <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get>
      <filter type="subtree">
        <t:top xmlns:t="http://example.com/schema/1.2/stats">
          <t:interfaces>
            <t:interface t:ifName="eth0"/>
          </t:interfaces>
        </t:top>
      </filter>
    </get>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
      <t:top xmlns:t="http://example.com/schema/1.2/stats">
        <t:interfaces>
          <t:interface t:ifName="eth0">
            <t:ifInOctets>45621</t:ifInOctets>
            <t:ifOutOctets>774344</t:ifOutOctets>
          </t:interface>
        </t:interfaces>
      </t:top>
    </data>
  </rpc-reply>
              ]]></artwork>
            </figure>
          </t>
          <t>
            If ifName were a child node instead of an attribute, then the
            following request would produce similar results.
            <figure>
              <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get>
      <filter type="subtree">
        <top xmlns="http://example.com/schema/1.2/stats">
          <interfaces>
            <interface>
              <ifName>eth0</ifName>
            </interface>
          </interfaces>
        </top>
      </filter>
    </get>
  </rpc>
              ]]></artwork>
            </figure>
          </t>
        </section>
      </section>
    </section> <!-- Subtree Filtering -->

    <section title="Protocol Operations" anchor="protocolOperations">
      <t>
        The NETCONF protocol provides a small set of low-level 
        operations to manage device configurations and retrieve device state
        information. The base protocol provides operations to retrieve,
        configure, copy, and delete configuration datastores.  Additional
        operations are provided, based on the capabilities advertised by the
        device.
      </t>
      <t>
        The base protocol includes the following protocol operations:
        <list style="symbols">
          <t>get</t>
          <t>get-config</t>
          <t>edit-config</t>
          <t>copy-config</t>
          <t>delete-config</t>
          <t>lock</t>
          <t>unlock</t>
          <t>close-session</t>
          <t>kill-session</t>
        </list>
      </t>
      <t>
A protocol operation may fail for various reasons,
including "operation not supported".  An initiator should
not assume that any operation will always succeed.  The return
values in any RPC reply should be checked for error responses.
      </t>
      <t>
The syntax and XML encoding of the protocol operations are 
formally defined in the XML schema in <xref target="protocolSchema" />.
The following sections describe the semantics of each protocol operation.
      </t>
      <section title="&lt;get-config&gt;" anchor="get-config">
        <t>
          <list style="hanging">
            <t hangText="Description:">
              <t>
    Retrieve all or part of a specified configuration.
              </t>
            </t>
            <t hangText="Parameters:">
              <list style="hanging">
                <t hangText="source:">
                  <t>
        Name of the configuration datastore being queried,
        such as &lt;running/&gt;.  If this element is unspecified,
        the &lt;running/&gt; configuration is used.
                  </t>
                </t>
                <t hangText="filter:">
      <t>
        The filter element identifies the portions of the device
        configuration to retrieve.
        If this element is unspecified, the entire configuration
        is returned.
      </t>
      <t>
        The filter element may optionally contain a "type" attribute.
        This attribute indicates the type of filtering syntax used within
        the filter element. The default filtering mechanism in NETCONF is
        referred to as subtree filtering and is described in
        <xref target="subtree" />. The value "subtree"
        explicitly identifies this type of filtering.
      </t>
      <t>
        If the NETCONF peer supports <xref target="xpath">the :xpath capability</xref>,
        the value "xpath" may be used to indicate that the filter element
        contains an XPath expression.
      </t>
                </t>
              </list>
            </t>
            <t hangText="Positive Response:">
              <t>
    If the device can satisfy the request, the server sends an
    &lt;rpc-reply&gt; element containing a &lt;data&gt; element
    with the results of the query.
              </t>
            </t>
            <t hangText="Negative Response:">
              <t>
    An &lt;rpc-error&gt; element is included in the &lt;rpc-reply&gt;
    if the request cannot be completed for any reason.
              </t>
            </t>
            <t hangText="Example:">
              To retrieve the entire &lt;users&gt; subtree:
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get-config>
      <source>
        <running/>
      </source>
      <filter type="subtree">
        <top xmlns="http://example.com/schema/1.2/config">
          <users/>
        </top>
      </filter>
    </get-config>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
      <top xmlns="http://example.com/schema/1.2/config">
        <users>
          <user>
            <name>root</name>
            <type>superuser</type>
            <full-name>Charlie Root</full-name>
            <company-info>
              <dept>1</dept>
              <id>1</id>
            </company-info>
          </user>
          <!-- additional <user> elements appear here... -->
        </users>
      </top>
    </data>
  </rpc-reply>
                  ]]></artwork>
              </figure>
              If the configuration is available in multiple formats,
              such as XML and text, an XML namespace can be used
              to specify which format is desired.
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get-config>
      <source>
        <running/>
      </source>
      <filter type="subtree">
        <!-- request a text version of the configuration -->
        <config-text xmlns="http://example.com/text/1.2/config"/>
      </filter>
    </get-config>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
      <config-text xmlns="http://example.com/text/1.2/config">
        <!-- configuration text... -->
      </config-text>
    </data>
  </rpc-reply>
                  ]]></artwork>
              </figure>
            </t>

            <t>
              <xref target="subtree"/> contains additional examples
              of subtree filtering.
            </t>
          </list>
        </t>
      </section>
      <section title="&lt;edit-config&gt;">
        <t>
          <list style="hanging">
            <t hangText="Description:">
              <t>
The &lt;edit-config&gt; operation loads all or part of a specified
configuration to the specified target configuration.  This
operation allows the new configuration to be expressed in
several ways, such as using a local file, a remote file, or
inline.  If the target configuration does not exist, it will be
created.
              </t>
              <t>
The device analyzes the source and target configurations and
performs the requested changes.  The target configuration is not
necessarily
replaced, as with the &lt;copy-config&gt; message.  Instead the
target configuration is changed in accordance with the source's
data and requested operations.
              </t>
            </t>
            <t hangText="Attributes:">
              <list style="hanging">
                <t hangText="operation:">
                  <t>
                    Elements in the &lt;config&gt; subtree may contain an
                    "operation" attribute. The attribute identifies the point in
                    the configuration to perform the operation, and
                    MAY appear on multiple elements throughout the
                    &lt;config&gt; subtree.
                  </t>
                  <t>
                    If the operation attribute is not specified, the
                    configuration is merged into the configuration datastore.
                  </t>
                  <t>
                    The operation attribute has one of the following values:
                  </t>
                  <list style="hanging">
                    <t hangText="merge:">
                      The configuration data identified by the
                      element containing this attribute is
                      merged with the configuration at the corresponding
                      level in the configuration datastore identified by
                      the target parameter.  This is the default behavior.
                    </t>
                    <t hangText="replace:">
                      The configuration data identified by the
                      element containing this attribute
                      replaces any related configuration
                      in the configuration datastore identified by the target parameter.
                      Unlike a &lt;copy-config&gt; operation, which replaces
                      the entire target configuration, only the configuration
                      actually present in the config parameter
                      is affected.
                    </t>
                    <t hangText="create:">
                      The configuration data identified by the element
                      containing this attribute is added to the configuration
                      if and only if the configuration data does not already
                      exist on the device.
                      If the configuration data exists, an &lt;rpc-error&gt;
                      element is returned with an &lt;error-tag&gt;
                      value of data-exists.
                    </t>
                    <t hangText="delete:">
                      The configuration data identified by the
                      element containing this attribute is
                      deleted in the configuration datastore identified by
                      the target parameter.  
                    </t>
                  </list>
                </t>
              </list>
            </t>
            <t hangText="Parameters:">
              <list style="hanging">
                <t hangText="target:">
                  <t>
                    Configuration datastore being edited, such as
                    &lt;running/&gt; or &lt;candidate/&gt;.
                  </t>
                </t>
                <t hangText="default-operation:">
                  <t>
                    Selects the default operation (as described in the
                    "operation" attribute) for this &lt;edit-config&gt; request.
                    The default value for the default-operation
                    parameter is "merge". 
                  </t>
                  <t>
                    The default-operation parameter is optional, but if provided,
                    must have one of the following values:
                    <list style="hanging">
                      <t hangText="merge:">
                        The configuration data in the &lt;config&gt; parameter is
                        merged with the configuration at the corresponding level in
                        the target datastore.  This is the default behavior.
                      </t>
                      <t hangText="replace:">
                        The configuration data in the &lt;config&gt; parameter
                        completely replaces the configuration in the target
                        datastore.  This is useful for loading previously saved
                        configuration data.
                      </t>
                      <t hangText="none:">
                        The target datastore is unaffected by the
                        configuration in the &lt;config&gt; parameter,
                        unless and until the
                        incoming configuration data uses the "operation" attribute to
                        request a different operation.  If the configuration in the
                        &lt;config&gt; parameter contains data for which there is not a
                        corresponding level in the target datastore, an &lt;rpc-error&gt;
                        is returned with an &lt;error-tag&gt;
                        value of data-missing.
                        Using "none" allows operations like "delete" to avoid
                        unintentionally creating the parent hierarchy of the element to
                        be deleted.
                      </t>
                    </list>
                  </t>
                </t>
                <t hangText="test-option:">
                  <t>
                    The test-option element may be specified only if the device
                    advertises the <xref target="validate">:validate
                    capability</xref>.
                  </t>
                  <t>
                    The test-option element has one of the following values:
                  </t>
                  <list style="hanging">
                    <t hangText="test-then-set:">
                      Perform a validation test before attempting to set.
                      If validation errors occur, do not perform the &lt;edit-config&gt;
                      operation. This is the default test-option.
                    </t>
                    <t hangText="set:">
                      Perform a set without a validation test first.
                    </t>
                  </list>
                </t>
                <t hangText="error-option:">
                  <t>
                    The error-option element has one of the following values:
                  </t>
                  <list style="hanging">
                    <t hangText="stop-on-error:">
                      Abort the edit-config operation on first error. This
                      is the default error-option.
                    </t>
                    <t hangText="ignore-error:">
                      Continue to process configuration data on error;
                      error is recorded and negative response is
                      generated if any errors occur.
                    </t>
                    <t hangText="rollback-on-error:">
                      If an error condition occurs
                      such that an error severity &lt;rpc-error&gt; element is generated,
                      the server will stop processing the edit-config operation and
                      restore the specified configuration to its complete state
                      at the start of this edit-config operation. This option
                      requires the server to support the :rollback-on-error capability
                      described in <xref target="rollback-on-error"/>.
                    </t>
                  </list>
                </t>
                <t hangText="config:">
                  <t>
                    Portion of the configuration subtree to edit.
                  </t>
                </t>
              </list>
            </t>
            <t hangText="Positive Response:">
              <t>
    If the device was able to satisfy the request, an &lt;rpc-reply&gt;
    is sent containing an &lt;ok&gt; element.
              </t>
            </t>
            <t hangText="Negative Response:">
              <t>
    An &lt;rpc-error&gt; response is sent if the request cannot
    be completed for any reason.  
              </t>
            </t>
            <t hangText="Example:">
              <t>
              Set the MTU to 1500 on an interface named "Ethernet0/0" in
              the running configuration:
              </t>
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <running/>
      </target>
      <config>
        <top xmlns="http://example.com/schema/1.2/config">
          <interface>
            <name>Ethernet0/0</name>
            <mtu>1500</mtu>
          </interface>
        </top>
      </config>
    </edit-config>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
                  ]]></artwork>
              </figure>
            </t>
            <t>
              Add an interface named "Ethernet0/0" to the
              running configuration, replacing any previous interface
              with that name:
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <running/>
      </target>
      <config xmlns:xc="urn:ietf:params:xml:ns:netconf:base:1.0">
        <top xmlns="http://example.com/schema/1.2/config">
          <interface xc:operation="replace">
            <name>Ethernet0/0</name>
            <mtu>1500</mtu>
            <address>
              <name>192.0.2.4</name>
              <prefix-length>24</prefix-length>
            </address>
          </interface>
        </top>
      </config>
    </edit-config>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
                  ]]></artwork>
              </figure>
            </t>
            <t>
              Delete the configuration for an 
              interface named "Ethernet0/0" from the running configuration:
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <running/>
      </target>
      <default-operation>none</default-operation>
      <config xmlns:xc="urn:ietf:params:xml:ns:netconf:base:1.0">
        <top xmlns="http://example.com/schema/1.2/config">
          <interface xc:operation="delete">
            <name>Ethernet0/0</name>
          </interface>
        </top>
      </config>
    </edit-config>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
                  ]]></artwork>
              </figure>
            </t>
            <t>
              Delete interface 192.0.2.4 from an OSPF area (other
              interfaces configured in the same area are unaffected):
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <running/>
      </target>
      <default-operation>none</default-operation>
      <config xmlns:xc="urn:ietf:params:xml:ns:netconf:base:1.0">
        <top xmlns="http://example.com/schema/1.2/config">
          <protocols>
            <ospf>
              <area>
                <name>0.0.0.0</name>
                <interfaces>
                  <interface xc:operation="delete">
                    <name>192.0.2.4</name>
                  </interface>
                </interfaces>
              </area>
            </ospf>
          </protocols>
        </top>
      </config>
    </edit-config>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
                  ]]></artwork>
              </figure>
            </t>
          </list>
        </t>
      </section>
      <section title="&lt;copy-config&gt;">
        <t>
          <list style="hanging">
            <t hangText="Description:">
              <t>
    Create or replace an entire 
    configuration datastore with the contents of another
    complete configuration datastore.  If the target datastore
    exists, it is overwritten. Otherwise, a new one is created, if allowed. 
              </t>
              <t>
If a NETCONF peer supports <xref target="url">the :url capability</xref>,
the &lt;url&gt; element can appear as the &lt;source&gt; or &lt;target&gt;
parameter.
              </t>
              <t>
Even if it advertises the :writable-running capability,
a device may choose not to support the &lt;running/&gt; configuration
datastore as the &lt;target&gt; parameter of a &lt;copy-config&gt;
operation.
A device may choose not to support remote-to-remote copy operations,
where both the &lt;source&gt; and &lt;target&gt; parameters use the
&lt;url&gt; element.
If the source and target parameters identify the same URL or
configuration datastore, an error MUST be returned with an error-tag
containing invalid-value.
              </t>
            </t>
            <t hangText="Parameters:">
              <list style="hanging">
                <t hangText="source:">
                  <t>
                    The configuration datastore to use as the
                    source of the copy operation or the
                    &lt;config&gt; element containing the
                    configuration subtree to copy.
                  </t>
                </t>
                <t hangText="target:">
                  <t>
                    The configuration datastore to use as the destination of the
                    copy operation.
                  </t>
                </t>
              </list>
            </t>
            <t hangText="Positive Response:">
              <t>
    If the device was able to satisfy the request, an &lt;rpc-reply&gt;
    is sent that includes an &lt;ok&gt; element.
              </t>
            </t>
            <t hangText="Negative Response:">
              <t>
    An &lt;rpc-error&gt; element is included within the &lt;rpc-reply&gt;
    if the request cannot be completed for any reason.
              </t>
            </t>
            <t hangText="Example:">
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <copy-config>
      <source>
        <url>https://user@example.com:passphrase/cfg/new.txt</url>
      </source>
      <target>
        <running/>
      </target>
    </copy-config>
  </rpc>

  <rpc-reply message-id="101"
      xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
                  ]]></artwork>
              </figure>
            </t>
          </list>
        </t>
      </section>
      <section title="&lt;delete-config&gt;">
        <t>
          <list style="hanging">
            <t hangText="Description:">
              <t>
    Delete a configuration
    datastore. The &lt;running&gt; configuration datastore cannot be deleted.
              </t>
              <t>
If a NETCONF peer supports <xref target="url">the :url capability</xref>,
the &lt;url&gt; element can appear as the &lt;target&gt; parameter.
              </t>
            </t>
            <t hangText="Parameters:">
              <list style="hanging">
                <t hangText="target:">
                  <t>
                    Name of the configuration datastore to delete.
                  </t>
                </t>
              </list>
            </t>
            <t hangText="Positive Response:">
              <t>
    If the device was able to satisfy the request, an &lt;rpc-reply&gt;
    is sent that includes an &lt;ok&gt; element.
              </t>
            </t>
            <t hangText="Negative Response:">
              <t>
    An &lt;rpc-error&gt; element is included within the &lt;rpc-reply&gt;
    if the request cannot be completed for any reason.
              </t>
            </t>
            <t hangText="Example:">
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <delete-config>
      <target>
        <startup/>
      </target>
    </delete-config>
  </rpc>

   <rpc-reply message-id="101"
        xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
                  ]]></artwork>
              </figure>
            </t>
          </list>
        </t>
      </section>

        <section title="&lt;lock&gt;" anchor="lock">
            <t>
            <list style="hanging">
              <t hangText="Description:">
          <t>
The lock operation allows the client to lock the configuration
system of a device. Such locks are intended to be short-lived and
allow a client to make a change without fear of interaction with other
NETCONF clients, non-NETCONF clients (e.g. SNMP and CLI scripts) and
human users.
          </t>
          <t>
An attempt to lock the configuration MUST fail if an existing
session or other entity holds a lock on any portion of the
lock target.
          </t>
          <t>
When the lock is acquired, the server MUST prevent any changes to the
locked resource other than those requested by this session.
SNMP and CLI requests to modify the resource MUST
fail with an appropriate error.
          </t>
          <t>
The duration of the lock is defined as beginning when the lock is
acquired and lasting until either the lock is released or the NETCONF
session closes. The session closure may be explicitly performed by the
client, or implicitly performed by the server based on criteria such
as failure of the underlying transport,
or simple inactivity timeout. This criteria is dependent on the
implementation and the underlying transport.
          </t>
          <t>
   The lock operation takes a mandatory parameter, target.
   The target parameter names the configuration that will
   be locked.
   When a lock is active, using the &lt;edit-config&gt; operation
   on the locked
   configuration and using the locked configuration as a target of the
   &lt;copy-config&gt; operation will be disallowed by any other
   NETCONF session.
   Additionally, the system
   will ensure that these locked configuration resources will not be
   modified by other non-NETCONF management operations such as SNMP and
   CLI. The &lt;kill-session&gt; message (at the RPC layer) can be used to
   force
   the release of a lock owned by another NETCONF session.  It
   is beyond the scope of this document to define how to break
   locks held by other entities.
 </t>
              <t>
      A lock MUST not be granted if any of the following conditions are
      true:
<list style="symbols">
<t>
a lock is already held by another NETCONF session or another entity
</t>
<t>
the target configuration has already been modified and these
changes have not been committed or rolled back
</t>
</list>
              </t>
                <t>
The server MUST respond with either an &lt;ok&gt; element or an &lt;rpc-error&gt;.
                </t>
              <t>
                A lock will be released by the system if the session holding
                the lock is terminated for any reason.
              </t>
            </t>
            <t hangText="Parameters:">
              <list style="hanging">
                <t hangText="target:">
                  <t>
                    Name of the configuration datastore to lock.
                  </t>
                </t>
              </list>
            </t>
            <t hangText="Positive Response:">
                    <t>
    If the device was able to satisfy the request, an &lt;rpc-reply&gt;
    is sent that contains an &lt;ok&gt; element.
                    </t>
                  </t>
                  <t hangText="Negative Response:">
                    <t>
    An &lt;rpc-error&gt; element is included in the &lt;rpc-reply&gt;
    if the request cannot be completed for any reason.
                    </t>
                    <t>
    If the lock is already held, the &lt;error-tag&gt; element
    will be 'lock-denied' and the &lt;error-info&gt; element will include the
    &lt;session-id&gt; of the lock owner. If the lock is held
    by a non-NETCONF entity, a &lt;session-id&gt; of 0 (zero) is included.
    Note that any
    other entity performing a lock on even a partial piece of a
    target will prevent a NETCONF lock (which is global) from
    being obtained on that target.
                    </t>
                  </t>
                  <t hangText="Example:">
<t>The following example shows a successful acquisition of a lock.</t>
                    <figure>
                      <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <lock>
      <target>
        <running/>
      </target>
    </lock>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/> <!-- lock succeeded -->
  </rpc-reply>

                        ]]></artwork>
                    </figure>
                  </t>
                  <t hangText="Example:">
<t>The following example shows a failed attempt to acquire a lock
when the lock is already in use.</t>
                    <figure>
                      <artwork><![CDATA[

  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <lock>
      <target>
        <running/>
      </target>
    </lock>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <rpc-error> <!-- lock failed -->
      <error-type>protocol</error-type>
      <error-tag>lock-denied</error-tag>
      <error-severity>error</error-severity>
      <error-message>
        Lock failed, lock is already held
      </error-message>
      <error-info>
        <session-id>454</session-id>
        <!-- lock is held by NETCONF session 454 -->
      </error-info>
    </rpc-error>
  </rpc-reply>
                        ]]></artwork>
                    </figure>
                  </t>
                </list>
            </t>
        </section><!-- end of Lock operation -->
            
          <section title="&lt;unlock&gt;">
            <t>
              <list style="hanging">
            <t hangText="Description:">
              <t>
The unlock operation is used to release a configuration
lock, previously obtained with the &lt;lock&gt; operation.
              </t>
              <t>
An unlock operation will not succeed if any of the following 
conditions are true:
                <list style="symbols">
                  <t>the specified lock is not currently active</t>
                  <t>the session issuing the &lt;unlock&gt; operation is not
                    the same session that obtained the lock</t>
                </list>
              </t>
                <t>
The server MUST respond with either an &lt;ok&gt; element or an &lt;rpc-error&gt;.
                </t>
            </t>
            <t hangText="Parameters:">
              <list style="hanging">
                <t hangText="target:">
                  <t>
                    Name of the configuration datastore to unlock.
                  </t>
                  <t>
                      A NETCONF client is not permitted to unlock a
                      configuration datastore that it did not lock.
                  </t>
                </t>
              </list>
            </t>
            <t hangText="Positive Response:">
              <t>
    If the device was able to satisfy the request, an &lt;rpc-reply&gt;
    is sent that contains an &lt;ok&gt; element.
              </t>
            </t>
            <t hangText="Negative Response:">
              <t>
    An &lt;rpc-error&gt; element is included in the &lt;rpc-reply&gt;
    if the request cannot be completed for any reason.
              </t>
            </t>
            <t hangText="Example:">
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <unlock>
      <target>
       <running/>
      </target>
    </unlock>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
                  ]]></artwork>
              </figure>
            </t>
                </list>
            </t>
            </section> <!-- end of Unlock operation -->

      <section title="&lt;get&gt;">
        <t>
          <list style="hanging">
            <t hangText="Description:">
              <t>
                Retrieve running configuration and device state information.
              </t>
            </t>
            <t hangText="Parameters:">
              <list style="hanging">
                <t hangText="filter:">
                  <t>
        This parameter specifies the portion of the system configuration and state 
        data to retrieve. If this parameter is empty, all the device configuration
        and state information is returned.
                  </t>
      <t>
        The filter element may optionally contain a 'type' attribute.
        This attribute indicates the type of filtering syntax used within
        the filter element. The default filtering mechanism in NETCONF is
        referred to as subtree filtering and is described in
        <xref target="subtree" />. The value 'subtree'
        explicitly identifies this type of filtering.
      </t>
      <t>
        If the NETCONF peer supports <xref target="xpath">the :xpath capability</xref>,
        the value 'xpath' may be used to indicate that the filter element
        contains an XPath expression.
      </t>
                </t>
              </list>
            </t>
            <t hangText="Positive Response:">
              <t>
    If the device was able to satisfy the request, an &lt;rpc-reply&gt;
    is sent.  The &lt;data&gt; section contains the 
    appropriate subset.
              </t>
            </t>
            <t hangText="Negative Response:">
              <t>
    An &lt;rpc-error&gt; element is included in the &lt;rpc-reply&gt;
    if the request cannot be completed for any reason.
              </t>
            </t>
            <t hangText="Example:">
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get>
      <filter type="subtree">
        <top xmlns="http://example.com/schema/1.2/stats">
          <interfaces>
            <interface>
              <ifName>eth0</ifName>
            </interface>
          </interfaces>
        </top>
      </filter>
    </get>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
      <top xmlns="http://example.com/schema/1.2/stats">
        <interfaces>
          <interface>
            <ifName>eth0</ifName>
            <ifInOctets>45621</ifInOctets>
            <ifOutOctets>774344</ifOutOctets>
          </interface>
        </interfaces>
      </top>
    </data>
  </rpc-reply>
                  ]]></artwork>
              </figure>
            </t>
          </list>
        </t>
      </section>

      <section title="&lt;close-session&gt;">
        <t>
          <list style="hanging">
            <t hangText="Description:">
              <t>Request graceful termination of a NETCONF session.</t>
              <t>
                When a NETCONF server receives a &lt;close-session&gt;
                request, it will gracefully close the session.
                The server will release any
                locks and resources associated with the session and
                gracefully close any associated connections.
                Any NETCONF requests received after a &lt;close-session&gt;
                request will be ignored.
              </t>
            </t>
            <t hangText="Positive Response:">
              <t>
      If the device was able to satisfy the request, an &lt;rpc-reply&gt;
      is sent that includes an &lt;ok&gt; element.
              </t>
            </t>
            <t hangText="Negative Response:">
              <t>
      An &lt;rpc-error&gt; element is included in the &lt;rpc-reply&gt; if the
      request cannot be completed for any reason.
              </t>
            </t>
            <t hangText="Example:">
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <close-session/>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
                  ]]></artwork>
              </figure>
            </t>
          </list>
        </t>
      </section>

      <section title="&lt;kill-session&gt;">
        <t>
          <list style="hanging">
            <t hangText="Description:">
              <t>Force the termination of a NETCONF session.</t>
              <t>
                When a NETCONF entity receives a &lt;kill-session&gt;
                request for an open session, it will abort any operations
                currently in process, release any locks and resources
                associated with the session and close any
                associated connections.
              </t>
              <t>
                If a NETCONF server receives a &lt;kill-session&gt; request
                while processing a confirmed commit (<xref target='confirmed'/>),
                it must restore the configuration to its state before
                the confirmed commit was issued.
              </t>
              <t>
                Otherwise, the &lt;kill-session&gt; operation does not roll back
                configuration or other device state modifications made
                by the entity holding the lock.
              </t>
            </t>
            <t hangText="Parameters:">
              <list style="hanging">
                <t hangText="session-id:">
                  <t>
         Session identifier of the NETCONF session to be terminated.
         If this value is equal to the current session ID,
         an 'invalid-value' error is returned.
                  </t>
                </t>
              </list>
            </t>
            <t hangText="Positive Response:">
              <t>
      If the device was able to satisfy the request, an &lt;rpc-reply&gt;
      is sent that includes an &lt;ok&gt; element.
              </t>
            </t>
            <t hangText="Negative Response:">
              <t>
      An &lt;rpc-error&gt; element is included in the &lt;rpc-reply&gt; if the
      request cannot be completed for any reason.
              </t>
            </t>
            <t hangText="Example:">
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <kill-session>
      <session-id>4</session-id>
    </kill-session>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
                  ]]></artwork>
              </figure>
            </t>
          </list>
        </t>
      </section>

    </section>
    
    <section title="Capabilities" anchor="capabilities">
      <t>
This section defines a set of capabilities that a client or a server MAY
implement.
Each peer advertises its capabilities by
sending them during an initial capabilities exchange. Each peer
needs to understand only those capabilities that it might use and MUST
ignore any capability received from the other
peer that it does not require or does not understand.
      </t>
      <t>
Additional capabilities can be defined using the template in
<xref target="capabilityTemplate" />.
Future capability definitions may be published as standards by
standards bodies or published as proprietary extensions.
      </t>
      <t>
A NETCONF capability is identified with a URI.
The base capabilities are defined using URNs following
the method described in <xref target="RFC3553">RFC 3553</xref>.
Capabilities defined in this document have the following format:
        <list style="empty">
          <t>urn:ietf:params:netconf:capability:{name}:1.0</t>
        </list>
where {name} is the name of the capability. Capabilities are often referenced
in discussions and email using the shorthand :{name}. For example, the
foo capability would have the formal name
"urn:ietf:params:netconf:capability:foo:1.0" and be called ":foo". The
shorthand form MUST NOT be used inside the protocol.
      </t>
      
      <section title="Capabilities Exchange" anchor="capabilityExchange">
        <t>
Capabilities are advertised in messages sent 
by each peer during session establishment. When the NETCONF session is
opened, each peer (both client and server) MUST send a &lt;hello&gt;
element containing a list of that peer's capabilities. 
Each peer MUST send at least the base NETCONF capability,
"urn:ietf:params:netconf:base:1.0".
        </t>
        <t>
A server sending the &lt;hello&gt; element
MUST include a &lt;session-id&gt; element containing the
session ID for this NETCONF session.
A client sending the &lt;hello&gt; element MUST NOT
include a &lt;session-id&gt; element.
        </t>
        <t>
A server receiving a &lt;session-id&gt; element MUST NOT continue
the NETCONF session.
Similarly, a client that does not receive a &lt;session-id&gt; element 
in the server's &lt;hello&gt; message MUST NOT continue the NETCONF session.
In both cases the underlying transport
should be closed.
        </t>
        <t>
In the following example, a server advertises the base NETCONF capability,
one NETCONF capability defined in the base NETCONF document, and one
implementation-specific capability.
        </t>
        <figure>
          <artwork><![CDATA[
<hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
  <capabilities>
    <capability>
      urn:ietf:params:netconf:base:1.0
    </capability>
    <capability>
      urn:ietf:params:netconf:capability:startup:1.0
    </capability>
    <capability>
      http:/example.net/router/2.3/myfeature
    </capability>
  </capabilities>
  <session-id>4</session-id>
</hello>
            ]]></artwork>
        </figure>
        <t>
Each peer sends its &lt;hello&gt; element simultaneously as soon as the
connection is open. A peer MUST NOT wait to receive the capability set
from the other side before sending its own set.
        </t>
      </section>
      
      <section title="Writable-Running Capability">
        <section title="Description">
          <t>
The :writable-running capability indicates that the device
supports writes directly to the &lt;running&gt; configuration datastore. In other
words, the device supports edit-config and
copy-config operations where the &lt;running&gt; configuration is the
target.</t>
        </section>
        <section title="Dependencies">
          <t>None.</t>
        </section>
        <section title="Capability Identifier">
          <t>The :writable-running capability is identified by the
            following capability string:
            <list style="empty">
              <t>urn:ietf:params:netconf:capability:writable-running:1.0</t>
            </list>
          </t>
        </section> <!-- end of Capability & Namespace -->
        <section title="New Operations">
          <t>None.</t>
        </section>
        <section title="Modifications to Existing Operations">
          <section title="&lt;edit-config&gt;">
            <t>
            The :writable-running capability modifies the
            &lt;edit-config&gt; operation to accept the
            &lt;running&gt; element as a &lt;target&gt;.
            </t>
          </section>
          <section title="&lt;copy-config&gt;">
            <t>
            The :writable-running capability modifies the
            &lt;copy-config&gt; operation to accept the
            &lt;running&gt; element as a &lt;target&gt;.
            </t>
          </section>
        </section>
      </section> <!-- end of writable-running capability -->

      <section title="Candidate Configuration Capability" anchor="candidate">
        <section title="Description">
          <t>
The candidate configuration capability, :candidate, indicates that
the device supports a candidate configuration datastore, which is used to hold
configuration data that can be manipulated without impacting the device's
current configuration.  The candidate configuration is a full
configuration data set that serves as a work place for creating and
manipulating configuration data.  Additions, deletions, and changes
may be made to this data to construct the desired configuration
data. A &lt;commit&gt; operation may be performed
at any time that causes the device's running configuration to be
set to the value of the candidate configuration.
          </t>
          <t>
The candidate configuration can be used as a source or target of any
operation with a &lt;source&gt; or &lt;target&gt; parameter. The &lt;candidate&gt;
element is used to indicate the candidate configuration:
            <figure>
              <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get-config> <!-- any NETCONF operation -->
      <source>
        <candidate/>
      </source>
    </get-config>
  </rpc>
            ]]></artwork>
        </figure>
          </t>
          <t>
   The candidate configuration may be shared among multiple
   sessions. Unless a client has specific information that the
   candidate configuration is not shared (for example, through another
   capability, e.g. :lock), it must assume that other sessions may be able to
   modify the candidate configuration at the same time. It is
   therefore prudent for a client to lock the candidate configuration
   before modifying it.
            </t>
            <t>
   The client can discard any changes since the last &lt;commit&gt;
   operation by executing the &lt;discard-changes&gt; operation.
   The candidate configuration's content then reverts to the current
   committed configuration.
            </t>
        </section> <!-- end of Description -->
        
        <section title="Dependencies">
          <t>None.</t>
        </section>
        <section title="Capability Identifier">
          <t> The :candidate capability is identified by the
            following capability string:
            <list style="empty">
              <t>urn:ietf:params:netconf:capability:candidate:1.0</t>
            </list>
          </t>
        </section> <!-- end of Capability & Namespace -->
        <section title="New Operations">
        <section title="&lt;commit&gt;">
          <t>
            <list style="hanging">
              <t hangText="Description:">
              <list style="empty">
                <t>
When a candidate configuration's content is complete, the
configuration data can be committed, publishing the data set to the
rest of the device and requesting the device to conform to the
behavior described in the new configuration.
                </t>
                <t>
To commit the candidate configuration as the device's new current
configuration, use the &lt;commit&gt; operation.
                </t>
                <t>
The &lt;commit&gt; operation instructs the device to implement the
configuration data contained in the candidate configuration.
If the device is unable to commit all of the changes in the candidate
configuration datastore, then the running configuration MUST
remain unchanged.  If the device does succeed in committing, the
running configuration MUST be updated with the contents of the
candidate configuration.
              </t>
              <t>
If the system does not have the :candidate
capability, the &lt;commit&gt; operation is not available.
              </t>
            </list>
            </t>
            <t hangText="Positive Response:">
              <list style="empty">
              <t>
    If the device was able to satisfy the request, an &lt;rpc-reply&gt;
    is sent that contains an &lt;ok&gt; element.
              </t>
              </list>
            </t>
            <t hangText="Negative Response:">
              <list style="empty">
              <t>
    An &lt;rpc-error&gt; element is included in the &lt;rpc-reply&gt;
    if the request cannot be completed for any reason.
              </t>
              </list>
            </t>
            <t hangText="Example:">
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <commit/>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
                  ]]></artwork>
              </figure>
            </t>
          </list>
        </t>
      
        </section>
        <section title="&lt;discard-changes&gt;" anchor="discard-changes">
          <t>
If the client decides that the candidate configuration should not be
committed, the &lt;discard-changes&gt; operation can be used to revert the
candidate configuration to the current running configuration.
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <discard-changes/>
  </rpc>
                  ]]></artwork>
              </figure>
This operation discards any uncommitted changes by resetting the
candidate configuration with the content of the running configuration.
          </t>              
        </section>
          </section>
        <section title="Modifications to Existing Operations">
          <section title="&lt;lock&gt; and &lt;unlock&gt;">
            <t>
The candidate configuration can be locked using the &lt;lock&gt;
operation with the &lt;candidate&gt; element as the &lt;target&gt; parameter:
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <lock>
      <target>
        <candidate/>
      </target>
    </lock>
  </rpc>
                  ]]></artwork>
              </figure>
Similarly, the candidate configuration is unlocked using
the &lt;candidate&gt; element as the &lt;target&gt; parameter:
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <unlock>
      <target>
        <candidate/>
      </target>
    </unlock>
  </rpc>
                  ]]></artwork>
              </figure>
            </t>
            <t>
When a client fails with outstanding changes to the candidate
configuration, recovery can be difficult. To facilitate easy recovery,
any outstanding changes are discarded when the lock is released,
whether explicitly with the &lt;unlock&gt; operation or implicitly from
session failure.
            </t>
          </section>
        </section>
      </section>
            
      <section title="Confirmed Commit Capability" anchor="confirmed">
        <section title="Description">
          <t>
The :confirmed-commit capability indicates that the server will
support the &lt;confirmed&gt; and &lt;confirm-timeout&gt; parameters for the
&lt;commit&gt; protocol operation. See section <xref target="candidate" />
for further details on the &lt;commit&gt; operation.
</t>
<t>
A confirmed commit operation MUST be reverted if a follow-up
commit (called the "confirming commit") is not issued within
600 seconds (10 minutes).
The timeout period can be adjusted with the &lt;confirm-timeout&gt;
element. The confirming commit can itself include a &lt;confirmed&gt; parameter.
</t>
<t>
If the session issuing the confirmed commit is terminated for any reason
before the confirm timeout expires, the server MUST restore the configuration
to its state before the confirmed commit was issued.
</t>
<t>
If the device reboots for any reason before the confirm timeout expires,
the server MUST restore the configuration to its state before the 
confirmed commit was issued.
</t>
<t>
If a confirming commit is not issued, the device will revert its configuration
to the state prior to the issuance of the confirmed commit.
Note that any commit operation, including a commit which introduces
additional changes to the configuration, will serve as a confirming commit.
Thus to cancel a confirmed commit and revert changes without waiting
for the confirm timeout to expire, the manager can explicitly
restore the configuration to its state before the confirmed commit
was issued.
</t>
<t>
For shared configurations, this feature can cause other
configuration changes (for example, via other NETCONF sessions) to be
inadvertently altered or removed, unless the configuration locking
feature is used (in other words, lock obtained before the edit-config
operation is started). Therefore, it is strongly suggested that in
order to use this feature with shared configuration databases,
configuration locking should also be used.
</t>
        </section> <!-- end of Description -->
        
        <section title="Dependencies">
          <t>The :confirmed-commit capability is only relevant if the :candidate
capability is also supported.</t>
        </section>
        <section title="Capability Identifier">
          <t> The :confirmed-commit capability is identified by the
            following capability string:
            <list style="empty">
              <t>urn:ietf:params:netconf:capability:confirmed-commit:1.0</t>
            </list>
          </t>
        </section> <!-- end of Capability & Namespace -->
        <section title="New Operations">
          <t>None.</t>
        </section>
        <section title="Modifications to Existing Operations">
          <section title="&lt;commit&gt;">
            <t>The :confirmed-commit capability allows 2 additional
            parameters to the &lt;commit&gt; operation.</t>
            <list style="hanging">
            <t hangText="Parameters:">
              <list style="hanging">
                <t hangText="confirmed:">
                  <list style="empty">
                    <t>
                      Perform a confirmed commit operation.
                    </t>
                  </list>
                </t>
                <t hangText="confirm-timeout:">
                  <list style="empty">
                    <t>
                      Timeout period for confirmed commit, in seconds.
                      If unspecified, the confirm timeout defaults to
                      600 seconds.
                    </t>
                  </list>
                </t>
              </list>
            </t>
            <t hangText="Example:">
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <commit>
      <confirmed/>
      <confirm-timeout>120</confirm-timeout>
    </commit>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
                   ]]></artwork>
               </figure>
             </t>
            </list>
           </section>
         </section>
       </section> <!-- confirmed commit capability -->

      <section title="Rollback on Error Capability" anchor="rollback-on-error">
        <section title="Description">
          <t>
            This capability indicates that the server will support the
            'rollback-on-error' value in the &lt;error-option&gt; parameter
            to the &lt;edit-config&gt; operation.
          </t>
          <t>
            For shared configurations, this feature can cause other
            configuration changes (for example, via other NETCONF sessions) to be
            inadvertently altered or removed, unless the configuration locking
            feature is used (in other words, lock obtained before the edit-config
            operation is started). Therefore, it is strongly suggested that in
            order to use this feature with shared configuration databases,
            configuration locking must also be used.
          </t>
        </section> <!-- end of Description -->
        
        <section title="Dependencies">
          <t>None</t>
        </section>
        <section title="Capability Identifier">
          <t> The :rollback-on-error capability is identified by the
            following capability string:
            <list style="empty">
              <t>urn:ietf:params:netconf:capability:rollback-on-error:1.0</t>
            </list>
          </t>
        </section> <!-- end of Capability & Namespace -->
        <section title="New Operations">
          <t>None.</t>
        </section>
        <section title="Modifications to Existing Operations">
          <section title="&lt;edit-config&gt;">
            <t>The :rollback-on-error capability allows the
            'rollback-on-error' value to the &lt;error-option&gt;
            parameter on the &lt;edit-config&gt; operation.</t>
            <t hangText="Example:">
              <figure>
                <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <running/>
      </target>
      <error-option>rollback-on-error</error-option>
      <config>
        <top xmlns="http://example.com/schema/1.2/config">
          <interface>
            <name>Ethernet0/0</name>
            <mtu>100000</mtu>
          </interface>
        </top>
      </config>
    </edit-config>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
                   ]]></artwork>
               </figure>
             </t>
           </section>
         </section>
       </section> <!-- rollback-on-error capability -->

       <section title="Validate Capability" anchor="validate">
         <section title="Description">
           <t>
             Validation consists of checking a candidate
             configuration for syntactical and semantic errors before
             applying the configuration to the device.
           </t>
           <t>
 If this capability is advertised, the device supports the
 &lt;validate&gt; protocol operation and checks at least for syntax
 errors. In addition, this capability supports the test-option parameter to the
 &lt;edit-config&gt; operation and, when it is provided, checks at
 least for syntax errors.
           </t>
         </section> <!-- end of Description -->
         <section title="Dependencies">
           <t>None.</t>
         </section>
         <section title="Capability Identifier">
           <t> The :validate capability is identified by the
             following capability string:
             <list style="empty">
               <t>urn:ietf:params:netconf:capability:validate:1.0</t>
             </list>
           </t>
         </section> <!-- end of Capability & Namespace -->

         <section title="New Operations">
         <section title="&lt;validate&gt;">
         <t>
           <list style="hanging">
             <t hangText="Description:">
               <list style="empty">
               <t>
                 This protocol operation validates the contents of the 
                 specified configuration.
               </t>
               </list>
             </t>
             <t hangText="Parameters:">
               <list style="hanging">
                 <t hangText="source:">
                   <list style="empty">
                   <t>
     Name of the configuration datastore being validated, such as
     &lt;candidate&gt;.
                   </t>
                   </list>
                 </t>
               </list>
             </t>
             <t hangText="Positive Response:">
               <list style="empty">
               <t>
     If the device was able to satisfy the request, an &lt;rpc-reply&gt;
     is sent that contains an &lt;ok&gt; element.
               </t>
               </list>
             </t>
             <t hangText="Negative Response:">
               <list style="empty">
               <t>
     An &lt;rpc-error&gt; element is included in the &lt;rpc-reply&gt;
     if the request cannot be completed for any reason.
               </t>
               <t>
     A validate operation can fail for any of the following reasons:
                 <list style="symbols">
                   <t>Syntax errors</t>
                   <t>Missing parameters</t>
                   <t>References to undefined configuration data</t>
                 </list>
               </t>
               </list>
             </t>
             <t hangText="Example:">
               <figure>
                 <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <validate>
      <source>
        <candidate/>
      </source>
    </validate>
  </rpc>

  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
                   ]]></artwork>
               </figure>
             </t>
           </list>
         </t>
           </section> <!-- end of validate operation -->
         </section>
       </section>

       <section title="Distinct Startup Capability" anchor="startup">
         <section title="Description">
           <t>
     The device supports separate running and startup 
     configuration datastores.  Operations which affect the running
     configuration will not be automatically copied to the
     startup configuration.  An explicit &lt;copy-config&gt;
     operation from the &lt;running&gt; to the &lt;startup&gt;
     must be invoked to update the startup configuration
     to the current contents of the running configuration.
     NETCONF protocol operations refer to the startup datastore
     using the &lt;startup&gt; element.
           </t>
         </section>
         <section title="Dependencies">
           <t>None.</t>
         </section>
         <section title="Capability Identifier">
           <t>The :startup capability is identified by the
             following capability string:
             <list style="empty">
               <t>urn:ietf:params:netconf:capability:startup:1.0</t>
             </list>
           </t>
         </section> <!-- end of Capability & Namespace -->
         <section title="New Operations">
           <t>None.</t>
         </section>
         <section title="Modifications to Existing Operations">
           <section title="&lt;copy-config&gt;">
             <t>
               To save the startup configuration, use the copy-config
               operation to copy the &lt;running&gt; configuration
               datastore to the &lt;startup&gt; configuration datastore.
               <figure>
                 <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <copy-config>
      <source>
        <running/>
      </source>
      <target>
        <startup/>
      </target>
    </copy-config>
  </rpc>
                   ]]></artwork>
               </figure>
             </t>
           </section>
         </section>
       </section>

       <section title="URL Capability" anchor="url">
         <section title="Description">
           <t>
             The NETCONF peer has the ability to accept the &lt;url&gt;
             element in &lt;source&gt; and &lt;target&gt;
             parameters. The capability is further identified by
             URL arguments indicating the protocols supported.
           </t>
         </section>
         <section title="Dependencies">
           <t>None.</t>
         </section>
         <section title="Capability Identifier">
           <t>The :url capability is identified by the
             following capability string:
           </t>
           <t>urn:ietf:params:netconf:capability:url:1.0?protocol={name,...}</t>
           <t>
             The :url capability URI MUST contain a "protocol" argument
             assigned a comma-separated list of protocol names indicating
             which protocols the NETCONF peer supports. For example:
             <list style="empty">
               <t>urn:ietf:params:netconf:capability:url:1.0?protocol=http,ftp,file</t>
             </list>
           </t>
         </section> <!-- end of Capability & Namespace -->
         <section title="New Operations">
           <t>None.</t>
         </section>
         <section title="Modifications to Existing Operations">
           <section title="&lt;edit-config&gt;">
             <t>The :url capability modifies the
             &lt;edit-config&gt; operation to accept the
             &lt;url&gt; element as an alternative to the &lt;config&gt; parameter.
             If the &lt;url&gt; element is specified, then it should identify
             a local configuration file.</t>
           </section>
           <section title="&lt;copy-config&gt;">
             <t>The :url capability modifies the
             &lt;copy-config&gt; operation to accept the
             &lt;url&gt; element as the value of the
             the &lt;source&gt; and the &lt;target&gt; parameters.</t>
           </section>
           <section title="&lt;delete-config&gt;">
             <t>The :url capability modifies the
             &lt;delete-config&gt; operation to accept the
             &lt;url&gt; element as the value of the
             the &lt;target&gt; parameters.
             If this parameter contains a URL, then it should identify
             a local configuration file.
             </t>
           </section>
           <section title="&lt;validate&gt;">
             <t>The :url capability modifies the
             &lt;validate&gt; operation to accept the
             &lt;url&gt; element as the value of the
             the &lt;source&gt; parameter.</t>
           </section>
         </section>
       </section> <!-- end of URL capability -->

       <section title="XPath Capability" anchor="xpath">
         <section title="Description">
           <t>
             The XPath capability indicates that the NETCONF
             peer supports the use of XPath expressions in the
             &lt;filter&gt; element.
             XPath is described in <xref target="W3C.REC-xpath-19991116" />.
           </t>
         </section>
         <section title="Dependencies">
           <t>None.</t>
         </section>
         <section title="Capability Identifier">
           <t>The :xpath capability is identified by the
             following capability string:
             <list style="empty">
               <t>urn:ietf:params:netconf:capability:xpath:1.0</t>
             </list>
           </t>
         </section> <!-- end of Capability & Namespace -->
         <section title="New Operations">
           <t>None.</t>
         </section>
         <section title="Modifications to Existing Operations">
           <section title="&lt;get-config&gt; and &lt;get&gt;">
             <t>
               The :xpath capability modifies the
               &lt;get&gt; and &lt;get-config&gt; operations to accept the
               value "xpath" in the type attribute of
               the filter element. When the type attribute
               is set to "xpath", the contents of the filter element
               will be treated as an xpath expression and used to
               filter the returned data.
             </t>
             <t>
               For example:
               <figure>
                 <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get-config>
      <source>
        <running/>
      </source>
      <filter type="xpath"> <!-- get the user named fred -->
        top/users/user[name="fred"]
      </filter>
    </get-config>
  </rpc>
                   ]]></artwork>
               </figure>
             </t>
           </section>
         </section>
       </section> <!-- end of XPath capability -->

     </section> <!-- Capabilities -->

     <section title="Security Considerations" anchor="security">
<t>
This document does not specify an authorization scheme, as 
such a scheme should be tied to a meta-data model or a
data model.  Implementors SHOULD provide a comprehensive
authorization scheme with NETCONF.
</t>
<t>
Authorization of individual users via the NETCONF server may or may
not map 1:1 to other interfaces.  First, the
data models may be incompatible.  Second, it may be desirable to
authorize based on mechanisms available in the application protocol
layer (TELNET, SSH, etc).
</t>
<t>
In addition, operations on configurations may have unintended
consequences if those operations are also not guarded by the global
lock on the files or objects being operated upon.  For instance, a
partially complete access list could be committed from a candidate
configuration unbeknownst to the owner of the lock of the candidate
configuration, leading to either an insecure or inaccessible device
if the lock on the candidate configuration does not also apply to
the &lt;copy-config&gt; operation when applied to it.
</t>
 <t>
 Configuration information is by its very nature sensitive.  Its
 transmission in the clear and without integrity checking leaves devices
 open to classic eavesdropping attacks.  Configuration
 information often contains passwords, user names, service
 descriptions, and topological information, all of which are
 sensitive.  Because of this, this protocol should be implemented
 carefully with adequate attention to all manner of attack one might
 expect to experience with other management interfaces.
 </t>
 <t>
 The protocol, therefore, must minimally support options for both
 privacy and authentication.  It is anticipated that the
 underlying protocol (SSH, BEEP, etc) will provide for both
 privacy and authentication, as is required.  It is further
 expected that the identity of each end of a NETCONF session will be
 available to the other in order to determine authorization for any
 given request.  One could also easily envision additional information
 such as transport and encryption methods being made available for purposes of
 authorization.  NETCONF itself provide no means to reauthenticate, much
 less authenticate.  All such actions occur at lower layers. 
 </t>
 <t>
 Different environments may well allow different rights prior to and
 then after authentication.  Thus, an authorization model is not
 specified in this document.  When an operation is not properly
 authorized then a simple "permission denied" is sufficient.
 Note that authorization information may be exchanged in the form of
 configuration information, which is all the more reason to ensure the
 security of the connection.
 </t>
 <t>
 That having been said, it is important to recognize that some
 operations are clearly more sensitive by nature than others.  For
 instance, &lt;copy-config&gt; to the startup or running
 configurations is clearly not a normal provisioning operation,
 where-as &lt;edit-config&gt; is.
Such global operations MUST disallow the changing of information
that an individual does not have authorization to perform.
For example, if a user A is not allowed to configure an IP
address on an interface but user B has configured an IP address
on an interface in the &lt;candidate&gt; configuration,
user A must not be allowed to commit the &lt;candidate&gt;
configuration.
 </t>
 <t>
 Similarly, just because someone
 says go write a configuration through the URL capability at a
 particular place does not mean that an element should do it without
 proper authorization.
</t>
 <t>
     The &lt;lock&gt; operation will demonstrate that NETCONF
     is intended for use by systems that have at least some trust of
     the administrator.  As specified in this document, it is possible
     to lock portions of a configuration that a principal might not
     otherwise have access to.  After all, the entire configuration is
     locked.  To mitigate this problem there are two approaches.  It
     is possible to kill another NETCONF session programmatically from
     within NETCONF if one knows the session identifier of the
     offending session.  The other possible way to break a lock is to
     provide an function within the device's native user interface.
These two mechanisms suffer from a race condition
that may be ameliorated by removing the offending user from an AAA
server.  However, such a solution is not useful in all deployment
scenarios, such as those where SSH public/private key pairs are used.
</t>

   </section> <!-- Security Considerations -->
   
   <section title="IANA Considerations"> <!-- RFC 2434 -->
     <section title="NETCONF XML Namespace">
       <t>
This document requests that IANA assign a URI for the NETCONF XML
namespace in the <xref target="RFC3688">IETF XML registry</xref>.
       </t>
       <t>
Following the format in RFC 3688, the following registration is requested.
       </t>
       <t>
URI: Please assign the URI "urn:ietf:params:xml:ns:netconf:base:1.0" for
use by the NETCONF protocol.
       </t>
       <t>
Registrant Contact: The IESG.
       </t>
       <t>
XML: N/A, the requested URI is an XML namespace.
       </t>
     </section>
     <section title="NETCONF XML Schema">
       <t>
This document requests that IANA assign a URI for the NETCONF XML
schema in the <xref target="RFC3688">IETF XML registry</xref>.
       </t>
       <t>
Following the format in RFC 3688, the following registration is requested.
       </t>
       <t>
URI: Please assign the URI "urn:ietf:params:xml:schema:netconf" for use by
the NETCONF protocol.
       </t>
       <t>
Registrant Contact: The IESG.
       </t>
       <t>
XML: <xref target="protocolSchema"/> of this document.
       </t>
     </section>
     <section title="NETCONF Capability URNs">
       <t>
This document requests that IANA create a registry
for allocating NETCONF capability identifiers.
Allocation from the registry is on a First Come First
Served basis, but a specification is required.
       </t>
       <t>
The initial content of the registry will be the capability
URNs defined in <xref target="capabilities"/>.
Once further experience is gained with NETCONF, this sub-namespace
may be used for additional purposes.
       </t>
       <t>
Following the guidelines in <xref target="RFC3553">RFC 3553</xref>,
IANA is requested to assign a NETCONF sub-namespace as follows:
       </t>
       <t>
Registry name: netconf
       </t>
       <t>
Specification: <xref target="capabilities"/> of this document.
       </t>
       <t>
Repository: The following table.
       </t>
       <t>
         <texttable>
           <ttcol width='30%'>Index</ttcol>
           <ttcol>Capability Identifier</ttcol>

           <c>:writable-running</c>
           <c>urn:ietf:params:netconf:capability:writable-running:1.0</c>

           <c>:candidate</c>
           <c>urn:ietf:params:netconf:capability:candidate:1.0</c>

           <c>:confirmed-commit</c>
           <c>urn:ietf:params:netconf:capability:confirmed-commit:1.0</c>

           <c>:rollback-on-error</c>
           <c>urn:ietf:params:netconf:capability:rollback-on-error:1.0</c>

           <c>:validate</c>
           <c>urn:ietf:params:netconf:capability:validate:1.0</c>

           <c>:startup</c>
           <c>urn:ietf:params:netconf:capability:startup:1.0</c>

           <c>:url</c>
           <c>urn:ietf:params:netconf:capability:url:1.0</c>

           <c>:xpath</c>
           <c>urn:ietf:params:netconf:capability:xpath:1.0</c>
         </texttable>
       </t>
       <t>
Index value: The NETCONF capability name.
       </t>
     </section>
   </section> <!-- IANA Considerations -->

     <section title="Authors and Acknowledgements">
       <t>This document was written by:
         <list style="empty">
           <t>Andy Bierman, Cisco Systems</t>
           <t>Ken Crozier, Cisco Systems</t>
           <t>Rob Enns, Juniper Networks</t>
           <t>Ted Goddard, IceSoft</t>
           <t>Eliot Lear, Cisco Systems</t>
           <t>Phil Shafer, Juniper Networks</t>
           <t>Steve Waldbusser</t>
           <t>Margaret Wasserman, ThingMagic</t>
         </list>
       </t>
       <t>
The authors would like to acknowledge the members of the NETCONF
working group.  In particular, we would like to thank Wes Hardaker
for his persistance and patience in assisting us with security
considerations.  We would also like to thank Randy Presuhn, Sharon
Chisolm, Juergen Schoenwalder, Glenn Waters, David Perkins, Weijing
Chen, Simon Leinen, Keith Allen and Dave Harrington for all of
their valuable advice.
       </t>
     </section>
   </middle>
   <back>
     <references title="Normative References">
       <?rfc include="reference.W3C.REC-xml-20001006" ?> <!-- XML spec -->
       <?rfc include="reference.W3C.REC-xpath-19991116" ?> <!-- XPath spec -->
       <?rfc include="reference.RFC.2119" ?> <!--  -->
       <?rfc include="reference.I-D.ietf-netconf-ssh" ?> <!-- NETCONF/SSH -->
       <?rfc include="reference.RFC.1630" ?> <!-- URI -->
       <?rfc include="reference.RFC.2141" ?> <!-- URN -->
       <?rfc include="reference.RFC.3553" ?> <!-- URNs for protocol params -->
       <?rfc include="reference.RFC.3688" ?> <!-- IETF XML registry -->
     </references>
     <references title="Informative References">
       <?rfc include="reference.W3C.REC-xslt-19991116" ?> <!-- XSLT spec -->
       <?rfc include="reference.RFC.2246" ?> <!-- TLS -->
       <?rfc include="reference.I-D.ietf-secsh-architecture" ?> <!-- SSH -->
       <?rfc include="reference.RFC.2865" ?> <!-- RADIUS -->
       <?rfc include="reference.RFC.3470" ?> <!-- XML use in IETF -->
     </references>
     <section title="NETCONF Error List" anchor="errorList">
           <figure>
             <artwork><![CDATA[
Tag:         in-use
Error-type:  protocol, application
Severity:    error
Error-info:  none
Description: The request requires a resource that already in use.

Tag:         invalid-value
Error-type:  protocol, application
Severity:    error
Error-info:  none
Description: The request specifies an unacceptable value for one
             or more parameters.

Tag:         too-big
Error-type:  transport, rpc, protocol, application
Severity:    error
Error-info:  none
Description: The request or response (that would be generated) is too 
             large for the implementation to handle.

Tag:         missing-attribute
Error-type:  rpc, protocol, application
Severity:    error
Error-info:  <bad-attribute> : name of the missing attribute
             <bad-element> : name of the element that should
             contain the missing attribute
Description: An expected attribute is missing

Tag:         bad-attribute
Error-type:  rpc, protocol, application
Severity:    error
Error-info:  <bad-attribute> : name of the attribute w/ bad value
             <bad-element> : name of the element that contains
             the attribute with the bad value
Description: An attribute value is not correct; e.g., wrong type,
             out of range, pattern mismatch

Tag:         unknown-attribute
Error-type:  rpc, protocol, application
Severity:    error
Error-info:  <bad-attribute> : name of the unexpected attribute
             <bad-element> : name of the element that contains
             the unexpected attribute
Description: An unexpected attribute is present

Tag:         missing-element
Error-type:  rpc, protocol, application
Severity:    error
Error-info:  <bad-element> : name of the missing element
Description: An expected element is missing

Tag:         bad-element
Error-type:  rpc, protocol, application
Severity:    error
Error-info:  <bad-element> : name of the element w/ bad value
Description: An element value is not correct; e.g., wrong type,
             out of range, pattern mismatch

Tag:         unknown-element
Error-type:  rpc, protocol, application
Severity:    error
Error-info:  <bad-element> : name of the unexpected element
Description: An unexpected element is present

Tag:         unknown-namespace
Error-type:  rpc, protocol, application
Severity:    error
Error-info:  Name of the unexpected namespace
Description: An unexpected namespace is present

Tag:         access-denied
Error-type:  rpc, protocol, application
Severity:    error
Error-info:  none
Description: Access to the requested RPC, protocol operation,
             or application data model is denied because
             authorization failed

Tag:         lock-denied
Error-type:  protocol
Severity:    error
Error-info:  <session-id> : session ID of session holding the
             requested lock, or zero to indicate a non-NETCONF
             entity holds the lock
Description: Access to the requested lock is denied because the
             lock is currently held by another entity

Tag:         resource-denied
Error-type:  transport, rpc, protocol, application
Severity:    error
Error-info:  none
Description: Request could not be completed because of insufficient
             resources

Tag:         rollback-failed
Error-type:  protocol, application
Severity:    error
Error-info:  none
Description: Request to rollback some configuration change (via 
             rollback-on-error or discard-changes operations) was
             not completed for some reason. 

Tag:         data-exists
Error-type:  application
Severity:    error
Error-info:  none
Description: Request could not be completed because the relevant
             data model content already exists. For example, 
             a 'create' operation was attempted on data which
             already exists.

Tag:         data-missing
Error-type:  application
Severity:    error
Error-info:  none
Description: Request could not be completed because the relevant
             data model content does not exist.  For example,
             a 'modify' or 'delete' operation was attempted on 
             data which does not exist.
             
Tag:         operation-not-supported
Error-type:  rpc, protocol, application
Severity:    error
Error-info:  none
Description: Request could not be completed because the requested
             operation is not supported by this implementation.

Tag:         operation-failed
Error-type:  rpc, protocol, application
Severity:    error
Error-info:  none
Description: Request could not be completed because the requested
             operation failed for some reason not covered by 
             any other error condition.

Tag:         partial-operation
Error-type:  application
Severity:    error
Error-info:  <ok-element> : identifies an element in the data model
             for which the requested operation has been completed
             for that node and all its child nodes.  This element
             can appear zero or more times in the <error-info>
             container.

             <err-element> : identifies an element in the data model
             for which the requested operation has failed for that 
             node and all its child nodes. This element
             can appear zero or more times in the <error-info>
             container.

             <noop-element> : identifies an element in the data model
             for which the requested operation was not attempted for 
             that node and all its child nodes. This element
             can appear zero or more times in the <error-info>
             container.

Description: Some part of the requested operation failed or was
             not attempted for some reason.  Full cleanup has 
             not been performed (e.g., rollback not supported)
             by the server.  The error-info container is used
             to identify which portions of the application
             data model content for which the requested operation 
             has succeeded (<ok-element>), failed (<bad-element>),
             or not attempted (<noop-element>).
               ]]></artwork>
           </figure>
     </section>
     <section title="XML Schema for NETCONF RPC and Protocol Operations" anchor="protocolSchema">
       <t>
         <figure>
           <artwork><![CDATA[
BEGIN

<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
           targetNamespace="urn:ietf:params:xml:ns:netconf:base:1.0"
           elementFormDefault="qualified"
           attributeFormDefault="unqualified"
           xml:lang="en">
  <!--
    import standard XML definitions
    -->
  <xs:import namespace="http://www.w3.org/XML/1998/namespace"
             schemaLocation="http://www.w3.org/2001/xml.xsd">
    <xs:annotation>
      <xs:documentation>
        This import accesses the xml: attribute groups for the
        xml:lang as declared on the error-message element.
      </xs:documentation>
    </xs:annotation>
  </xs:import>
  <!--
    <rpc> element
    -->
  <xs:complexType name="rpcType">
    <xs:sequence>
      <xs:element ref="rpcOperation"/>
    </xs:sequence>
    <xs:attribute name="message-id" type="xs:string" use="required"/>
    <!--
      Arbitrary attributes can be supplied with <rpc> element.
    -->
    <xs:anyAttribute processContents="lax"/>
  </xs:complexType>
  <xs:element name="rpc" type="rpcType"/>
  <!--
    data types and elements used to construct rpc-errors
    -->
  <xs:simpleType name="SessionId">
    <xs:restriction base="xs:unsignedInt"/>
  </xs:simpleType>
  <xs:simpleType name="ErrorType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="transport"/>
      <xs:enumeration value="rpc"/>
      <xs:enumeration value="protocol"/>
      <xs:enumeration value="application"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ErrorTag">
    <xs:restriction base="xs:string">
      <xs:enumeration value="in-use"/>
      <xs:enumeration value="invalid-value"/>
      <xs:enumeration value="too-big"/>
      <xs:enumeration value="missing-attribute"/>
      <xs:enumeration value="bad-attribute"/>
      <xs:enumeration value="unknown-attribute"/>
      <xs:enumeration value="missing-element"/>
      <xs:enumeration value="bad-element"/>
      <xs:enumeration value="unknown-element"/>
      <xs:enumeration value="unknown-namespace"/>
      <xs:enumeration value="access-denied"/>
      <xs:enumeration value="lock-denied"/>
      <xs:enumeration value="resource-denied"/>
      <xs:enumeration value="rollback-failed"/>
      <xs:enumeration value="data-exists"/>
      <xs:enumeration value="data-missing"/>
      <xs:enumeration value="operation-not-supported"/>
      <xs:enumeration value="operation-failed"/>
      <xs:enumeration value="partial-operation"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ErrorSeverity">
    <xs:restriction base="xs:string">
      <xs:enumeration value="error"/>
      <xs:enumeration value="warning"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:group name="errorInfoContent">
    <xs:sequence>
      <xs:element name="bad-attribute" type="xs:QName"
        minOccurs="0" maxOccurs="1"/>
      <xs:element name="bad-element" type="xs:QName"
        minOccurs="0" maxOccurs="1"/>
      <xs:element name="ok-element" type="xs:QName"
        minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="err-element" type="xs:QName"
        minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="noop-element" type="xs:QName"
        minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="session-id" type="SessionId"
        minOccurs="0" maxOccurs="1"/>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="rpcErrorType">
    <xs:sequence>
      <xs:element name="error-type" type="ErrorType"/>
      <xs:element name="error-tag" type="ErrorTag"/>
      <xs:element name="error-severity" type="ErrorSeverity"/>
      <xs:element name="error-app-tag" type="xs:string"
                  minOccurs="0"/>
      <xs:element name="error-path" type="xs:string" minOccurs="0"/>
      <xs:element name="error-message" minOccurs="0">
        <xs:complexType>
          <xs:simpleContent>
            <xs:extension base="xs:string">
              <xs:attribute ref="xml:lang" use="optional"/>
            </xs:extension>
          </xs:simpleContent>
        </xs:complexType>
      </xs:element>
      <!-- <error-info> can be any type -->
      <xs:element name="error-info" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <!--
    <rpc-reply> element
    -->
  <xs:complexType name="rpcReplyType">
    <xs:choice>
      <xs:element name="ok"/>
      <xs:group ref="rpcResponse"/>
    </xs:choice>
    <xs:attribute name="message-id" type="xs:string" use="optional"/>
    <!--
      Any attributes supplied with <rpc> element must be returned
      on <rpc-reply>.
    -->
    <xs:anyAttribute processContents="lax"/>
  </xs:complexType>
  <xs:group name="rpcResponse">
    <xs:sequence>
      <xs:element name="rpc-error" type="rpcErrorType"
        minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="data" type="dataInlineType" minOccurs="0"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="rpc-reply" type="rpcReplyType"/>
  <!--
    Type for <test-option> parameter to <edit-config>
    -->
  <xs:simpleType name="testOptionType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="test-then-set"/>
      <xs:enumeration value="set"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    Type for <error-option> parameter to <edit-config>
    -->
  <xs:simpleType name="errorOptionType">
    <xs:restriction base="xs:string">
      <xs:annotation>
        <xs:documentation>
          Use of the rollback-on-error value requires
          the :rollback-on-error capability.
        </xs:documentation>
      </xs:annotation>
      <xs:enumeration value="stop-on-error"/>
      <xs:enumeration value="ignore-error"/>
      <xs:enumeration value="rollback-on-error"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    rpcOperationType: used as a base type for all
    NETCONF operations
    -->
  <xs:complexType name="rpcOperationType"/>
  <xs:element name="rpcOperation"
              type="rpcOperationType" abstract="true"/>
  <!--
    Type for <config> element
    -->
  <xs:complexType name="configInlineType">
    <xs:complexContent>
      <xs:extension base="xs:anyType"/>
    </xs:complexContent>
  </xs:complexType>
  <!--
    Type for <data> element
    -->
  <xs:complexType name="dataInlineType">
    <xs:complexContent>
      <xs:extension base="xs:anyType"/>
    </xs:complexContent>
  </xs:complexType>
  <!--
    Type for <filter> element
    -->
  <xs:simpleType name="FilterType">
    <xs:restriction base="xs:string">
      <xs:annotation>
        <xs:documentation>
          Use of the xpath value requires the :xpath capability.
       </xs:documentation>
      </xs:annotation>
      <xs:enumeration value="subtree"/>
      <xs:enumeration value="xpath"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="filterInlineType">
    <xs:complexContent>
      <xs:extension base="xs:anyType">
        <xs:attribute name="type"
                      type="FilterType" default="subtree"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <!--
    configuration datastore names
    -->
  <xs:annotation>
    <xs:documentation>
      The startup datastore can be used only if the :startup
      capability is advertised. The candidate datastore can
      be used only if the :candidate datastore is advertised.
     </xs:documentation>
  </xs:annotation>
  <xs:complexType name="configNameType"/>
  <xs:element name="config-name"
              type="configNameType" abstract="true"/>
  <xs:element name="startup" type="configNameType"
              substitutionGroup="config-name"/>
  <xs:element name="candidate" type="configNameType"
              substitutionGroup="config-name"/>
  <xs:element name="running" type="configNameType"
              substitutionGroup="config-name"/>
  <!--
    operation attribute used in <edit-config>
    -->
  <xs:simpleType name="editOperationType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="merge"/>
      <xs:enumeration value="replace"/>
      <xs:enumeration value="create"/>
      <xs:enumeration value="delete"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:attribute name="operation"
                type="editOperationType" default="merge"/>
  <!--
    <default-operation> element
    -->
  <xs:simpleType name="defaultOperationType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="merge"/>
      <xs:enumeration value="replace"/>
      <xs:enumeration value="none"/>
    </xs:restriction>
  </xs:simpleType>
  <!--
    <url> element
    -->
  <xs:complexType name="configURIType">
    <xs:annotation>
      <xs:documentation>
        Use of the url element requires the :url capability.
      </xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:anyURI"/>
    </xs:simpleContent>
  </xs:complexType>
  <!--
    Type for <source> element (except <get-config>)
    -->
  <xs:complexType name="rpcOperationSourceType">
    <xs:choice>
      <xs:element name="config" type="configInlineType"/>
      <xs:element ref="config-name"/>
      <xs:element name="url" type="configURIType"/>
    </xs:choice>
  </xs:complexType>
  <!--
    Type for <source> element in <get-config>
    -->
  <xs:complexType name="getConfigSourceType">
    <xs:choice>
      <xs:element ref="config-name"/>
      <xs:element name="url" type="configURIType"/>
    </xs:choice>
  </xs:complexType>
  <!--
    Type for <target> element 
    -->
  <xs:complexType name="rpcOperationTargetType">
    <xs:choice>
      <xs:element ref="config-name"/>
      <xs:element name="url" type="configURIType"/>
    </xs:choice>
  </xs:complexType>
  <!--
    <get-config> operation
    -->
  <xs:complexType name="getConfigType">
    <xs:complexContent>
      <xs:extension base="rpcOperationType">
        <xs:sequence>
          <xs:element name="source"
                      type="getConfigSourceType"/>
          <xs:element name="filter"
                      type="filterInlineType" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="get-config" type="getConfigType"
              substitutionGroup="rpcOperation"/>
  <!--
    <edit-config> operation
    -->
  <xs:complexType name="editConfigType">
    <xs:complexContent>
      <xs:extension base="rpcOperationType">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation>
              Use of the test-option element requires the
              :validate capability. Use of the url element
              requires the :url capability.
            </xs:documentation>
          </xs:annotation>
          <xs:element name="target"
                      type="rpcOperationTargetType"/>
          <xs:element name="default-operation"
                      type="defaultOperationType"
                      minOccurs="0"/>
          <xs:element name="test-option"
                      type="testOptionType"
                      minOccurs="0"/>
          <xs:element name="error-option"
                      type="errorOptionType"
                      minOccurs="0"/>
          <xs:choice>
            <xs:element name="config"
                        type="configInlineType"/>
            <xs:element name="url"
                        type="configURIType"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="edit-config" type="editConfigType"
              substitutionGroup="rpcOperation"/>
  <!--
    <copy-config> operation
    -->
  <xs:complexType name="copyConfigType">
    <xs:complexContent>
      <xs:extension base="rpcOperationType">
        <xs:sequence>
          <xs:element name="source" type="rpcOperationSourceType"/>
          <xs:element name="target" type="rpcOperationTargetType"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="copy-config" type="copyConfigType"
              substitutionGroup="rpcOperation"/>
  <!--
    <delete-config> operation
    -->
  <xs:complexType name="deleteConfigType">
    <xs:complexContent>
      <xs:extension base="rpcOperationType">
        <xs:sequence>
          <xs:element name="target" type="rpcOperationTargetType"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="delete-config" type="deleteConfigType"
              substitutionGroup="rpcOperation"/>
  <!--
    <get> operation
    -->
  <xs:complexType name="getType">
    <xs:complexContent>
      <xs:extension base="rpcOperationType">
        <xs:sequence>
          <xs:element name="filter"
                      type="filterInlineType" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="get" type="getType"
              substitutionGroup="rpcOperation"/>
  <!--
    <lock> operation
    -->
  <xs:complexType name="lockType">
    <xs:complexContent>
      <xs:extension base="rpcOperationType">
        <xs:sequence>
          <xs:element name="target"
                      type="rpcOperationTargetType"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="lock" type="lockType"
              substitutionGroup="rpcOperation"/>
  <!--
    <unlock> operation
    -->
  <xs:complexType name="unlockType">
    <xs:complexContent>
      <xs:extension base="rpcOperationType">
        <xs:sequence>
          <xs:element name="target" type="rpcOperationTargetType"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="unlock" type="unlockType"
              substitutionGroup="rpcOperation"/>
  <!--
    <validate> operation
    -->
  <xs:complexType name="validateType">
    <xs:annotation>
      <xs:documentation>
        The validate operation requires the :validate capability.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="rpcOperationType">
        <xs:sequence>
          <xs:element name="source" type="rpcOperationSourceType"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="validate" type="validateType"
              substitutionGroup="rpcOperation"/>
  <!--
    <commit> operation
    -->
  <xs:complexType name="commitType">
    <xs:annotation>
      <xs:documentation>
        The commit operation requires the :candidate capability.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="rpcOperationType">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation>
              Use of the confirmed and confirm-timeout elements
              requires the :confirmed-commit capability.
            </xs:documentation>
          </xs:annotation>
          <xs:element name="confirmed" minOccurs="0"/>
          <xs:element name="confirm-timeout"
                      type="xs:positiveInteger"
                      minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="commit" type="commitType"
              substitutionGroup="rpcOperation"/>
  <!--
    <discard-changes> operation
    -->
  <xs:complexType name="discardChangesType">
    <xs:annotation>
      <xs:documentation>
        The discard-changes operation requires the
        :candidate capability.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="rpcOperationType"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="discard-changes"
              type="discardChangesType"
              substitutionGroup="rpcOperation"/>
  <!--
    <close-session> operation
    -->
  <xs:complexType name="closeSessionType">
    <xs:complexContent>
      <xs:extension base="rpcOperationType"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="close-session" type="closeSessionType"
              substitutionGroup="rpcOperation"/>
  <!--
    <kill-session> operation
    -->
  <xs:complexType name="killSessionType">
    <xs:complexContent>
      <xs:extension base="rpcOperationType">
        <xs:sequence>
          <xs:element name="session-id"
                      type="SessionId" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name="kill-session" type="killSessionType"
              substitutionGroup="rpcOperation"/>
  <!--
    <hello> element
    -->
  <xs:element name="hello">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="capabilities">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="capability" type="xs:anyURI"
                maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="session-id"
                    type="SessionId" minOccurs="0"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
</xs:schema>

END
             ]]></artwork>
         </figure>
       </t>
     </section>

     <section title="Capability Template" anchor="capabilityTemplate">
       <section title="capability-name (template)">
         <section title="Overview">
         </section>
         <section title="Dependencies">
         </section>
         <section title="Capability Identifier">
           <t>
             The {name} is identified by following capability string:
             <list style="empty">
               <t>urn:ietf:params:xml:ns:netconf:capability:{name}:1.0</t>
             </list>
           </t>
         </section>
         <section title="New Operations">
           <section title="&lt;op-name&gt;">
           </section>
         </section>
         <section title="Modifications to Existing Operations">
           <section title="&lt;op-name&gt;">
             <t>If existing operations are not modified by this
             capability, this section may be omitted.</t>
           </section>
         </section>
         <section title="Interactions with Other Capabilities">
           <t>If this capability does not interact with other
           capabilities, this section may be omitted.</t>
         </section>
       </section>
     </section>
     <section title="Configuring Multiple Devices with NETCONF" anchor="multidev">
       <section title="Operations on Individual Devices">
         <t>
 Consider the work involved in performing a configuration update
 against a single individual device.  In making a change to the
 configuration, the application needs to build trust that its change
 has been made correctly and that it has not impacted the operation of
 the device. The application (and the application user) should feel
 confident that their change has not damaged the network.
         </t>
         <t>
 Protecting each individual device consists of a number of steps:
           <list style="symbols">
 <t>Acquiring the configuration lock.</t>
 <t>Loading the update.</t>
 <t>Validating the incoming configuration.</t>
 <t>Checkpointing the running configuration.</t>
 <t>Changing the running configuration.</t>
 <t>Testing the new configuration.</t>
 <t>Making the change permanent (if desired).</t>
 <t>Releasing the configuration lock.</t>
           </list>
         </t>
         <t>
 Let's look at the details of each step.
         </t>
         <section title="Acquiring the Configuration Lock">
           <t>
 A lock should be acquired to prevent simultaneous updates from
 multiple sources.  If multiple sources are affecting the device, the
 application is hampered in both testing of its change to the
 configuration and in recovery should the update fail. Acquiring a
 short-lived lock is a simple defense to prevent other parties from
 introducing unrelated changes.
           </t>
           <t>
 The lock can be acquired using the &lt;lock&gt; operation.
             <figure>
               <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <lock>
      <target>
        <running/>
      </target>
    </lock>
  </rpc>
                 ]]></artwork>
             </figure>
           </t>
         </section>
         <section title="Loading the Update">
           <t>
 The configuration can be loaded onto the device without impacting the
 running system. If the :url capability is supported, incoming
 changes can be placed in a local file. 
             <figure>
               <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <copy-config>
      <source>
        <config>
          <!-- place incoming configuration here -->
        </config>
      </source>
      <target>
        <url>file://incoming.conf</url>
      </target>
    </copy-config>
  </rpc>
                 ]]></artwork>
             </figure>
           </t>
           <t>
 If the :candidate capability is supported, the candidate configuration
 can be used.
             <figure>
               <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <candidate/>
      </target>
      <config>
        <!-- place incoming configuration here -->
      </config>
    </edit-config>
  </rpc>
                 ]]></artwork>
             </figure>
           </t>
           <t>
 If the update fails, the user file can be deleted using the
 &lt;delete-config&gt; operation or the candidate configuration reverted
 using the &lt;discard-changes&gt; operation.
           </t>
         </section>
         <section title="Validating the Incoming Configuration">
           <t>
 Before applying the incoming configuration, it is often useful to
 validate it. Validation allows the application to gain confidence that
 the change will succeed and simplifies recovery if it does not.
           </t>
           <t>
 If the device supports the :url capability, use the &lt;validate&gt;
 operation with the &lt;source&gt; parameter set to the proper user file:
             <figure>
               <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <validate>
      <source>
        <url>file://incoming.conf</url>
      </source>
    </validate>
  </rpc>
                 ]]></artwork>
             </figure>
           </t>
           <t>
 If the device supports the :candidate capability, some validation will
 be performed as part of loading the incoming configuration into the
 candidate. For full validation, either pass the &lt;validate&gt; parameter
 during the &lt;edit-config&gt; step given above, or use the &lt;validate&gt;
 operation with the &lt;source&gt; parameter set to &lt;candidate&gt;.
             <figure>
               <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <validate>
      <source>
        <candidate/>
      </source>
    </validate>
  </rpc>
                 ]]></artwork>
             </figure>
           </t>
         </section>
         <section title="Checkpointing the Running Configuration">
           <t>
 The running configuration can be saved into a local file as a
 checkpoint before loading the new configuration. If the update fails,
 the configuration can be restored by reloading the checkpoint file.
           </t>
           <t>
 The checkpoint file can be created using the &lt;copy-config&gt; operation.
             <figure>
               <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <copy-config>
      <source>
        <running/>
      </source>
      <target>
        <url>file://checkpoint.conf</url>
      </target>
    </copy-config>
  </rpc>
                 ]]></artwork>
             </figure>
           </t>
           <t>
 To restore the checkpoint file, reverse the source and target parameters.
           </t>
           </section>
         <section title="Changing the Running Configuration">
           <t>
 When the incoming configuration has been safely loaded onto the device
 and validated, it is ready to impact the running system.
           </t>
           <t>
 If the device supports the :url capability, use the
 &lt;edit-config&gt; operation to merge the incoming configuration into the
 running configuration.
             <figure>
               <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <running/>
      </target>
      <config>
        <url>file://incoming.conf</url>
      </config>
    </edit-config>
  </rpc>
                 ]]></artwork>
             </figure>
           </t>
           <t>
 If the device supports the :candidate capability, use the &lt;commit&gt;
 operation to set the running configuration to the candidate
 configuration. Use the &lt;confirmed&gt; parameter to allow automatic
 reverting to the original configuration if connectivity to the device
 fails.
             <figure>
               <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <commit>
      <confirmed/>
      <confirm-timeout>120</confirm-timeout>
    </commit>
  </rpc>
                 ]]></artwork>
             </figure>
           </t>
         </section>
         <section title="Testing the New Configuration">
           <t>
 Now that the incoming configuration has been integrated into the
 running configuration, the application needs to gain trust that the
 change has affected the device in the way intended without affecting
 it negatively.
           </t>
           <t>
 To gain this confidence, the application can run tests of the
 operational state of the device. The nature of the test is dependent
 on the nature of the change and is outside the scope of this
 document. Such tests may include reachability from the system running
 the application (using ping), changes in reachability to the rest of the
 network (by comparing the device's routing table), or inspection of
 the particular change (looking for operational evidence of the BGP
 peer that was just added).
           </t>
         </section>
         <section title="Making the Change Permanent">
           <t>
 When the configuration change is in place and the application has
 sufficient faith in the proper function of this change, the
 application should make the change permanent.
           </t>
           <t>
 If the device supports the :startup capability, the current
 configuration can be saved to the startup configuration by using the
 startup configuration as the target of the &lt;copy-config&gt; operation.
             <figure>
               <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <copy-config>
      <source>
        <running/>
      </source>
      <target>
        <startup/>
      </target>
    </copy-config>
  </rpc>
                 ]]></artwork>
             </figure>
           </t>
           <t>
 If the device supports the :candidate capability and a confirmed
 commit was requested, the confirming commit must be sent before the
 timeout expires.
             <figure>
               <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <commit/>
  </rpc>
                 ]]></artwork>
             </figure>
           </t>
         </section>
         <section title="Releasing the Configuration Lock">
           <t>
 When the configuration update is complete, the lock must be
 released, allowing other applications access to the configuration.
           </t>
           <t>
 Use the &lt;unlock&gt; operation to release the configuration lock.
             <figure>
               <artwork><![CDATA[
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <unlock>
      <target>
        <running/>
      </target>
    </unlock>
  </rpc>
                 ]]></artwork>
             </figure>
           </t>
         </section>
       </section>
       <section title="Operations on Multiple Devices">
         <t>
 When a configuration change requires updates across a number of
 devices, care should be taken to provide the required transaction
 semantics. The NETCONF protocol contains sufficient primitives upon
 which transaction-oriented operations can be built.
 Providing complete transactional semantics across multiple
 devices is prohibitively expensive, but the size and number of windows
 for failure scenarios can be reduced.
         </t>
         <t>
 There are two classes of multidevice operations.  The first class
 allows the operation to fail on individual
 devices without requiring all devices to revert to their original
 state. The operation can be retried at a later time, or its failure
 simply reported to the user. A example of this class might be adding
 an NTP server. For this class of operations, failure avoidance and
 recovery are focused on the individual device. This means recovery of
 the device, reporting the failure, and perhaps scheduling another
 attempt.
         </t>
         <t>
 The second class is more interesting, requiring that the
 operation should complete on all devices or be fully reversed. The
 network should either be transformed into a new state or be reset to
 its original state. For example, a change to a VPN may require updates
 to a number of devices.  Another example of this might be adding a
 class-of-service definition. Leaving the network in a state
 where only a portion of the devices have been updated with the new
 definition will lead to future failures when the definition is
 referenced.
         </t>
         <t>
 To give transactional semantics, the same steps used in single device
 operations listed above are used, but are performed in parallel across
 all devices. Configuration locks should be acquired on all target
 devices and kept until all devices are updated and the changes made
 permanent.  Configuration changes should be uploaded and validation
 performed across all devices.  Checkpoints should be made on each
 device.  Then the running configuration can be changed, tested, and
 made permanent. If any of these steps fail, the previous
 configurations can be restored on any devices upon which it was
 changed. After the changes have been completely implemented or
 completely discarded, the locks on each device can be released.
         </t>
       </section>
     </section>
     <section title="Deferred Features">
       <t>
         The following features have been deferred until a future revision
         of this document.
       </t>
       <list style="symbols">
         <t>Granular locking of configuration objects.</t>
         <t>Named configuration files/datastores.</t>
         <t>Support for multiple NETCONF channels.</t>
         <t>Asynchronous notifications.</t>
         <t>Explicit protocol support for rollback of configuration
         changes to prior versions.</t>
       </list>
     </section>
     <section title="Change Log">
       <t>RFC Editor: Please remove this section before RFC publication.
       </t>
       <section title="draft-ietf-netconf-prot-09">
         <list style="symbols">
           <t>Minor spelling and grammar corrections.</t>
           <t>Add a table enumerating all capability identifiers to
           IANA considerations.</t>
           <t>Clarify that &lt;kill-session&gt; does in fact roll back
           changes if received during a confirmed commit.</t>
           <t>In IANA considerations, request
           ...:netconf:base:1.0 as the NETCONF namespace.</t>
         </list>
       </section>
       <section title="draft-ietf-netconf-prot-08">
         <list style="symbols">
           <t>Second &lt;rpc-error&gt; example was missing message-id attribute.</t>
           <t>Fix namespace in section <xref target="attribute-match"/>.</t>
           <t>Fix namespaces in examples in sections 6.4.8 and 7.7.</t>
           <t>Edit <xref target="containment-nodes"/> for clarification.</t>
           <t>Change "committed" to "running" in <xref target="discard-changes"/>.</t>
           <t>Convert example addresses to use the range 192.0.2.0/24.</t>
           <t>Clarify optional support of &lt;running/&gt; as target
           of &lt;copy-config&gt;.</t>
           <t>Clarify that &lt;kill-session&gt; does not restore
           configuration or device state.</t>
           <t>Clarify that both client and server must send a &lt;hello&gt;
           element with capabilities.</t>
           <t>NETCONF over SSH is mandatory.</t>
           <t>Add IANA considerations.</t>
           <t>Add BEGIN/END markers to NETCONF XML schema per RFC 3688.</t>
           <t>NETCONF capability URNs should be in the protocol parameters
           namespace as described in RFC 3553.</t>
         </list>
       </section>
       <section title="draft-ietf-netconf-prot-07">
         <list style="symbols">
           <t>Add clarifying text to :confirmed-commit capability.</t>
           <t>Change units of 'confirm-timeout' parameter to seconds.</t>
           <t>Type confirm-timeout element as a positiveInteger in the XSD.</t>
           <t>Update XSD to allow &lt;url&gt; element in &lt;edit-config&gt;
           as required by :url capability.</t>
           <t>Denote attribute names with single quotes in the text;
           some cases were missed.</t>
					 <t>Update &lt;rpc-error&gt; to state that the server must
					 not return data that the client has no access rights on.</t>
					 <t>[XMLDir] Moderate use of the term API.</t>
					 <t>[XMLDir] Clarify capability naming requirements in
					 <xref target="namespace"/>.</t>
					 <t>[XMLDir] Remove "DTD" acronym from <xref target="nodtd"/>.</t>
           <t>[XMLDir] Remove # naming scheme from capability URNs.</t>
					 <t>Error code when a lock is in use is 'lock-denied'.</t>
         </list>
       </section>
       <section title="draft-ietf-netconf-prot-06">
         <list style="symbols">
           <t>Allow an xml:lang attribute in the &lt;error-message&gt; tag.</t>
           <t>Update XSD to permit artibrary attributes on &lt;rpc&gt;
           and &lt;rpc-reply&gt;.</t>
           <t>Add example showing retrieval of textual configuration
           to &lt;get-config&gt;.</t>
           <t>Indicate that URLs passed to &lt;edit-config&gt; should be local.</t>
           <t>Update &lt;copy-config&gt; example to use https.</t>
           <t>Update &lt;rpc-error&gt; description to explicitly allow
           multiple &lt;rpc-error&gt; elements. Add example. Update XSD.</t>
           <t>Incorporate clarifying text on subtree filtering.</t>
           <t>Annotate XSD with capability information.</t>
           <t>Make error tags lower case separated with dashes.</t>
           <t>Add unknown-namespace error tag.</t>
           <t>Add text expliticly stating that a server must discontinue
           the NETCONF session if it receives a &lt;session-id&gt; element,
           and similarly a client must discontinue if it does not receive one.</t>
         </list>
       </section>
       <section title="draft-ietf-netconf-prot-05">
         <list style="symbols">
           <t>Change XPATH to XPath.</t>
           <t>Fix I-D nits (mostly long lines).</t>
           <t>Remove "--" from XSD comments.</t>
           <t>Add &lt;source&gt; attribute where it was missing
           in &lt;get-config&gt; examples.</t>
           <t>Clarified <xref target="capabilityExchange" /> by
           indicating that each peer MUST send a &lt;hello&gt;
           element at session startup.</t>
           <t>Typo propriety -> proprietary in <xref target="capabilities" />.</t>
           <t>Fix some bugs in examples.</t>
           <t><xref target="get-config" />: typo: change &lt;config&gt;
           to &lt;data&gt; in the positive response section.</t>
           <t><xref target="get-config" />: If &lt;filter&gt; is
           unspecified, the entire configuration is returned.
           If it is empty, nothing is returned.</t>
           <t>Be explicit about &lt;commit&gt; being atomic.</t>
           <t>s/MAY/SHOULD/ wrt supporting more than one NETCONF session.</t>
           <t>Strengthen language to say that NETCONF requests MUST
           be processed serially.</t>
           <t>Fix misspelling of "unbeknownst."</t>
           <t>Change "Expect scripts" to "CLI scripts" in
           <xref target="lock" />.</t>
           <t>Change "system software" to "device" in <xref target="state" />.</t>
           <t>The &lt;hello&gt; element must also include the
           session ID (issue I002).</t>
           <t>Address all accepted clarifications from working group last call.
           See the NETCONF mailing list for details.</t>
           <t>Address all closed issues from working group last call.
           See the NETCONF mailing list for details.</t>
         </list>
       </section>
       <section title="draft-ietf-netconf-prot-04">
         <t>
           Refer to the NETCONF issue list for futher detail on the
           issue numbers below. The issue list is found at
           http://www.nextbeacon.com/netconf/.
         </t>
         <list style="symbols">
           <t>Update security considerations (action from IETF 60).</t>
           <t>Add type attribute on filter element (issue 14.1).</t>
           <t>Add #xpath capability (issue 14.1).</t>
           <t>&lt;rpc-reply&gt; for &lt;get-config&gt; returns
           &lt;data&gt; element, not &lt;config&gt; element
           (issue 14.1).</t>
           <t>Add detailed description of subtree filtering (issue 14.1.2).</t>
           <t>Typo: change confirmed-timeout -> confirm-timeout in XSD.</t>
           <t>Typo: correct misnaming of test-option parameter in text
           for the validate capability.</t>
           <t>&lt;target&gt; is now a mandatory parameter for &lt;lock&gt;
           and &lt;unlock&gt;. There is no default target (action
           from IETF 60).</t>
           <t>Remove XML schema for NETCONF state data (action from IETF 60).</t>
           <t>Correct namespace handling a number of examples.
           The fix is to put the device's configuration under a top level tag
           called &lt;top&gt; which is in the device's namespace.</t>
           <t>Use message-id 101 everywhere.</t>
           <t>Add default-operation parameter to &lt;edit-config&gt; 
           (action from IETF 60).</t>
           <t>Fix &lt;edit-config&gt; examples in <xref target="multidev"/>.</t>
           <t>Update and reformat protocol XSD.</t>
           <t>Remove XML usage guidelines. Add a section on XML considerations
           covering the NETCONF namespace and no DTD restriction (action
           from IETF 60).</t>
         </list>
       </section>
       <section title="draft-ietf-netconf-prot-03">
         <t>
           Refer to the NETCONF issue list for futher detail on the
           issue numbers below. The issue list is found at
           http://www.nextbeacon.com/netconf/.
         </t>
         <t>
           <list style="symbols">
             <t>Consistent naming of &lt;confirm-timeout&gt; element.</t>
             <t>Add #confirmed-commit capability (issue 10.3.2)</t>
            <t>Use a URN for the NETCONF namespace (issue 11.1.2) and capabilities</t>
            <t>Remove #manager capability (issue 11.2.1)</t>
            <t>Remove #agent capability (issue 11.2.2)</t>
            <t>Add "create" as a value for the operation attribute
            in &lt;edit-config&gt; (issue 13.3.1)</t>
            <t>Add #rollback-on-error capability (issue 13.3.2)</t>
            <t>Rename &lt;get-all&gt; operation to &lt;get&gt;.</t>
            <t>Remove format parameter from two &lt;get-config&gt;
            and one &lt;get&gt; examples missed in the 
            -02 draft (issue 13.3.3).</t>
            <t>Add text indicating that the session-id is returned if the
            lock is already held (issue 13.12.3). Add example of this.</t>
            <t>Remove &lt;discard-changes&gt; parameter on the &lt;lock&gt;
            operation (issue 13.16.1), all outstanding changes are to be
            discarded when the candidate configuration is unlocked.</t>
            <t>Remove section 8.7, guidelines on namespace construction.</t>
            <t>Add clarifying text regarding locks held by other entities.</t>
            <t>Update the abstract.</t>
            <t>Remove mention of the format parameter from the &lt;get-config&gt;
            and &lt;get&gt; operations and the XSD.</t>
            <t>Updated security considerations section.</t>
            <t>Removed terminology section, moved session description to protocol overview section.</t>
            <t>New text describing &lt;rpc-error&gt;.</t>
            <t>Updated NETCONF protocol schema (to reflect new &lt;rpc-error&gt; details, among other things).</t>
            <t>
              Add &lt;filter&gt; parameter to &lt;get&gt; and &lt;get-config&gt;.
              Rename &lt;state&gt; response the &lt;get&gt; operation to &lt;data&gt;.
            </t>
            <t>Better description of the &lt;kill-session&gt; operation.</t>
            <t>Add &lt;close-session&gt; operation.</t>
            <t>Removed format parameter to &lt;copy-config&gt;.</t>
            <t>Removed restriction that a changed &lt;candidate/&gt;
            configuration datastore can't be locked.</t>
            <t>Add note in section 2 that the application protocol must
            provide an indication of session type (manager or agent)
            to the NETCONF layer.</t>
          </list>
        </t>
      </section>
      <section title="draft-ietf-netconf-prot-02">
        <t>
          Refer to the NETCONF issue list for futher detail on the
          issue numbers below. The issue list is found at
          http://www.nextbeacon.com/netconf/.
        </t>
        <t>
          <list style="symbols">
            <t>Remove &lt;rpc-abort&gt;, &lt;rpc-abort-reply&gt;,
              and &lt;rpc-progress&gt; (issues 12.1, 12.2, 12.3).</t>
            <t>Remove channels (issues 3.*).</t>
            <t>Remove notifications (issues 2.*, 4.2, 13.9, 13.10, 13.11).</t>
            <t>Move version number to last component of the capability URI
            (issue 11.1.1).</t>
            <t>Remove format parameter from &lt;get-config&gt; (issue 13.3.3).</t>
            <t>Remove mention of #lock capability from <xref
            target="multidev"/>. Locking is a mandatory NETCONF operation.</t>
            <t>Added text indicating that attributes received in
            &lt;rpc&gt; should be echoed on &lt;rpc-reply&gt; (issue 16.1).</t>
            <t>Reworded Section 7.3 to encourage always
            prefixing attributes with namespaces.</t>
          </list>
        </t>
      </section>
    </section>
  </back>
</rfc>
<!-- Local Variables: -->
<!-- tab-width: 2 -->
<!-- End: -->
