// Code generated by protoc-gen-yang(*.c) DO NOT EDIT.

/*****************************************************************************************************
 * Copyright (C) 2017-2022 by Intrising
 *  - ian0113@intrising.com.tw
 * 
 * Generated by protoc-gen-yang@gen-yang
 * 
 *****************************************************************************************************/

#include <libxml/xmlstring.h>
#include "agt.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "procdefs.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"

#include "intri-stp@2022-06-24.h"
#include "../../../../../../../../.libintrishare/libintrishare.h"

#include "../../../../../../genc-trans/github.com/Intrising/intri-type/core/stp/intri-stp-trans.h"
#include "../../../../../../genc-trans/github.com/Intrising/intri-type/device/intri-device-trans.h"
#include "../../../../../../genc-trans/github.com/golang/protobuf/ptypes/empty/intri-empty-trans.h"

static ncx_module_t *intri_stp_mod;

static status_t intri_stp_MSTP_GetConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct stppb_MSTPConfig *out = malloc(sizeof(*out));

  stp_MSTP_GetConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_MSTPConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_MSTPConfig *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  stp_MSTP_GetConfig(out, in);
  res = build_to_priv_stp_MSTPConfig(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetCistConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_CISTEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_stp_CISTEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetCistConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetMstiConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_MSTIList *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_stp_MSTIList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetMstiConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetCistStatus_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct stppb_CISTStatus *out = malloc(sizeof(*out));

  stp_MSTP_GetCistStatus(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_CISTStatus(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetMstiStatus_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct stppb_MSTIStatus *out = malloc(sizeof(*out));

  stp_MSTP_GetMstiStatus(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_MSTIStatus(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_RunReconfigPortState_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  stp_MSTP_RunReconfigPortState(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetBridgeConfigMode_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct stppb_BridgeConfigMode *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigMode(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_BridgeConfigMode(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetBridgeConfigMode_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_BridgeConfigMode *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigMode(out, in);
  res = build_to_priv_stp_BridgeConfigMode(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetBridgeConfigMode(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetBridgeConfigPriority_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct stppb_BridgeConfigPriority *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigPriority(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_BridgeConfigPriority(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetBridgeConfigPriority_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_BridgeConfigPriority *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigPriority(out, in);
  res = build_to_priv_stp_BridgeConfigPriority(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetBridgeConfigPriority(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetBridgeConfigHelloTime_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct stppb_BridgeConfigHelloTime *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigHelloTime(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_BridgeConfigHelloTime(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetBridgeConfigHelloTime_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_BridgeConfigHelloTime *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigHelloTime(out, in);
  res = build_to_priv_stp_BridgeConfigHelloTime(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetBridgeConfigHelloTime(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetBridgeConfigMaxAge_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct stppb_BridgeConfigMaxAge *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigMaxAge(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_BridgeConfigMaxAge(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetBridgeConfigMaxAge_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_BridgeConfigMaxAge *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigMaxAge(out, in);
  res = build_to_priv_stp_BridgeConfigMaxAge(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetBridgeConfigMaxAge(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetBridgeConfigForwardDelay_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct stppb_BridgeConfigForwardDelay *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigForwardDelay(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_BridgeConfigForwardDelay(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetBridgeConfigForwardDelay_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_BridgeConfigForwardDelay *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigForwardDelay(out, in);
  res = build_to_priv_stp_BridgeConfigForwardDelay(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetBridgeConfigForwardDelay(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetBridgeConfigTxHoldCount_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct stppb_BridgeConfigTxHoldCount *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigTxHoldCount(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_BridgeConfigTxHoldCount(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetBridgeConfigTxHoldCount_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_BridgeConfigTxHoldCount *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigTxHoldCount(out, in);
  res = build_to_priv_stp_BridgeConfigTxHoldCount(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetBridgeConfigTxHoldCount(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetBridgeConfigMSTPRegionName_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct stppb_BridgeConfigMSTPRegionName *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigMSTPRegionName(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_BridgeConfigMSTPRegionName(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetBridgeConfigMSTPRegionName_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_BridgeConfigMSTPRegionName *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigMSTPRegionName(out, in);
  res = build_to_priv_stp_BridgeConfigMSTPRegionName(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetBridgeConfigMSTPRegionName(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetBridgeConfigMSTPRevisionLevel_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct stppb_BridgeConfigMSTPRevisionLevel *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigMSTPRevisionLevel(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_BridgeConfigMSTPRevisionLevel(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetBridgeConfigMSTPRevisionLevel_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_BridgeConfigMSTPRevisionLevel *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigMSTPRevisionLevel(out, in);
  res = build_to_priv_stp_BridgeConfigMSTPRevisionLevel(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetBridgeConfigMSTPRevisionLevel(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetBridgeConfigMSTPMaxHops_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct stppb_BridgeConfigMSTPMaxHops *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigMSTPMaxHops(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_BridgeConfigMSTPMaxHops(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetBridgeConfigMSTPMaxHops_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_BridgeConfigMSTPMaxHops *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  stp_MSTP_GetBridgeConfigMSTPMaxHops(out, in);
  res = build_to_priv_stp_BridgeConfigMSTPMaxHops(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetBridgeConfigMSTPMaxHops(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetPortConfigEnabled_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct devicepb_PortList *in = malloc(sizeof(*in));
  struct stppb_STPPortConfigEnabled *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_device_PortList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_GetPortConfigEnabled(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_STPPortConfigEnabled(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetPortConfigEnabled_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_STPPortConfigEnabled *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_stp_STPPortConfigEnabled(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetPortConfigEnabled(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetPortConfigPriority_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct devicepb_PortList *in = malloc(sizeof(*in));
  struct stppb_STPPortConfigPriority *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_device_PortList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_GetPortConfigPriority(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_STPPortConfigPriority(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetPortConfigPriority_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_STPPortConfigPriority *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_stp_STPPortConfigPriority(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetPortConfigPriority(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetPortConfigAdminP2PPort_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct devicepb_PortList *in = malloc(sizeof(*in));
  struct stppb_STPPortConfigAdminP2PPort *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_device_PortList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_GetPortConfigAdminP2PPort(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_STPPortConfigAdminP2PPort(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetPortConfigAdminP2PPort_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_STPPortConfigAdminP2PPort *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_stp_STPPortConfigAdminP2PPort(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetPortConfigAdminP2PPort(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetPortConfigAdminEdgePort_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct devicepb_PortList *in = malloc(sizeof(*in));
  struct stppb_STPPortConfigAdminEdgePort *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_device_PortList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_GetPortConfigAdminEdgePort(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_STPPortConfigAdminEdgePort(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetPortConfigAdminEdgePort_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_STPPortConfigAdminEdgePort *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_stp_STPPortConfigAdminEdgePort(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetPortConfigAdminEdgePort(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetPortConfigAdminPathCost_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct devicepb_PortList *in = malloc(sizeof(*in));
  struct stppb_STPPortConfigAdminPathCost *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_device_PortList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_GetPortConfigAdminPathCost(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_STPPortConfigAdminPathCost(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetPortConfigAdminPathCost_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_STPPortConfigAdminPathCost *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_stp_STPPortConfigAdminPathCost(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetPortConfigAdminPathCost(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetPortConfigMSTPDefaultPriority_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct devicepb_PortList *in = malloc(sizeof(*in));
  struct stppb_STPPortConfigMSTPDefaultPriority *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_device_PortList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_GetPortConfigMSTPDefaultPriority(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_STPPortConfigMSTPDefaultPriority(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetPortConfigMSTPDefaultPriority_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_STPPortConfigMSTPDefaultPriority *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_stp_STPPortConfigMSTPDefaultPriority(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetPortConfigMSTPDefaultPriority(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetPortConfigMSTPPortPriority_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct devicepb_PortList *in = malloc(sizeof(*in));
  struct stppb_STPPortConfigMSTPPortPriority *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_device_PortList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_GetPortConfigMSTPPortPriority(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_STPPortConfigMSTPPortPriority(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetPortConfigMSTPPortPriority_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_STPPortConfigMSTPPortPriority *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_stp_STPPortConfigMSTPPortPriority(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetPortConfigMSTPPortPriority(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetPortConfigMSTPDefaultAdminPathCost_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct devicepb_PortList *in = malloc(sizeof(*in));
  struct stppb_STPPortConfigMSTPDefaultAdminPathCost *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_device_PortList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_GetPortConfigMSTPDefaultAdminPathCost(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_STPPortConfigMSTPDefaultAdminPathCost(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetPortConfigMSTPDefaultAdminPathCost_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_STPPortConfigMSTPDefaultAdminPathCost *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_stp_STPPortConfigMSTPDefaultAdminPathCost(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetPortConfigMSTPDefaultAdminPathCost(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetPortConfigMSTPPortAdminPathCost_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct devicepb_PortList *in = malloc(sizeof(*in));
  struct stppb_STPPortConfigMSTPPortAdminPathCost *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_device_PortList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_GetPortConfigMSTPPortAdminPathCost(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_STPPortConfigMSTPPortAdminPathCost(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetPortConfigMSTPPortAdminPathCost_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_STPPortConfigMSTPPortAdminPathCost *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_stp_STPPortConfigMSTPPortAdminPathCost(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetPortConfigMSTPPortAdminPathCost(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetPortConfigBPDUGuard_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct devicepb_PortList *in = malloc(sizeof(*in));
  struct stppb_STPPortConfigBPDUGuard *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_device_PortList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_GetPortConfigBPDUGuard(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_STPPortConfigBPDUGuard(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetPortConfigBPDUGuard_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_STPPortConfigBPDUGuard *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_stp_STPPortConfigBPDUGuard(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetPortConfigBPDUGuard(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetPortConfigBPDUReceiveOnly_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct devicepb_PortList *in = malloc(sizeof(*in));
  struct stppb_STPPortConfigBPDUReceiveOnly *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_device_PortList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_GetPortConfigBPDUReceiveOnly(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_STPPortConfigBPDUReceiveOnly(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetPortConfigBPDUReceiveOnly_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_STPPortConfigBPDUReceiveOnly *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_stp_STPPortConfigBPDUReceiveOnly(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetPortConfigBPDUReceiveOnly(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetPortConfigRestrictTcn_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct devicepb_PortList *in = malloc(sizeof(*in));
  struct stppb_STPPortConfigRestrictTcn *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_device_PortList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_GetPortConfigRestrictTcn(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_STPPortConfigRestrictTcn(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetPortConfigRestrictTcn_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_STPPortConfigRestrictTcn *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_stp_STPPortConfigRestrictTcn(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetPortConfigRestrictTcn(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetPortConfigRestrictRoot_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct devicepb_PortList *in = malloc(sizeof(*in));
  struct stppb_STPPortConfigRestrictRoot *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_device_PortList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_GetPortConfigRestrictRoot(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_STPPortConfigRestrictRoot(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetPortConfigRestrictRoot_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_STPPortConfigRestrictRoot *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_stp_STPPortConfigRestrictRoot(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetPortConfigRestrictRoot(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_GetMSTPGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_MSTPIDList *in = malloc(sizeof(*in));
  struct stppb_MSTPGroup *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_stp_MSTPIDList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_GetMSTPGroup(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_stp,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_MSTPGroup(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_SetMSTPGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_MSTPGroup *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_stp_MSTPGroup(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_SetMSTPGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_stp_MSTP_DeleteMSTPGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_MSTPIDList *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_stp_MSTPIDList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  stp_MSTP_DeleteMSTPGroup(in, out);

  free(in);
  free(out);
  return res;
}

status_t y_intri_stp_init(
    const xmlChar *modname,
    const xmlChar *revision) {
  status_t res = NO_ERR;
  agt_profile_t *agt_profile = agt_get_profile();

  if (xml_strcmp(modname, y_M_intri_stp)) {
    return ERR_NCX_UNKNOWN_MODULE;
  }
  if (revision && xml_strcmp(revision, y_R_intri_stp)) {
    return ERR_NCX_WRONG_VERSION;
  }

  res = ncxmod_load_module(
      y_M_intri_stp,
      y_R_intri_stp,
      &agt_profile->agt_savedevQ,
      &intri_stp_mod);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetConfig",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetConfig",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetCistConfig",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetCistConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetMstiConfig",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetMstiConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetCistStatus",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetCistStatus_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetMstiStatus",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetMstiStatus_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-RunReconfigPortState",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_RunReconfigPortState_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigMode",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetBridgeConfigMode_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigMode",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetBridgeConfigMode_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigPriority",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetBridgeConfigPriority_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigPriority",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetBridgeConfigPriority_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigHelloTime",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetBridgeConfigHelloTime_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigHelloTime",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetBridgeConfigHelloTime_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigMaxAge",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetBridgeConfigMaxAge_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigMaxAge",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetBridgeConfigMaxAge_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigForwardDelay",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetBridgeConfigForwardDelay_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigForwardDelay",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetBridgeConfigForwardDelay_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigTxHoldCount",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetBridgeConfigTxHoldCount_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigTxHoldCount",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetBridgeConfigTxHoldCount_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigMSTPRegionName",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetBridgeConfigMSTPRegionName_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigMSTPRegionName",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetBridgeConfigMSTPRegionName_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigMSTPRevisionLevel",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetBridgeConfigMSTPRevisionLevel_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigMSTPRevisionLevel",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetBridgeConfigMSTPRevisionLevel_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigMSTPMaxHops",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetBridgeConfigMSTPMaxHops_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigMSTPMaxHops",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetBridgeConfigMSTPMaxHops_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigEnabled",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetPortConfigEnabled_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigEnabled",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetPortConfigEnabled_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigPriority",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetPortConfigPriority_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigPriority",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetPortConfigPriority_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigAdminP2PPort",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetPortConfigAdminP2PPort_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigAdminP2PPort",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetPortConfigAdminP2PPort_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigAdminEdgePort",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetPortConfigAdminEdgePort_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigAdminEdgePort",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetPortConfigAdminEdgePort_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigAdminPathCost",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetPortConfigAdminPathCost_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigAdminPathCost",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetPortConfigAdminPathCost_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigMSTPDefaultPriority",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetPortConfigMSTPDefaultPriority_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigMSTPDefaultPriority",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetPortConfigMSTPDefaultPriority_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigMSTPPortPriority",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetPortConfigMSTPPortPriority_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigMSTPPortPriority",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetPortConfigMSTPPortPriority_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigMSTPDefaultAdminPathCost",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetPortConfigMSTPDefaultAdminPathCost_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigMSTPDefaultAdminPathCost",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetPortConfigMSTPDefaultAdminPathCost_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigMSTPPortAdminPathCost",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetPortConfigMSTPPortAdminPathCost_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigMSTPPortAdminPathCost",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetPortConfigMSTPPortAdminPathCost_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigBPDUGuard",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetPortConfigBPDUGuard_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigBPDUGuard",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetPortConfigBPDUGuard_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigBPDUReceiveOnly",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetPortConfigBPDUReceiveOnly_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigBPDUReceiveOnly",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetPortConfigBPDUReceiveOnly_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigRestrictTcn",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetPortConfigRestrictTcn_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigRestrictTcn",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetPortConfigRestrictTcn_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigRestrictRoot",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetPortConfigRestrictRoot_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigRestrictRoot",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetPortConfigRestrictRoot_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetMSTPGroup",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_GetMSTPGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetMSTPGroup",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_SetMSTPGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_stp,
      "intri-stp-MSTP-DeleteMSTPGroup",
      AGT_RPC_PH_INVOKE,
      intri_stp_MSTP_DeleteMSTPGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  return res;
}

status_t y_intri_stp_init2(void) {
  status_t res = NO_ERR;
  return res;
}

void y_intri_stp_cleanup(void) {
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetConfig");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetConfig");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetCistConfig");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetMstiConfig");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetCistStatus");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetMstiStatus");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-RunReconfigPortState");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigMode");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigMode");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigPriority");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigPriority");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigHelloTime");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigHelloTime");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigMaxAge");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigMaxAge");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigForwardDelay");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigForwardDelay");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigTxHoldCount");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigTxHoldCount");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigMSTPRegionName");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigMSTPRegionName");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigMSTPRevisionLevel");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigMSTPRevisionLevel");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetBridgeConfigMSTPMaxHops");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetBridgeConfigMSTPMaxHops");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigEnabled");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigEnabled");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigPriority");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigPriority");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigAdminP2PPort");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigAdminP2PPort");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigAdminEdgePort");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigAdminEdgePort");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigAdminPathCost");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigAdminPathCost");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigMSTPDefaultPriority");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigMSTPDefaultPriority");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigMSTPPortPriority");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigMSTPPortPriority");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigMSTPDefaultAdminPathCost");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigMSTPDefaultAdminPathCost");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigMSTPPortAdminPathCost");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigMSTPPortAdminPathCost");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigBPDUGuard");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigBPDUGuard");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigBPDUReceiveOnly");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigBPDUReceiveOnly");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigRestrictTcn");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigRestrictTcn");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetPortConfigRestrictRoot");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetPortConfigRestrictRoot");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-GetMSTPGroup");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-SetMSTPGroup");
  agt_rpc_unregister_method(
      y_M_intri_stp,
      "intri-stp-MSTP-DeleteMSTPGroup");
}
