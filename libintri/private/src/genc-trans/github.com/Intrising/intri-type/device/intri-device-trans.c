// Code generated by protoc-gen-yang(*.c) DO NOT EDIT.

/*****************************************************************************************************
 * Copyright (C) 2017-2022 by Intrising
 *  - ian0113@intrising.com.tw
 * 
 * Generated by protoc-gen-yang@gen-yang
 * 
 *****************************************************************************************************/

#include <libxml/xmlstring.h>
#include "agt.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "procdefs.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"

#include "intri-device-trans.h"
#include "../../../../../../../.libintrishare/libintrishare.h"

#include "../../../../github.com/Intrising/intri-type/common/intri-common-trans.h"
#include "../../../../github.com/golang/protobuf/ptypes/empty/intri-empty-trans.h"

status_t build_to_xml_device_LedInfo(
    val_value_t *parentval,
    struct devicepb_LedInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Name",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Name;
  childval = agt_make_object(
      parentval->obj,
      "PortNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->PortNo;
  childval = agt_make_object(
      parentval->obj,
      "Type",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->Type) {
    case devicepb_DeviceTypeOptions_DEVICE_TYPE_MCU:
      enum_str = "DEVICE_TYPE_MCU";
      break;
    case devicepb_DeviceTypeOptions_DEVICE_TYPE_I2C:
      enum_str = "DEVICE_TYPE_I2C";
      break;
    case devicepb_DeviceTypeOptions_DEVICE_TYPE_GPIO:
      enum_str = "DEVICE_TYPE_GPIO";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "Direction",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Direction;
  switch (entry->Device_Union_Option) {
    case devicepb_LedInfo_Device_Union_Options_LEDDevice:
      childval = agt_make_object(
          parentval->obj,
          "LEDDevice",
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      /* message */
      res = build_to_xml_device_MCULedDevice(
          childval,
          entry->Device.Device_LEDDevice);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
    case devicepb_LedInfo_Device_Union_Options_I2CDevice:
      childval = agt_make_object(
          parentval->obj,
          "I2CDevice",
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      /* message */
      res = build_to_xml_device_I2CDevice(
          childval,
          entry->Device.Device_I2CDevice);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
    case devicepb_LedInfo_Device_Union_Options_GPIODevice:
      childval = agt_make_object(
          parentval->obj,
          "GPIODevice",
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      /* message */
      res = build_to_xml_device_GPIODevice(
          childval,
          entry->Device.Device_GPIODevice);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
  }
  return res;
}
status_t build_to_xml_device_MonitorInfo(
    val_value_t *parentval,
    struct devicepb_MonitorInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Name",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Name;
  childval = agt_make_object(
      parentval->obj,
      "Type",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->Type) {
    case devicepb_DeviceTypeOptions_DEVICE_TYPE_MCU:
      enum_str = "DEVICE_TYPE_MCU";
      break;
    case devicepb_DeviceTypeOptions_DEVICE_TYPE_I2C:
      enum_str = "DEVICE_TYPE_I2C";
      break;
    case devicepb_DeviceTypeOptions_DEVICE_TYPE_GPIO:
      enum_str = "DEVICE_TYPE_GPIO";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "Direction",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Direction;
  switch (entry->Device_Union_Option) {
    case devicepb_MonitorInfo_Device_Union_Options_MonitorDevice:
      childval = agt_make_object(
          parentval->obj,
          "MonitorDevice",
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      /* message */
      res = build_to_xml_device_MCUMonitorDevice(
          childval,
          entry->Device.Device_MonitorDevice);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
    case devicepb_MonitorInfo_Device_Union_Options_I2CDevice:
      childval = agt_make_object(
          parentval->obj,
          "I2CDevice",
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      /* message */
      res = build_to_xml_device_I2CDevice(
          childval,
          entry->Device.Device_I2CDevice);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
    case devicepb_MonitorInfo_Device_Union_Options_GPIODevice:
      childval = agt_make_object(
          parentval->obj,
          "GPIODevice",
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      /* message */
      res = build_to_xml_device_GPIODevice(
          childval,
          entry->Device.Device_GPIODevice);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
  }
  return res;
}
status_t build_to_xml_device_PSUInfo(
    val_value_t *parentval,
    struct devicepb_PSUInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Name",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Name;
  childval = agt_make_object(
      parentval->obj,
      "Type",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->Type) {
    case devicepb_DeviceTypeOptions_DEVICE_TYPE_MCU:
      enum_str = "DEVICE_TYPE_MCU";
      break;
    case devicepb_DeviceTypeOptions_DEVICE_TYPE_I2C:
      enum_str = "DEVICE_TYPE_I2C";
      break;
    case devicepb_DeviceTypeOptions_DEVICE_TYPE_GPIO:
      enum_str = "DEVICE_TYPE_GPIO";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "Direction",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Direction;
  switch (entry->Device_Union_Option) {
    case devicepb_PSUInfo_Device_Union_Options_PSUDevice:
      childval = agt_make_object(
          parentval->obj,
          "PSUDevice",
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      /* message */
      res = build_to_xml_device_MCUPSUDevice(
          childval,
          entry->Device.Device_PSUDevice);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
    case devicepb_PSUInfo_Device_Union_Options_I2CDevice:
      childval = agt_make_object(
          parentval->obj,
          "I2CDevice",
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      /* message */
      res = build_to_xml_device_I2CDevice(
          childval,
          entry->Device.Device_I2CDevice);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
    case devicepb_PSUInfo_Device_Union_Options_GPIODevice:
      childval = agt_make_object(
          parentval->obj,
          "GPIODevice",
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      /* message */
      res = build_to_xml_device_GPIODevice(
          childval,
          entry->Device.Device_GPIODevice);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
  }
  return res;
}
status_t build_to_xml_device_MCULedDevice(
    val_value_t *parentval,
    struct devicepb_MCULedDevice *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "I2CAddr",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->I2CAddr;
  childval = agt_make_object(
      parentval->obj,
      "AddrRegister",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->AddrRegister;
  childval = agt_make_object(
      parentval->obj,
      "LedAction",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->LedAction) {
    case devicepb_LedTypeOptions_LED_TYPE_OFF:
      enum_str = "LED_TYPE_OFF";
      break;
    case devicepb_LedTypeOptions_LED_TYPE_ON:
      enum_str = "LED_TYPE_ON";
      break;
    case devicepb_LedTypeOptions_LED_TYPE_ORANGE:
      enum_str = "LED_TYPE_ORANGE";
      break;
    case devicepb_LedTypeOptions_LED_TYPE_GREEN:
      enum_str = "LED_TYPE_GREEN";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "ActiveBit",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->ActiveBit;
  return res;
}
status_t build_to_xml_device_MCUMonitorDevice(
    val_value_t *parentval,
    struct devicepb_MCUMonitorDevice *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "I2CAddr",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->I2CAddr;
  childval = agt_make_object(
      parentval->obj,
      "AddrRegister",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->AddrRegister;
  childval = agt_make_object(
      parentval->obj,
      "MonitorAction",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->MonitorAction) {
    case devicepb_MonitorTypeOptions_MONITOR_TYPE_TEMP_OK:
      enum_str = "MONITOR_TYPE_TEMP_OK";
      break;
    case devicepb_MonitorTypeOptions_MONITOR_TYPE_TEMP_WARN:
      enum_str = "MONITOR_TYPE_TEMP_WARN";
      break;
    case devicepb_MonitorTypeOptions_MONITOR_TYPE_FAN_OK:
      enum_str = "MONITOR_TYPE_FAN_OK";
      break;
    case devicepb_MonitorTypeOptions_MONITOR_TYPE_FAN_WARN:
      enum_str = "MONITOR_TYPE_FAN_WARN";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "ActiveBit",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->ActiveBit;
  return res;
}
status_t build_to_xml_device_MCUPSUDevice(
    val_value_t *parentval,
    struct devicepb_MCUPSUDevice *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "I2CAddr",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->I2CAddr;
  childval = agt_make_object(
      parentval->obj,
      "AddrRegister",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->AddrRegister;
  childval = agt_make_object(
      parentval->obj,
      "PSUAction",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->PSUAction) {
    case devicepb_PSUTypeOptions_PSU_TYPE_LOCATION_OK:
      enum_str = "PSU_TYPE_LOCATION_OK";
      break;
    case devicepb_PSUTypeOptions_PSU_TYPE_LOCATION_WARN:
      enum_str = "PSU_TYPE_LOCATION_WARN";
      break;
    case devicepb_PSUTypeOptions_PSU_TYPE_AC_OK:
      enum_str = "PSU_TYPE_AC_OK";
      break;
    case devicepb_PSUTypeOptions_PSU_TYPE_AC_WARN:
      enum_str = "PSU_TYPE_AC_WARN";
      break;
    case devicepb_PSUTypeOptions_PSU_TYPE_PW_OK:
      enum_str = "PSU_TYPE_PW_OK";
      break;
    case devicepb_PSUTypeOptions_PSU_TYPE_PW_WARN:
      enum_str = "PSU_TYPE_PW_WARN";
      break;
    case devicepb_PSUTypeOptions_PSU_TYPE_FAIL:
      enum_str = "PSU_TYPE_FAIL";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "ActiveBit",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->ActiveBit;
  return res;
}
status_t build_to_xml_device_MCUFanDevice(
    val_value_t *parentval,
    struct devicepb_MCUFanDevice *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "I2CAddr",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->I2CAddr;
  childval = agt_make_object(
      parentval->obj,
      "AddrRegister",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->AddrRegister;
  childval = agt_make_object(
      parentval->obj,
      "FANAction",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->FANAction) {
    case devicepb_FanTypeOptions_FAN_TYPE_RPM:
      enum_str = "FAN_TYPE_RPM";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "ActiveBit",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->ActiveBit;
  return res;
}
status_t build_to_xml_device_I2CDevice(
    val_value_t *parentval,
    struct devicepb_I2CDevice *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "I2CAddr",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->I2CAddr;
  childval = agt_make_object(
      parentval->obj,
      "AddrRegister",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->AddrRegister;
  childval = agt_make_object(
      parentval->obj,
      "Action",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->Action;
  childval = agt_make_object(
      parentval->obj,
      "ActiveBit",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->ActiveBit;
  return res;
}
status_t build_to_xml_device_GPIODevice(
    val_value_t *parentval,
    struct devicepb_GPIODevice *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Register",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->Register;
  childval = agt_make_object(
      parentval->obj,
      "Pin",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->Pin;
  childval = agt_make_object(
      parentval->obj,
      "Action",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->Action;
  childval = agt_make_object(
      parentval->obj,
      "Enable",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->Enable;
  return res;
}
status_t build_to_xml_device_I2Cinfo(
    val_value_t *parentval,
    struct devicepb_I2Cinfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Name",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Name;
  childval = agt_make_object(
      parentval->obj,
      "Direction",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Direction;
  childval = agt_make_object(
      parentval->obj,
      "Device",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_I2CDevice(
      childval,
      entry->Device);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_GPIOInfo(
    val_value_t *parentval,
    struct devicepb_GPIOInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Name",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Name;
  childval = agt_make_object(
      parentval->obj,
      "Direction",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Direction;
  childval = agt_make_object(
      parentval->obj,
      "Device",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_GPIODevice(
      childval,
      entry->Device);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_PTPClockSynchronizerInfo(
    val_value_t *parentval,
    struct devicepb_PTPClockSynchronizerInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Name",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Name;
  childval = agt_make_object(
      parentval->obj,
      "Direction",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Direction;
  childval = agt_make_object(
      parentval->obj,
      "Device",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_I2CDevice(
      childval,
      entry->Device);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_GPSInfo(
    val_value_t *parentval,
    struct devicepb_GPSInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Name",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Name;
  childval = agt_make_object(
      parentval->obj,
      "Path",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Path;
  childval = agt_make_object(
      parentval->obj,
      "Direction",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Direction;
  return res;
}
status_t build_to_xml_device_ToDInfo(
    val_value_t *parentval,
    struct devicepb_ToDInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Name",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Name;
  childval = agt_make_object(
      parentval->obj,
      "Path",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Path;
  childval = agt_make_object(
      parentval->obj,
      "Direction",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Direction;
  return res;
}
status_t build_to_xml_device_UARTDevice(
    val_value_t *parentval,
    struct devicepb_UARTDevice *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Name",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Name;
  childval = agt_make_object(
      parentval->obj,
      "Path",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Path;
  childval = agt_make_object(
      parentval->obj,
      "Direction",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Direction;
  childval = agt_make_object(
      parentval->obj,
      "Bandwidth",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->Bandwidth;
  return res;
}
status_t build_to_xml_device_FanInfo(
    val_value_t *parentval,
    struct devicepb_FanInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Name",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Name;
  childval = agt_make_object(
      parentval->obj,
      "Type",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->Type) {
    case devicepb_FanDeviceTypeOptions_FAN_DEVICE_TYPE_RPM:
      enum_str = "FAN_DEVICE_TYPE_RPM";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "FanNumber",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->FanNumber;
  switch (entry->Device_Union_Option) {
    case devicepb_FanInfo_Device_Union_Options_FANDevice:
      childval = agt_make_object(
          parentval->obj,
          "FANDevice",
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      /* message */
      res = build_to_xml_device_MCUFanDevice(
          childval,
          entry->Device.Device_FANDevice);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
    case devicepb_FanInfo_Device_Union_Options_I2CDevice:
      childval = agt_make_object(
          parentval->obj,
          "I2CDevice",
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      /* message */
      res = build_to_xml_device_I2CDevice(
          childval,
          entry->Device.Device_I2CDevice);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
    case devicepb_FanInfo_Device_Union_Options_GPIODevice:
      childval = agt_make_object(
          parentval->obj,
          "GPIODevice",
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      /* message */
      res = build_to_xml_device_GPIODevice(
          childval,
          entry->Device.Device_GPIODevice);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
  }
  return res;
}
status_t build_to_xml_device_PoEInfo(
    val_value_t *parentval,
    struct devicepb_PoEInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Name",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Name;
  childval = agt_make_object(
      parentval->obj,
      "Type",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->Type) {
    case devicepb_PoEDeviceTypeOptions_POE_DEVICE_TYPE_I2C:
      enum_str = "POE_DEVICE_TYPE_I2C";
      break;
    case devicepb_PoEDeviceTypeOptions_POE_DEVICE_TYPE_UART:
      enum_str = "POE_DEVICE_TYPE_UART";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  switch (entry->Device_Union_Option) {
    case devicepb_PoEInfo_Device_Union_Options_I2CDevice:
      childval = agt_make_object(
          parentval->obj,
          "I2CDevice",
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      /* message */
      res = build_to_xml_device_I2CDevice(
          childval,
          entry->Device.Device_I2CDevice);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
    case devicepb_PoEInfo_Device_Union_Options_UartDevice:
      childval = agt_make_object(
          parentval->obj,
          "UartDevice",
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      /* message */
      res = build_to_xml_device_UARTDevice(
          childval,
          entry->Device.Device_UartDevice);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
  }
  return res;
}
status_t build_to_xml_device_HardwareInfo(
    val_value_t *parentval,
    struct devicepb_HardwareInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "DeviceLed",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->DeviceLed_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "DeviceLed_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_LedInfo(
        listval,
        entry->DeviceLed[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = agt_make_object(
      parentval->obj,
      "DeviceHWMonitor",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->DeviceHWMonitor_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "DeviceHWMonitor_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_MonitorInfo(
        listval,
        entry->DeviceHWMonitor[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = agt_make_object(
      parentval->obj,
      "DevicePSU",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->DevicePSU_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "DevicePSU_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_PSUInfo(
        listval,
        entry->DevicePSU[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = agt_make_object(
      parentval->obj,
      "DeviceI2C",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->DeviceI2C_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "DeviceI2C_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_I2Cinfo(
        listval,
        entry->DeviceI2C[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = agt_make_object(
      parentval->obj,
      "DeviceHW",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->DeviceHW_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "DeviceHW_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_GPIOInfo(
        listval,
        entry->DeviceHW[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = agt_make_object(
      parentval->obj,
      "DevicePTP",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->DevicePTP_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "DevicePTP_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_PTPClockSynchronizerInfo(
        listval,
        entry->DevicePTP[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = agt_make_object(
      parentval->obj,
      "DeviceGPS",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->DeviceGPS_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "DeviceGPS_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_GPSInfo(
        listval,
        entry->DeviceGPS[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = agt_make_object(
      parentval->obj,
      "DeviceToD",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->DeviceToD_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "DeviceToD_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_ToDInfo(
        listval,
        entry->DeviceToD[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = agt_make_object(
      parentval->obj,
      "DeviceFan",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->DeviceFan_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "DeviceFan_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_FanInfo(
        listval,
        entry->DeviceFan[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = agt_make_object(
      parentval->obj,
      "DevicePoE",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->DevicePoE_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "DevicePoE_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_PoEInfo(
        listval,
        entry->DevicePoE[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_device_HardwareTableSize(
    val_value_t *parentval,
    struct devicepb_HardwareTableSize *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "TcamSize",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->TcamSize;
  childval = agt_make_object(
      parentval->obj,
      "BridgeFDBEntries",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->BridgeFDBEntries;
  childval = agt_make_object(
      parentval->obj,
      "VirtualPorts",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->VirtualPorts;
  childval = agt_make_object(
      parentval->obj,
      "VirtualBridgeDomains",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->VirtualBridgeDomains;
  childval = agt_make_object(
      parentval->obj,
      "ARPTableEntries",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->ARPTableEntries;
  childval = agt_make_object(
      parentval->obj,
      "RouterIPv4HostEntries",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->RouterIPv4HostEntries;
  childval = agt_make_object(
      parentval->obj,
      "RouterIPv6HostEntries",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->RouterIPv6HostEntries;
  childval = agt_make_object(
      parentval->obj,
      "RouterNextHopEntries",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->RouterNextHopEntries;
  childval = agt_make_object(
      parentval->obj,
      "MulticastPhysicalPortGroups",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->MulticastPhysicalPortGroups;
  childval = agt_make_object(
      parentval->obj,
      "MulticastLinkedListEntries",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->MulticastLinkedListEntries;
  childval = agt_make_object(
      parentval->obj,
      "CentralizedCounters",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->CentralizedCounters;
  childval = agt_make_object(
      parentval->obj,
      "SpanningTreeGroups",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->SpanningTreeGroups;
  childval = agt_make_object(
      parentval->obj,
      "QoSProfiles",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->QoSProfiles;
  childval = agt_make_object(
      parentval->obj,
      "L2L3PortIsolation",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->L2L3PortIsolation;
  return res;
}
status_t build_to_xml_device_PhyInterface(
    val_value_t *parentval,
    struct devicepb_PhyInterface *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Interface",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->Interface;
  childval = agt_make_object(
      parentval->obj,
      "Type",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->Type) {
    case devicepb_PhyInterfaceTypeOptions_PHY_INTERFACE_TYPE_SMI:
      enum_str = "PHY_INTERFACE_TYPE_SMI";
      break;
    case devicepb_PhyInterfaceTypeOptions_PHY_INTERFACE_TYPE_XSMI:
      enum_str = "PHY_INTERFACE_TYPE_XSMI";
      break;
    case devicepb_PhyInterfaceTypeOptions_PHY_INTERFACE_TYPE_UNUSED:
      enum_str = "PHY_INTERFACE_TYPE_UNUSED";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  return res;
}
status_t build_to_xml_device_PortInfo(
    val_value_t *parentval,
    struct devicepb_PortInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "PortNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->PortNo;
  childval = agt_make_object(
      parentval->obj,
      "MACChip",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->MACChip;
  childval = agt_make_object(
      parentval->obj,
      "MACNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->MACNo;
  childval = agt_make_object(
      parentval->obj,
      "PortGroup",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->PortGroup;
  childval = agt_make_object(
      parentval->obj,
      "PhyID1",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->PhyID1;
  childval = agt_make_object(
      parentval->obj,
      "PhyID2",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->PhyID2;
  childval = agt_make_object(
      parentval->obj,
      "PhyInterface",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_PhyInterface(
      childval,
      entry->PhyInterface);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "PoENo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->PoENo;
  childval = agt_make_object(
      parentval->obj,
      "PoEChannel",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->PoEChannel_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "PoEChannel_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* int32 */
    VAL_INT(listval) = entry->PoEChannel[i];
  }
  childval = agt_make_object(
      parentval->obj,
      "PoEChipNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->PoEChipNo;
  childval = agt_make_object(
      parentval->obj,
      "MacsecEncLen",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->MacsecEncLen;
  childval = agt_make_object(
      parentval->obj,
      "InterfaceType",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->InterfaceType) {
    case devicepb_PortInterfaceTypeOptions_PORT_INTERFACE_TYPE_COPPER:
      enum_str = "PORT_INTERFACE_TYPE_COPPER";
      break;
    case devicepb_PortInterfaceTypeOptions_PORT_INTERFACE_TYPE_OPTICAL:
      enum_str = "PORT_INTERFACE_TYPE_OPTICAL";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "Properties",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->Properties_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "Properties_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* enum */
    switch (entry->Properties[i]) {
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_10M_FULL:
        enum_str = "PORT_PROPERTIES_TYPE_10M_FULL";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_10M_HALF:
        enum_str = "PORT_PROPERTIES_TYPE_10M_HALF";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_100M_FULL:
        enum_str = "PORT_PROPERTIES_TYPE_100M_FULL";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_100M_HALF:
        enum_str = "PORT_PROPERTIES_TYPE_100M_HALF";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_1000M_FULL:
        enum_str = "PORT_PROPERTIES_TYPE_1000M_FULL";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_2500M_FULL:
        enum_str = "PORT_PROPERTIES_TYPE_2500M_FULL";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_5G_FULL:
        enum_str = "PORT_PROPERTIES_TYPE_5G_FULL";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_10G_FULL:
        enum_str = "PORT_PROPERTIES_TYPE_10G_FULL";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_25G_FULL:
        enum_str = "PORT_PROPERTIES_TYPE_25G_FULL";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_RJ45:
        enum_str = "PORT_PROPERTIES_TYPE_RJ45";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_SFP:
        enum_str = "PORT_PROPERTIES_TYPE_SFP";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_POE:
        enum_str = "PORT_PROPERTIES_TYPE_POE";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_POE_PLUS:
        enum_str = "PORT_PROPERTIES_TYPE_POE_PLUS";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_POE_PLUS_PLUS:
        enum_str = "PORT_PROPERTIES_TYPE_POE_PLUS_PLUS";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_LINK_PORT:
        enum_str = "PORT_PROPERTIES_TYPE_LINK_PORT";
        break;
    }
    VAL_ENUM_NAME(listval) = enum_str;
  }
  childval = agt_make_object(
      parentval->obj,
      "DeviceID",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->DeviceID;
  childval = agt_make_object(
      parentval->obj,
      "SpeedProperties",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->SpeedProperties_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "SpeedProperties_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* enum */
    switch (entry->SpeedProperties[i]) {
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_AUTO:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_AUTO";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_10M_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_10M_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_10M_HALF:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_10M_HALF";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_100M_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_100M_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_100M_HALF:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_100M_HALF";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_1000M_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_1000M_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_2500M_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_2500M_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_5G_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_5G_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_10G_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_10G_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_25G_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_25G_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_40G_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_40G_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_100G_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_100G_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_NA:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_NA";
        break;
    }
    VAL_ENUM_NAME(listval) = enum_str;
  }
  return res;
}
status_t build_to_xml_device_BoardInfo(
    val_value_t *parentval,
    struct devicepb_BoardInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "SystemDescription",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->SystemDescription;
  childval = agt_make_object(
      parentval->obj,
      "PortLists",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->PortLists_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "PortLists_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_PortInfo(
        listval,
        entry->PortLists[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = agt_make_object(
      parentval->obj,
      "HwFeatures",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->HwFeatures_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "HwFeatures_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* enum */
    switch (entry->HwFeatures[i]) {
      case devicepb_FactoryHwFeatureTypeOptions_FACTORY_HW_FEATURE_TYPE_POE_PLUS_PLUS:
        enum_str = "FACTORY_HW_FEATURE_TYPE_POE_PLUS_PLUS";
        break;
      case devicepb_FactoryHwFeatureTypeOptions_FACTORY_HW_FEATURE_TYPE_POE_PLUS:
        enum_str = "FACTORY_HW_FEATURE_TYPE_POE_PLUS";
        break;
      case devicepb_FactoryHwFeatureTypeOptions_FACTORY_HW_FEATURE_TYPE_EEE:
        enum_str = "FACTORY_HW_FEATURE_TYPE_EEE";
        break;
      case devicepb_FactoryHwFeatureTypeOptions_FACTORY_HW_FEATURE_TYPE_RTC:
        enum_str = "FACTORY_HW_FEATURE_TYPE_RTC";
        break;
      case devicepb_FactoryHwFeatureTypeOptions_FACTORY_HW_FEATURE_TYPE_SFP:
        enum_str = "FACTORY_HW_FEATURE_TYPE_SFP";
        break;
    }
    VAL_ENUM_NAME(listval) = enum_str;
  }
  childval = agt_make_object(
      parentval->obj,
      "HwSize",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_HardwareTableSize(
      childval,
      entry->HwSize);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "CPUPort",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->CPUPort;
  childval = agt_make_object(
      parentval->obj,
      "BoardDevice",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_HardwareInfo(
      childval,
      entry->BoardDevice);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "TimeControl",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_TimeControlInfo(
      childval,
      entry->TimeControl);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "EnterpriseOID",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->EnterpriseOID;
  return res;
}
status_t build_to_xml_device_TimeControlSpeedFrequencyEntry(
    val_value_t *parentval,
    struct devicepb_TimeControlSpeedFrequencyEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Speed",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->Speed) {
    case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_10M_FULL:
      enum_str = "PORT_PROPERTIES_TYPE_10M_FULL";
      break;
    case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_10M_HALF:
      enum_str = "PORT_PROPERTIES_TYPE_10M_HALF";
      break;
    case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_100M_FULL:
      enum_str = "PORT_PROPERTIES_TYPE_100M_FULL";
      break;
    case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_100M_HALF:
      enum_str = "PORT_PROPERTIES_TYPE_100M_HALF";
      break;
    case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_1000M_FULL:
      enum_str = "PORT_PROPERTIES_TYPE_1000M_FULL";
      break;
    case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_2500M_FULL:
      enum_str = "PORT_PROPERTIES_TYPE_2500M_FULL";
      break;
    case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_5G_FULL:
      enum_str = "PORT_PROPERTIES_TYPE_5G_FULL";
      break;
    case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_10G_FULL:
      enum_str = "PORT_PROPERTIES_TYPE_10G_FULL";
      break;
    case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_25G_FULL:
      enum_str = "PORT_PROPERTIES_TYPE_25G_FULL";
      break;
    case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_RJ45:
      enum_str = "PORT_PROPERTIES_TYPE_RJ45";
      break;
    case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_SFP:
      enum_str = "PORT_PROPERTIES_TYPE_SFP";
      break;
    case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_POE:
      enum_str = "PORT_PROPERTIES_TYPE_POE";
      break;
    case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_POE_PLUS:
      enum_str = "PORT_PROPERTIES_TYPE_POE_PLUS";
      break;
    case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_POE_PLUS_PLUS:
      enum_str = "PORT_PROPERTIES_TYPE_POE_PLUS_PLUS";
      break;
    case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_LINK_PORT:
      enum_str = "PORT_PROPERTIES_TYPE_LINK_PORT";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "Frequency",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int64 */
  VAL_LONG(childval) = entry->Frequency;
  childval = agt_make_object(
      parentval->obj,
      "M",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int64 */
  VAL_LONG(childval) = entry->M;
  childval = agt_make_object(
      parentval->obj,
      "N",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int64 */
  VAL_LONG(childval) = entry->N;
  childval = agt_make_object(
      parentval->obj,
      "Div",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int64 */
  VAL_LONG(childval) = entry->Div;
  return res;
}
status_t build_to_xml_device_TimeControlPortInfoEntry(
    val_value_t *parentval,
    struct devicepb_TimeControlPortInfoEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "PortNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->PortNo;
  childval = agt_make_object(
      parentval->obj,
      "RCLKPin",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->RCLKPin) {
    case devicepb_RCLKTypeOptions_RCLK_TYPE_0:
      enum_str = "RCLK_TYPE_0";
      break;
    case devicepb_RCLKTypeOptions_RCLK_TYPE_1:
      enum_str = "RCLK_TYPE_1";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "Frequency",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int64 */
  VAL_LONG(childval) = entry->Frequency;
  childval = agt_make_object(
      parentval->obj,
      "InputClock",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->InputClock) {
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_0:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_0";
      break;
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_1:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_1";
      break;
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_2:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_2";
      break;
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_3:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_3";
      break;
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_4:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_4";
      break;
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_5:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_5";
      break;
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_6:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_6";
      break;
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_7:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_7";
      break;
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_8:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_8";
      break;
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_9:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_9";
      break;
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_10:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_10";
      break;
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_11:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_11";
      break;
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_12:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_12";
      break;
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_13:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_13";
      break;
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_14:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_14";
      break;
    case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_15:
      enum_str = "INPUT_CLOCK_INDEX_TYPE_15";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  return res;
}
status_t build_to_xml_device_TimeControlInfo(
    val_value_t *parentval,
    struct devicepb_TimeControlInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "InputClockMapping",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->InputClockMapping_Len; i++) {
    val_value_t *listval = NULL;
    val_value_t *kvval = NULL;
    listval = agt_make_object(
        childval->obj,
        "InputClockMapping_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    kvval = agt_make_object(
        listval->obj,
        "Key",
        &res);
    if (kvval != NULL) {
      val_add_child(kvval, listval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* string */
    VAL_STRING(kvval) = entry->InputClockMapping[i]->Key;
    kvval = agt_make_object(
        listval->obj,
        "Value",
        &res);
    if (kvval != NULL) {
      val_add_child(kvval, listval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* enum */
    switch (entry->InputClockMapping[i]->Value) {
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_0:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_0";
        break;
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_1:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_1";
        break;
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_2:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_2";
        break;
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_3:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_3";
        break;
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_4:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_4";
        break;
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_5:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_5";
        break;
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_6:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_6";
        break;
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_7:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_7";
        break;
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_8:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_8";
        break;
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_9:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_9";
        break;
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_10:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_10";
        break;
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_11:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_11";
        break;
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_12:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_12";
        break;
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_13:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_13";
        break;
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_14:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_14";
        break;
      case devicepb_InputClockIndexTypeOptions_INPUT_CLOCK_INDEX_TYPE_15:
        enum_str = "INPUT_CLOCK_INDEX_TYPE_15";
        break;
    }
    VAL_ENUM_NAME(kvval) = enum_str;
  }
  childval = agt_make_object(
      parentval->obj,
      "PortInfoList",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->PortInfoList_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "PortInfoList_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_TimeControlPortInfoEntry(
        listval,
        entry->PortInfoList[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = agt_make_object(
      parentval->obj,
      "SpeedFrequencyList",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->SpeedFrequencyList_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "SpeedFrequencyList_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_TimeControlSpeedFrequencyEntry(
        listval,
        entry->SpeedFrequencyList[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_device_Boundary(
    val_value_t *parentval,
    struct devicepb_Boundary *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Type",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->Type) {
    case devicepb_BoundaryTypeOptions_BOUNDARY_TYPE_INT:
      enum_str = "BOUNDARY_TYPE_INT";
      break;
    case devicepb_BoundaryTypeOptions_BOUNDARY_TYPE_DOUBLE:
      enum_str = "BOUNDARY_TYPE_DOUBLE";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "Max",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->Max;
  childval = agt_make_object(
      parentval->obj,
      "Min",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->Min;
  childval = agt_make_object(
      parentval->obj,
      "Lower",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* double */
  VAL_DOUBLE(childval) = entry->Lower;
  childval = agt_make_object(
      parentval->obj,
      "Upper",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* double */
  VAL_DOUBLE(childval) = entry->Upper;
  return res;
}
status_t build_to_xml_device_BoundaryAll(
    val_value_t *parentval,
    struct devicepb_BoundaryAll *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VLAN",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_BoundaryVLAN(
      childval,
      entry->VLAN);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Access",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_BoundaryAccess(
      childval,
      entry->Access);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "DDM",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_BoundaryDDM(
      childval,
      entry->DDM);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "ACL",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_BoundaryACL(
      childval,
      entry->ACL);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Log",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_BoundaryLog(
      childval,
      entry->Log);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Mirroring",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_BoundaryMirroring(
      childval,
      entry->Mirroring);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Trunk",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_BoundaryTRUNK(
      childval,
      entry->Trunk);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "FDB",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_BoundaryFDB(
      childval,
      entry->FDB);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "QoS",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_BoundaryQoS(
      childval,
      entry->QoS);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Multicast",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_BoundaryMulticast(
      childval,
      entry->Multicast);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "PoE",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_BoundaryPoE(
      childval,
      entry->PoE);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Files",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_BoundaryFiles(
      childval,
      entry->Files);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "TimeRange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_BoundaryTimeRange(
      childval,
      entry->TimeRange);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "DHCPServer",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_BoundaryDHCPServer(
      childval,
      entry->DHCPServer);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Monitor",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_BoundaryMonitor(
      childval,
      entry->Monitor);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_BoundaryDHCPServer(
    val_value_t *parentval,
    struct devicepb_BoundaryDHCPServer *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "MACBased",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->MACBased);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_BoundaryVLAN(
    val_value_t *parentval,
    struct devicepb_BoundaryVLAN *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VlanID",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->VlanID);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "VlanFilter",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->VlanFilter);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "ProtocolBased",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->ProtocolBased);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "MACBased",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->MACBased);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "SubnetBased",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->SubnetBased);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "TPIDsRange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->TPIDsRange);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "ProtocolClasses",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->ProtocolClasses);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "SelectiveQinQ",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->SelectiveQinQ);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Mapping",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->Mapping);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_BoundaryDDM(
    val_value_t *parentval,
    struct devicepb_BoundaryDDM *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "DdmTemperature",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->DdmTemperature);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "DdmVoltage",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->DdmVoltage);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "DdmTxBias",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->DdmTxBias);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "DdmRxPower",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->DdmRxPower);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "DdmTxPower",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->DdmTxPower);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_BoundaryACL(
    val_value_t *parentval,
    struct devicepb_BoundaryACL *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "ACLs",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->ACLs);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "ACEs",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->ACEs);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Binding",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->Binding);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Flow",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->Flow);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "FlowRules",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->FlowRules);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Rules",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->Rules);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_BoundaryLog(
    val_value_t *parentval,
    struct devicepb_BoundaryLog *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "LogRotateSize",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->LogRotateSize);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "LogRotateFileCount",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->LogRotateFileCount);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "LogTargetList",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->LogTargetList);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_BoundaryAccess(
    val_value_t *parentval,
    struct devicepb_BoundaryAccess *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Users",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->Users);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "UsersAssociatedGroups",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->UsersAssociatedGroups);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Groups",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->Groups);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "GroupsPattern",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->GroupsPattern);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Restrictions",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->Restrictions);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Servers",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->Servers);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_BoundaryMirroring(
    val_value_t *parentval,
    struct devicepb_BoundaryMirroring *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Session",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->Session);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_BoundaryFDB(
    val_value_t *parentval,
    struct devicepb_BoundaryFDB *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "FDBSize",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->FDBSize);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "AgeTime",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->AgeTime);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "PortLearningLimit",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->PortLearningLimit);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "PortSecurityLearningLimit",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->PortSecurityLearningLimit);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "ForwardLimit",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->ForwardLimit);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "DropLimit",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->DropLimit);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_BoundaryTRUNK(
    val_value_t *parentval,
    struct devicepb_BoundaryTRUNK *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "IDRange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->IDRange);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "PriorityRange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->PriorityRange);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "MemberRange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->MemberRange);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_BoundaryMulticast(
    val_value_t *parentval,
    struct devicepb_BoundaryMulticast *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VIDXRange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->VIDXRange);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "StaticEntries",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->StaticEntries);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "DynamicEntries",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->DynamicEntries);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_BoundaryQoS(
    val_value_t *parentval,
    struct devicepb_BoundaryQoS *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "QueueListRange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->QueueListRange);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "CoSRange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->CoSRange);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "DSCPRange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->DSCPRange);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "WRRRange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->WRRRange);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_BoundaryPoE(
    val_value_t *parentval,
    struct devicepb_BoundaryPoE *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "BudgetRange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->BudgetRange);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_BoundaryFiles(
    val_value_t *parentval,
    struct devicepb_BoundaryFiles *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "CertificatedRange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->CertificatedRange);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_BoundaryTimeRange(
    val_value_t *parentval,
    struct devicepb_BoundaryTimeRange *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "EntryRange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->EntryRange);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_BoundaryMonitor(
    val_value_t *parentval,
    struct devicepb_BoundaryMonitor *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Temperature",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->Temperature);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Power",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->Power);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Cpu",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->Cpu);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Memory",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->Memory);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "PowerRedundantConsumption",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->PowerRedundantConsumption);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "PowerRedundantTemperature",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->PowerRedundantTemperature);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "PowerRedundantVoltage",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->PowerRedundantVoltage);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "PowerRedundantCurrent",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_Boundary(
      childval,
      entry->PowerRedundantCurrent);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_FunctionControlAll(
    val_value_t *parentval,
    struct devicepb_FunctionControlAll *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "VLAN",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_FunctionControlVLAN(
      childval,
      entry->VLAN);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Acl",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_FunctionControlACL(
      childval,
      entry->Acl);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Mirroring",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_FunctionControlMirroring(
      childval,
      entry->Mirroring);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "FDB",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_FunctionControlFDB(
      childval,
      entry->FDB);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_device_FunctionControlVLAN(
    val_value_t *parentval,
    struct devicepb_FunctionControlVLAN *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Voice",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->Voice;
  childval = agt_make_object(
      parentval->obj,
      "SelectiveQinq",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->SelectiveQinq;
  childval = agt_make_object(
      parentval->obj,
      "MACBased",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->MACBased;
  childval = agt_make_object(
      parentval->obj,
      "SubnetBased",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->SubnetBased;
  childval = agt_make_object(
      parentval->obj,
      "ProtocolBased",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->ProtocolBased;
  childval = agt_make_object(
      parentval->obj,
      "Translation",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->Translation;
  return res;
}
status_t build_to_xml_device_FunctionControlACL(
    val_value_t *parentval,
    struct devicepb_FunctionControlACL *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "TimeRange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->TimeRange;
  childval = agt_make_object(
      parentval->obj,
      "Binding",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->Binding;
  childval = agt_make_object(
      parentval->obj,
      "FlowMirroring",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->FlowMirroring;
  return res;
}
status_t build_to_xml_device_FunctionControlMirroring(
    val_value_t *parentval,
    struct devicepb_FunctionControlMirroring *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "RSPAN",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->RSPAN;
  return res;
}
status_t build_to_xml_device_FunctionControlFDB(
    val_value_t *parentval,
    struct devicepb_FunctionControlFDB *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "PortSecurity",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->PortSecurity;
  childval = agt_make_object(
      parentval->obj,
      "LearningLimit",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->LearningLimit;
  childval = agt_make_object(
      parentval->obj,
      "Forward",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->Forward;
  childval = agt_make_object(
      parentval->obj,
      "Drop",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->Drop;
  return res;
}
status_t build_to_xml_device_PathAll(
    val_value_t *parentval,
    struct devicepb_PathAll *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "LogRamDisk",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->LogRamDisk;
  childval = agt_make_object(
      parentval->obj,
      "LogFlash",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->LogFlash;
  childval = agt_make_object(
      parentval->obj,
      "ConfigDefault",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->ConfigDefault;
  childval = agt_make_object(
      parentval->obj,
      "ConfigSaved",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->ConfigSaved;
  childval = agt_make_object(
      parentval->obj,
      "User",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->User;
  childval = agt_make_object(
      parentval->obj,
      "IPTables",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->IPTables;
  childval = agt_make_object(
      parentval->obj,
      "CoreReboot",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->CoreReboot;
  childval = agt_make_object(
      parentval->obj,
      "WarmStart",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->WarmStart;
  childval = agt_make_object(
      parentval->obj,
      "VlanMgmt",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->VlanMgmt;
  childval = agt_make_object(
      parentval->obj,
      "TimeCfg",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->TimeCfg;
  childval = agt_make_object(
      parentval->obj,
      "BootReady",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->BootReady;
  childval = agt_make_object(
      parentval->obj,
      "IPv6LinkLocal",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->IPv6LinkLocal;
  childval = agt_make_object(
      parentval->obj,
      "TimeZone",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->TimeZone;
  childval = agt_make_object(
      parentval->obj,
      "Resolv",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Resolv;
  childval = agt_make_object(
      parentval->obj,
      "DropbearProc",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->DropbearProc;
  childval = agt_make_object(
      parentval->obj,
      "TelnetProc",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->TelnetProc;
  childval = agt_make_object(
      parentval->obj,
      "FTPProc",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->FTPProc;
  childval = agt_make_object(
      parentval->obj,
      "LocalUser",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->LocalUser;
  childval = agt_make_object(
      parentval->obj,
      "Certificates",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Certificates;
  childval = agt_make_object(
      parentval->obj,
      "OpenSSLCertificates",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->OpenSSLCertificates;
  childval = agt_make_object(
      parentval->obj,
      "SNMPdCertificates",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->SNMPdCertificates;
  childval = agt_make_object(
      parentval->obj,
      "SNMPdCertificatesKey",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->SNMPdCertificatesKey;
  childval = agt_make_object(
      parentval->obj,
      "NetCfg",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->NetCfg;
  childval = agt_make_object(
      parentval->obj,
      "IPv4Script",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->IPv4Script;
  childval = agt_make_object(
      parentval->obj,
      "IPv6Script",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->IPv6Script;
  childval = agt_make_object(
      parentval->obj,
      "LastSaveTime",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->LastSaveTime;
  childval = agt_make_object(
      parentval->obj,
      "Image",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Image;
  childval = agt_make_object(
      parentval->obj,
      "AltVersion",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->AltVersion;
  childval = agt_make_object(
      parentval->obj,
      "AltBuildDateTime",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->AltBuildDateTime;
  childval = agt_make_object(
      parentval->obj,
      "Version",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Version;
  childval = agt_make_object(
      parentval->obj,
      "BuildDateTime",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->BuildDateTime;
  childval = agt_make_object(
      parentval->obj,
      "DhcpServerDnsmasqLeasePath",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->DhcpServerDnsmasqLeasePath;
  childval = agt_make_object(
      parentval->obj,
      "DhcpServerDnsmasqCfgPath",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->DhcpServerDnsmasqCfgPath;
  childval = agt_make_object(
      parentval->obj,
      "DhcpServerPortBasedInfo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->DhcpServerPortBasedInfo;
  return res;
}
status_t build_to_xml_device_InterfaceIdentify(
    val_value_t *parentval,
    struct devicepb_InterfaceIdentify *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Type",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->Type) {
    case devicepb_InterfaceTypeOptions_INTERFACE_TYPE_VLAN:
      enum_str = "INTERFACE_TYPE_VLAN";
      break;
    case devicepb_InterfaceTypeOptions_INTERFACE_TYPE_PORT:
      enum_str = "INTERFACE_TYPE_PORT";
      break;
    case devicepb_InterfaceTypeOptions_INTERFACE_TYPE_TRUNK:
      enum_str = "INTERFACE_TYPE_TRUNK";
      break;
    case devicepb_InterfaceTypeOptions_INTERFACE_TYPE_MULTICAST:
      enum_str = "INTERFACE_TYPE_MULTICAST";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "DeviceID",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->DeviceID;
  childval = agt_make_object(
      parentval->obj,
      "PortNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->PortNo;
  childval = agt_make_object(
      parentval->obj,
      "LAGNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->LAGNo;
  childval = agt_make_object(
      parentval->obj,
      "VlanID",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->VlanID;
  return res;
}
status_t build_to_xml_device_Info(
    val_value_t *parentval,
    struct devicepb_Info *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Model",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Model;
  childval = agt_make_object(
      parentval->obj,
      "MACAddr",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->MACAddr;
  childval = agt_make_object(
      parentval->obj,
      "MACAddrFactory",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->MACAddrFactory;
  childval = agt_make_object(
      parentval->obj,
      "SerialNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->SerialNo;
  childval = agt_make_object(
      parentval->obj,
      "Vendor",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Vendor;
  childval = agt_make_object(
      parentval->obj,
      "AltBuildDateTime",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->AltBuildDateTime;
  childval = agt_make_object(
      parentval->obj,
      "CurrentBuildDateTime",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->CurrentBuildDateTime;
  childval = agt_make_object(
      parentval->obj,
      "AltSwVersion",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->AltSwVersion;
  childval = agt_make_object(
      parentval->obj,
      "CurrentSwVersion",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->CurrentSwVersion;
  childval = agt_make_object(
      parentval->obj,
      "HwVersion",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->HwVersion;
  childval = agt_make_object(
      parentval->obj,
      "CurrentImage",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->CurrentImage;
  childval = agt_make_object(
      parentval->obj,
      "Board",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Board;
  childval = agt_make_object(
      parentval->obj,
      "Layer",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->Layer) {
    case devicepb_LayerTypeOptions_LAYER_TYPE_L2:
      enum_str = "LAYER_TYPE_L2";
      break;
    case devicepb_LayerTypeOptions_LAYER_TYPE_L3:
      enum_str = "LAYER_TYPE_L3";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  return res;
}
status_t build_to_xml_device_PortList(
    val_value_t *parentval,
    struct devicepb_PortList *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "List",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->List_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "List_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_InterfaceIdentify(
        listval,
        entry->List[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}

status_t build_to_priv_device_LedInfo(
    val_value_t *parentval,
    struct devicepb_LedInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Name");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Name = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "PortNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->PortNo = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Type");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->Type = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Direction");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Direction = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "LEDDevice");
  if (childval != NULL && childval->res == NO_ERR) {
    entry->Device_Union_Option = devicepb_LedInfo_Device_Union_Options_LEDDevice;
    /* message */
    entry->Device.Device_LEDDevice = malloc(sizeof(*(entry->Device.Device_LEDDevice)));
    res = build_to_priv_device_MCULedDevice(
        childval,
        entry->Device.Device_LEDDevice);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "I2CDevice");
  if (childval != NULL && childval->res == NO_ERR) {
    entry->Device_Union_Option = devicepb_LedInfo_Device_Union_Options_I2CDevice;
    /* message */
    entry->Device.Device_I2CDevice = malloc(sizeof(*(entry->Device.Device_I2CDevice)));
    res = build_to_priv_device_I2CDevice(
        childval,
        entry->Device.Device_I2CDevice);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "GPIODevice");
  if (childval != NULL && childval->res == NO_ERR) {
    entry->Device_Union_Option = devicepb_LedInfo_Device_Union_Options_GPIODevice;
    /* message */
    entry->Device.Device_GPIODevice = malloc(sizeof(*(entry->Device.Device_GPIODevice)));
    res = build_to_priv_device_GPIODevice(
        childval,
        entry->Device.Device_GPIODevice);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_MonitorInfo(
    val_value_t *parentval,
    struct devicepb_MonitorInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Name");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Name = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Type");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->Type = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Direction");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Direction = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MonitorDevice");
  if (childval != NULL && childval->res == NO_ERR) {
    entry->Device_Union_Option = devicepb_MonitorInfo_Device_Union_Options_MonitorDevice;
    /* message */
    entry->Device.Device_MonitorDevice = malloc(sizeof(*(entry->Device.Device_MonitorDevice)));
    res = build_to_priv_device_MCUMonitorDevice(
        childval,
        entry->Device.Device_MonitorDevice);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "I2CDevice");
  if (childval != NULL && childval->res == NO_ERR) {
    entry->Device_Union_Option = devicepb_MonitorInfo_Device_Union_Options_I2CDevice;
    /* message */
    entry->Device.Device_I2CDevice = malloc(sizeof(*(entry->Device.Device_I2CDevice)));
    res = build_to_priv_device_I2CDevice(
        childval,
        entry->Device.Device_I2CDevice);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "GPIODevice");
  if (childval != NULL && childval->res == NO_ERR) {
    entry->Device_Union_Option = devicepb_MonitorInfo_Device_Union_Options_GPIODevice;
    /* message */
    entry->Device.Device_GPIODevice = malloc(sizeof(*(entry->Device.Device_GPIODevice)));
    res = build_to_priv_device_GPIODevice(
        childval,
        entry->Device.Device_GPIODevice);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_PSUInfo(
    val_value_t *parentval,
    struct devicepb_PSUInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Name");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Name = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Type");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->Type = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Direction");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Direction = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "PSUDevice");
  if (childval != NULL && childval->res == NO_ERR) {
    entry->Device_Union_Option = devicepb_PSUInfo_Device_Union_Options_PSUDevice;
    /* message */
    entry->Device.Device_PSUDevice = malloc(sizeof(*(entry->Device.Device_PSUDevice)));
    res = build_to_priv_device_MCUPSUDevice(
        childval,
        entry->Device.Device_PSUDevice);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "I2CDevice");
  if (childval != NULL && childval->res == NO_ERR) {
    entry->Device_Union_Option = devicepb_PSUInfo_Device_Union_Options_I2CDevice;
    /* message */
    entry->Device.Device_I2CDevice = malloc(sizeof(*(entry->Device.Device_I2CDevice)));
    res = build_to_priv_device_I2CDevice(
        childval,
        entry->Device.Device_I2CDevice);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "GPIODevice");
  if (childval != NULL && childval->res == NO_ERR) {
    entry->Device_Union_Option = devicepb_PSUInfo_Device_Union_Options_GPIODevice;
    /* message */
    entry->Device.Device_GPIODevice = malloc(sizeof(*(entry->Device.Device_GPIODevice)));
    res = build_to_priv_device_GPIODevice(
        childval,
        entry->Device.Device_GPIODevice);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_MCULedDevice(
    val_value_t *parentval,
    struct devicepb_MCULedDevice *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "I2CAddr");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->I2CAddr = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "AddrRegister");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->AddrRegister = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "LedAction");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->LedAction = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "ActiveBit");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->ActiveBit = VAL_INT(childval);
  }
  return res;
}
status_t build_to_priv_device_MCUMonitorDevice(
    val_value_t *parentval,
    struct devicepb_MCUMonitorDevice *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "I2CAddr");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->I2CAddr = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "AddrRegister");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->AddrRegister = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MonitorAction");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->MonitorAction = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "ActiveBit");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->ActiveBit = VAL_INT(childval);
  }
  return res;
}
status_t build_to_priv_device_MCUPSUDevice(
    val_value_t *parentval,
    struct devicepb_MCUPSUDevice *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "I2CAddr");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->I2CAddr = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "AddrRegister");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->AddrRegister = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "PSUAction");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->PSUAction = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "ActiveBit");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->ActiveBit = VAL_INT(childval);
  }
  return res;
}
status_t build_to_priv_device_MCUFanDevice(
    val_value_t *parentval,
    struct devicepb_MCUFanDevice *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "I2CAddr");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->I2CAddr = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "AddrRegister");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->AddrRegister = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "FANAction");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->FANAction = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "ActiveBit");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->ActiveBit = VAL_INT(childval);
  }
  return res;
}
status_t build_to_priv_device_I2CDevice(
    val_value_t *parentval,
    struct devicepb_I2CDevice *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "I2CAddr");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->I2CAddr = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "AddrRegister");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->AddrRegister = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Action");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->Action = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "ActiveBit");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->ActiveBit = VAL_INT(childval);
  }
  return res;
}
status_t build_to_priv_device_GPIODevice(
    val_value_t *parentval,
    struct devicepb_GPIODevice *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Register");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->Register = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Pin");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->Pin = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Action");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->Action = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Enable");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->Enable = VAL_BOOL(childval);
  }
  return res;
}
status_t build_to_priv_device_I2Cinfo(
    val_value_t *parentval,
    struct devicepb_I2Cinfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Name");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Name = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Direction");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Direction = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Device");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Device = malloc(sizeof(*(entry->Device)));
    res = build_to_priv_device_I2CDevice(
        childval,
        entry->Device);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_GPIOInfo(
    val_value_t *parentval,
    struct devicepb_GPIOInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Name");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Name = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Direction");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Direction = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Device");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Device = malloc(sizeof(*(entry->Device)));
    res = build_to_priv_device_GPIODevice(
        childval,
        entry->Device);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_PTPClockSynchronizerInfo(
    val_value_t *parentval,
    struct devicepb_PTPClockSynchronizerInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Name");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Name = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Direction");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Direction = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Device");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Device = malloc(sizeof(*(entry->Device)));
    res = build_to_priv_device_I2CDevice(
        childval,
        entry->Device);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_GPSInfo(
    val_value_t *parentval,
    struct devicepb_GPSInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Name");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Name = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Path");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Path = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Direction");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Direction = VAL_STRING(childval);
  }
  return res;
}
status_t build_to_priv_device_ToDInfo(
    val_value_t *parentval,
    struct devicepb_ToDInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Name");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Name = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Path");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Path = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Direction");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Direction = VAL_STRING(childval);
  }
  return res;
}
status_t build_to_priv_device_UARTDevice(
    val_value_t *parentval,
    struct devicepb_UARTDevice *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Name");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Name = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Path");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Path = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Direction");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Direction = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Bandwidth");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->Bandwidth = VAL_INT(childval);
  }
  return res;
}
status_t build_to_priv_device_FanInfo(
    val_value_t *parentval,
    struct devicepb_FanInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Name");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Name = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Type");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->Type = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "FanNumber");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->FanNumber = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "FANDevice");
  if (childval != NULL && childval->res == NO_ERR) {
    entry->Device_Union_Option = devicepb_FanInfo_Device_Union_Options_FANDevice;
    /* message */
    entry->Device.Device_FANDevice = malloc(sizeof(*(entry->Device.Device_FANDevice)));
    res = build_to_priv_device_MCUFanDevice(
        childval,
        entry->Device.Device_FANDevice);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "I2CDevice");
  if (childval != NULL && childval->res == NO_ERR) {
    entry->Device_Union_Option = devicepb_FanInfo_Device_Union_Options_I2CDevice;
    /* message */
    entry->Device.Device_I2CDevice = malloc(sizeof(*(entry->Device.Device_I2CDevice)));
    res = build_to_priv_device_I2CDevice(
        childval,
        entry->Device.Device_I2CDevice);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "GPIODevice");
  if (childval != NULL && childval->res == NO_ERR) {
    entry->Device_Union_Option = devicepb_FanInfo_Device_Union_Options_GPIODevice;
    /* message */
    entry->Device.Device_GPIODevice = malloc(sizeof(*(entry->Device.Device_GPIODevice)));
    res = build_to_priv_device_GPIODevice(
        childval,
        entry->Device.Device_GPIODevice);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_PoEInfo(
    val_value_t *parentval,
    struct devicepb_PoEInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Name");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Name = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Type");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->Type = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "I2CDevice");
  if (childval != NULL && childval->res == NO_ERR) {
    entry->Device_Union_Option = devicepb_PoEInfo_Device_Union_Options_I2CDevice;
    /* message */
    entry->Device.Device_I2CDevice = malloc(sizeof(*(entry->Device.Device_I2CDevice)));
    res = build_to_priv_device_I2CDevice(
        childval,
        entry->Device.Device_I2CDevice);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "UartDevice");
  if (childval != NULL && childval->res == NO_ERR) {
    entry->Device_Union_Option = devicepb_PoEInfo_Device_Union_Options_UartDevice;
    /* message */
    entry->Device.Device_UartDevice = malloc(sizeof(*(entry->Device.Device_UartDevice)));
    res = build_to_priv_device_UARTDevice(
        childval,
        entry->Device.Device_UartDevice);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_HardwareInfo(
    val_value_t *parentval,
    struct devicepb_HardwareInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "DeviceLed");
  entry->DeviceLed_Len = 0;
  entry->DeviceLed = malloc(sizeof(*entry->DeviceLed));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->DeviceLed_Len = dlq_count(&childval->v.childQ);
    entry->DeviceLed = malloc((entry->DeviceLed_Len + 1) * sizeof(*entry->DeviceLed));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->DeviceLed[cnt] = malloc(sizeof(*(entry->DeviceLed[cnt])));
      res = build_to_priv_device_LedInfo(
          listval,
          entry->DeviceLed[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  childval = val_first_child_name(
      parentval,
      "DeviceHWMonitor");
  entry->DeviceHWMonitor_Len = 0;
  entry->DeviceHWMonitor = malloc(sizeof(*entry->DeviceHWMonitor));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->DeviceHWMonitor_Len = dlq_count(&childval->v.childQ);
    entry->DeviceHWMonitor = malloc((entry->DeviceHWMonitor_Len + 1) * sizeof(*entry->DeviceHWMonitor));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->DeviceHWMonitor[cnt] = malloc(sizeof(*(entry->DeviceHWMonitor[cnt])));
      res = build_to_priv_device_MonitorInfo(
          listval,
          entry->DeviceHWMonitor[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  childval = val_first_child_name(
      parentval,
      "DevicePSU");
  entry->DevicePSU_Len = 0;
  entry->DevicePSU = malloc(sizeof(*entry->DevicePSU));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->DevicePSU_Len = dlq_count(&childval->v.childQ);
    entry->DevicePSU = malloc((entry->DevicePSU_Len + 1) * sizeof(*entry->DevicePSU));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->DevicePSU[cnt] = malloc(sizeof(*(entry->DevicePSU[cnt])));
      res = build_to_priv_device_PSUInfo(
          listval,
          entry->DevicePSU[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  childval = val_first_child_name(
      parentval,
      "DeviceI2C");
  entry->DeviceI2C_Len = 0;
  entry->DeviceI2C = malloc(sizeof(*entry->DeviceI2C));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->DeviceI2C_Len = dlq_count(&childval->v.childQ);
    entry->DeviceI2C = malloc((entry->DeviceI2C_Len + 1) * sizeof(*entry->DeviceI2C));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->DeviceI2C[cnt] = malloc(sizeof(*(entry->DeviceI2C[cnt])));
      res = build_to_priv_device_I2Cinfo(
          listval,
          entry->DeviceI2C[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  childval = val_first_child_name(
      parentval,
      "DeviceHW");
  entry->DeviceHW_Len = 0;
  entry->DeviceHW = malloc(sizeof(*entry->DeviceHW));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->DeviceHW_Len = dlq_count(&childval->v.childQ);
    entry->DeviceHW = malloc((entry->DeviceHW_Len + 1) * sizeof(*entry->DeviceHW));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->DeviceHW[cnt] = malloc(sizeof(*(entry->DeviceHW[cnt])));
      res = build_to_priv_device_GPIOInfo(
          listval,
          entry->DeviceHW[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  childval = val_first_child_name(
      parentval,
      "DevicePTP");
  entry->DevicePTP_Len = 0;
  entry->DevicePTP = malloc(sizeof(*entry->DevicePTP));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->DevicePTP_Len = dlq_count(&childval->v.childQ);
    entry->DevicePTP = malloc((entry->DevicePTP_Len + 1) * sizeof(*entry->DevicePTP));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->DevicePTP[cnt] = malloc(sizeof(*(entry->DevicePTP[cnt])));
      res = build_to_priv_device_PTPClockSynchronizerInfo(
          listval,
          entry->DevicePTP[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  childval = val_first_child_name(
      parentval,
      "DeviceGPS");
  entry->DeviceGPS_Len = 0;
  entry->DeviceGPS = malloc(sizeof(*entry->DeviceGPS));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->DeviceGPS_Len = dlq_count(&childval->v.childQ);
    entry->DeviceGPS = malloc((entry->DeviceGPS_Len + 1) * sizeof(*entry->DeviceGPS));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->DeviceGPS[cnt] = malloc(sizeof(*(entry->DeviceGPS[cnt])));
      res = build_to_priv_device_GPSInfo(
          listval,
          entry->DeviceGPS[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  childval = val_first_child_name(
      parentval,
      "DeviceToD");
  entry->DeviceToD_Len = 0;
  entry->DeviceToD = malloc(sizeof(*entry->DeviceToD));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->DeviceToD_Len = dlq_count(&childval->v.childQ);
    entry->DeviceToD = malloc((entry->DeviceToD_Len + 1) * sizeof(*entry->DeviceToD));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->DeviceToD[cnt] = malloc(sizeof(*(entry->DeviceToD[cnt])));
      res = build_to_priv_device_ToDInfo(
          listval,
          entry->DeviceToD[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  childval = val_first_child_name(
      parentval,
      "DeviceFan");
  entry->DeviceFan_Len = 0;
  entry->DeviceFan = malloc(sizeof(*entry->DeviceFan));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->DeviceFan_Len = dlq_count(&childval->v.childQ);
    entry->DeviceFan = malloc((entry->DeviceFan_Len + 1) * sizeof(*entry->DeviceFan));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->DeviceFan[cnt] = malloc(sizeof(*(entry->DeviceFan[cnt])));
      res = build_to_priv_device_FanInfo(
          listval,
          entry->DeviceFan[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  childval = val_first_child_name(
      parentval,
      "DevicePoE");
  entry->DevicePoE_Len = 0;
  entry->DevicePoE = malloc(sizeof(*entry->DevicePoE));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->DevicePoE_Len = dlq_count(&childval->v.childQ);
    entry->DevicePoE = malloc((entry->DevicePoE_Len + 1) * sizeof(*entry->DevicePoE));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->DevicePoE[cnt] = malloc(sizeof(*(entry->DevicePoE[cnt])));
      res = build_to_priv_device_PoEInfo(
          listval,
          entry->DevicePoE[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_device_HardwareTableSize(
    val_value_t *parentval,
    struct devicepb_HardwareTableSize *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "TcamSize");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->TcamSize = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "BridgeFDBEntries");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->BridgeFDBEntries = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "VirtualPorts");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->VirtualPorts = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "VirtualBridgeDomains");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->VirtualBridgeDomains = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "ARPTableEntries");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->ARPTableEntries = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "RouterIPv4HostEntries");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->RouterIPv4HostEntries = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "RouterIPv6HostEntries");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->RouterIPv6HostEntries = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "RouterNextHopEntries");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->RouterNextHopEntries = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MulticastPhysicalPortGroups");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->MulticastPhysicalPortGroups = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MulticastLinkedListEntries");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->MulticastLinkedListEntries = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "CentralizedCounters");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->CentralizedCounters = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "SpanningTreeGroups");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->SpanningTreeGroups = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "QoSProfiles");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->QoSProfiles = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "L2L3PortIsolation");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->L2L3PortIsolation = VAL_INT(childval);
  }
  return res;
}
status_t build_to_priv_device_PhyInterface(
    val_value_t *parentval,
    struct devicepb_PhyInterface *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Interface");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->Interface = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Type");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->Type = VAL_ENUM(childval);
  }
  return res;
}
status_t build_to_priv_device_PortInfo(
    val_value_t *parentval,
    struct devicepb_PortInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "PortNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->PortNo = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MACChip");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->MACChip = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MACNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->MACNo = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "PortGroup");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->PortGroup = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "PhyID1");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->PhyID1 = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "PhyID2");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->PhyID2 = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "PhyInterface");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->PhyInterface = malloc(sizeof(*(entry->PhyInterface)));
    res = build_to_priv_device_PhyInterface(
        childval,
        entry->PhyInterface);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "PoENo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->PoENo = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "PoEChannel");
  entry->PoEChannel_Len = 0;
  entry->PoEChannel = malloc(sizeof(*entry->PoEChannel));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->PoEChannel_Len = dlq_count(&childval->v.childQ);
    entry->PoEChannel = malloc((entry->PoEChannel_Len + 1) * sizeof(*entry->PoEChannel));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* int32 */
      entry->PoEChannel[cnt] = VAL_INT(listval);
      cnt++;
    }
  }
  childval = val_first_child_name(
      parentval,
      "PoEChipNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->PoEChipNo = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MacsecEncLen");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->MacsecEncLen = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "InterfaceType");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->InterfaceType = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Properties");
  entry->Properties_Len = 0;
  entry->Properties = malloc(sizeof(*entry->Properties));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->Properties_Len = dlq_count(&childval->v.childQ);
    entry->Properties = malloc((entry->Properties_Len + 1) * sizeof(*entry->Properties));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* enum */
      entry->Properties[cnt] = VAL_ENUM(listval);
      cnt++;
    }
  }
  childval = val_first_child_name(
      parentval,
      "DeviceID");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->DeviceID = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "SpeedProperties");
  entry->SpeedProperties_Len = 0;
  entry->SpeedProperties = malloc(sizeof(*entry->SpeedProperties));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->SpeedProperties_Len = dlq_count(&childval->v.childQ);
    entry->SpeedProperties = malloc((entry->SpeedProperties_Len + 1) * sizeof(*entry->SpeedProperties));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* enum */
      entry->SpeedProperties[cnt] = VAL_ENUM(listval);
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_device_BoardInfo(
    val_value_t *parentval,
    struct devicepb_BoardInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "SystemDescription");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->SystemDescription = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "PortLists");
  entry->PortLists_Len = 0;
  entry->PortLists = malloc(sizeof(*entry->PortLists));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->PortLists_Len = dlq_count(&childval->v.childQ);
    entry->PortLists = malloc((entry->PortLists_Len + 1) * sizeof(*entry->PortLists));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->PortLists[cnt] = malloc(sizeof(*(entry->PortLists[cnt])));
      res = build_to_priv_device_PortInfo(
          listval,
          entry->PortLists[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  childval = val_first_child_name(
      parentval,
      "HwFeatures");
  entry->HwFeatures_Len = 0;
  entry->HwFeatures = malloc(sizeof(*entry->HwFeatures));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->HwFeatures_Len = dlq_count(&childval->v.childQ);
    entry->HwFeatures = malloc((entry->HwFeatures_Len + 1) * sizeof(*entry->HwFeatures));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* enum */
      entry->HwFeatures[cnt] = VAL_ENUM(listval);
      cnt++;
    }
  }
  childval = val_first_child_name(
      parentval,
      "HwSize");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->HwSize = malloc(sizeof(*(entry->HwSize)));
    res = build_to_priv_device_HardwareTableSize(
        childval,
        entry->HwSize);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "CPUPort");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->CPUPort = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "BoardDevice");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->BoardDevice = malloc(sizeof(*(entry->BoardDevice)));
    res = build_to_priv_device_HardwareInfo(
        childval,
        entry->BoardDevice);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "TimeControl");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->TimeControl = malloc(sizeof(*(entry->TimeControl)));
    res = build_to_priv_device_TimeControlInfo(
        childval,
        entry->TimeControl);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "EnterpriseOID");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->EnterpriseOID = VAL_STRING(childval);
  }
  return res;
}
status_t build_to_priv_device_TimeControlSpeedFrequencyEntry(
    val_value_t *parentval,
    struct devicepb_TimeControlSpeedFrequencyEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Speed");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->Speed = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Frequency");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int64 */
    entry->Frequency = VAL_LONG(childval);
  }
  childval = val_first_child_name(
      parentval,
      "M");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int64 */
    entry->M = VAL_LONG(childval);
  }
  childval = val_first_child_name(
      parentval,
      "N");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int64 */
    entry->N = VAL_LONG(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Div");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int64 */
    entry->Div = VAL_LONG(childval);
  }
  return res;
}
status_t build_to_priv_device_TimeControlPortInfoEntry(
    val_value_t *parentval,
    struct devicepb_TimeControlPortInfoEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "PortNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->PortNo = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "RCLKPin");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->RCLKPin = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Frequency");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int64 */
    entry->Frequency = VAL_LONG(childval);
  }
  childval = val_first_child_name(
      parentval,
      "InputClock");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->InputClock = VAL_ENUM(childval);
  }
  return res;
}
status_t build_to_priv_device_TimeControlInfo(
    val_value_t *parentval,
    struct devicepb_TimeControlInfo *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "PortInfoList");
  entry->PortInfoList_Len = 0;
  entry->PortInfoList = malloc(sizeof(*entry->PortInfoList));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->PortInfoList_Len = dlq_count(&childval->v.childQ);
    entry->PortInfoList = malloc((entry->PortInfoList_Len + 1) * sizeof(*entry->PortInfoList));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->PortInfoList[cnt] = malloc(sizeof(*(entry->PortInfoList[cnt])));
      res = build_to_priv_device_TimeControlPortInfoEntry(
          listval,
          entry->PortInfoList[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  childval = val_first_child_name(
      parentval,
      "SpeedFrequencyList");
  entry->SpeedFrequencyList_Len = 0;
  entry->SpeedFrequencyList = malloc(sizeof(*entry->SpeedFrequencyList));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->SpeedFrequencyList_Len = dlq_count(&childval->v.childQ);
    entry->SpeedFrequencyList = malloc((entry->SpeedFrequencyList_Len + 1) * sizeof(*entry->SpeedFrequencyList));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->SpeedFrequencyList[cnt] = malloc(sizeof(*(entry->SpeedFrequencyList[cnt])));
      res = build_to_priv_device_TimeControlSpeedFrequencyEntry(
          listval,
          entry->SpeedFrequencyList[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_device_Boundary(
    val_value_t *parentval,
    struct devicepb_Boundary *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Type");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->Type = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Max");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->Max = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Min");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->Min = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Lower");
  if (childval != NULL && childval->res == NO_ERR) {
    /* double */
    entry->Lower = VAL_DOUBLE(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Upper");
  if (childval != NULL && childval->res == NO_ERR) {
    /* double */
    entry->Upper = VAL_DOUBLE(childval);
  }
  return res;
}
status_t build_to_priv_device_BoundaryAll(
    val_value_t *parentval,
    struct devicepb_BoundaryAll *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VLAN");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->VLAN = malloc(sizeof(*(entry->VLAN)));
    res = build_to_priv_device_BoundaryVLAN(
        childval,
        entry->VLAN);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Access");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Access = malloc(sizeof(*(entry->Access)));
    res = build_to_priv_device_BoundaryAccess(
        childval,
        entry->Access);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "DDM");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->DDM = malloc(sizeof(*(entry->DDM)));
    res = build_to_priv_device_BoundaryDDM(
        childval,
        entry->DDM);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "ACL");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->ACL = malloc(sizeof(*(entry->ACL)));
    res = build_to_priv_device_BoundaryACL(
        childval,
        entry->ACL);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Log");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Log = malloc(sizeof(*(entry->Log)));
    res = build_to_priv_device_BoundaryLog(
        childval,
        entry->Log);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Mirroring");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Mirroring = malloc(sizeof(*(entry->Mirroring)));
    res = build_to_priv_device_BoundaryMirroring(
        childval,
        entry->Mirroring);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Trunk");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Trunk = malloc(sizeof(*(entry->Trunk)));
    res = build_to_priv_device_BoundaryTRUNK(
        childval,
        entry->Trunk);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "FDB");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->FDB = malloc(sizeof(*(entry->FDB)));
    res = build_to_priv_device_BoundaryFDB(
        childval,
        entry->FDB);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "QoS");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->QoS = malloc(sizeof(*(entry->QoS)));
    res = build_to_priv_device_BoundaryQoS(
        childval,
        entry->QoS);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Multicast");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Multicast = malloc(sizeof(*(entry->Multicast)));
    res = build_to_priv_device_BoundaryMulticast(
        childval,
        entry->Multicast);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "PoE");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->PoE = malloc(sizeof(*(entry->PoE)));
    res = build_to_priv_device_BoundaryPoE(
        childval,
        entry->PoE);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Files");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Files = malloc(sizeof(*(entry->Files)));
    res = build_to_priv_device_BoundaryFiles(
        childval,
        entry->Files);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "TimeRange");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->TimeRange = malloc(sizeof(*(entry->TimeRange)));
    res = build_to_priv_device_BoundaryTimeRange(
        childval,
        entry->TimeRange);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "DHCPServer");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->DHCPServer = malloc(sizeof(*(entry->DHCPServer)));
    res = build_to_priv_device_BoundaryDHCPServer(
        childval,
        entry->DHCPServer);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Monitor");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Monitor = malloc(sizeof(*(entry->Monitor)));
    res = build_to_priv_device_BoundaryMonitor(
        childval,
        entry->Monitor);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_BoundaryDHCPServer(
    val_value_t *parentval,
    struct devicepb_BoundaryDHCPServer *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "MACBased");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->MACBased = malloc(sizeof(*(entry->MACBased)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->MACBased);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_BoundaryVLAN(
    val_value_t *parentval,
    struct devicepb_BoundaryVLAN *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VlanID");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->VlanID = malloc(sizeof(*(entry->VlanID)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->VlanID);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "VlanFilter");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->VlanFilter = malloc(sizeof(*(entry->VlanFilter)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->VlanFilter);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "ProtocolBased");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->ProtocolBased = malloc(sizeof(*(entry->ProtocolBased)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->ProtocolBased);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "MACBased");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->MACBased = malloc(sizeof(*(entry->MACBased)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->MACBased);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "SubnetBased");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->SubnetBased = malloc(sizeof(*(entry->SubnetBased)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->SubnetBased);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "TPIDsRange");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->TPIDsRange = malloc(sizeof(*(entry->TPIDsRange)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->TPIDsRange);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "ProtocolClasses");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->ProtocolClasses = malloc(sizeof(*(entry->ProtocolClasses)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->ProtocolClasses);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "SelectiveQinQ");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->SelectiveQinQ = malloc(sizeof(*(entry->SelectiveQinQ)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->SelectiveQinQ);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Mapping");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Mapping = malloc(sizeof(*(entry->Mapping)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->Mapping);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_BoundaryDDM(
    val_value_t *parentval,
    struct devicepb_BoundaryDDM *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "DdmTemperature");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->DdmTemperature = malloc(sizeof(*(entry->DdmTemperature)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->DdmTemperature);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "DdmVoltage");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->DdmVoltage = malloc(sizeof(*(entry->DdmVoltage)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->DdmVoltage);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "DdmTxBias");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->DdmTxBias = malloc(sizeof(*(entry->DdmTxBias)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->DdmTxBias);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "DdmRxPower");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->DdmRxPower = malloc(sizeof(*(entry->DdmRxPower)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->DdmRxPower);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "DdmTxPower");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->DdmTxPower = malloc(sizeof(*(entry->DdmTxPower)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->DdmTxPower);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_BoundaryACL(
    val_value_t *parentval,
    struct devicepb_BoundaryACL *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "ACLs");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->ACLs = malloc(sizeof(*(entry->ACLs)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->ACLs);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "ACEs");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->ACEs = malloc(sizeof(*(entry->ACEs)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->ACEs);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Binding");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Binding = malloc(sizeof(*(entry->Binding)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->Binding);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Flow");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Flow = malloc(sizeof(*(entry->Flow)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->Flow);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "FlowRules");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->FlowRules = malloc(sizeof(*(entry->FlowRules)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->FlowRules);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Rules");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Rules = malloc(sizeof(*(entry->Rules)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->Rules);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_BoundaryLog(
    val_value_t *parentval,
    struct devicepb_BoundaryLog *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "LogRotateSize");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->LogRotateSize = malloc(sizeof(*(entry->LogRotateSize)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->LogRotateSize);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "LogRotateFileCount");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->LogRotateFileCount = malloc(sizeof(*(entry->LogRotateFileCount)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->LogRotateFileCount);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "LogTargetList");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->LogTargetList = malloc(sizeof(*(entry->LogTargetList)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->LogTargetList);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_BoundaryAccess(
    val_value_t *parentval,
    struct devicepb_BoundaryAccess *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Users");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Users = malloc(sizeof(*(entry->Users)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->Users);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "UsersAssociatedGroups");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->UsersAssociatedGroups = malloc(sizeof(*(entry->UsersAssociatedGroups)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->UsersAssociatedGroups);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Groups");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Groups = malloc(sizeof(*(entry->Groups)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->Groups);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "GroupsPattern");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->GroupsPattern = malloc(sizeof(*(entry->GroupsPattern)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->GroupsPattern);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Restrictions");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Restrictions = malloc(sizeof(*(entry->Restrictions)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->Restrictions);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Servers");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Servers = malloc(sizeof(*(entry->Servers)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->Servers);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_BoundaryMirroring(
    val_value_t *parentval,
    struct devicepb_BoundaryMirroring *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Session");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Session = malloc(sizeof(*(entry->Session)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->Session);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_BoundaryFDB(
    val_value_t *parentval,
    struct devicepb_BoundaryFDB *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "FDBSize");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->FDBSize = malloc(sizeof(*(entry->FDBSize)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->FDBSize);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "AgeTime");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->AgeTime = malloc(sizeof(*(entry->AgeTime)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->AgeTime);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "PortLearningLimit");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->PortLearningLimit = malloc(sizeof(*(entry->PortLearningLimit)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->PortLearningLimit);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "PortSecurityLearningLimit");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->PortSecurityLearningLimit = malloc(sizeof(*(entry->PortSecurityLearningLimit)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->PortSecurityLearningLimit);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "ForwardLimit");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->ForwardLimit = malloc(sizeof(*(entry->ForwardLimit)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->ForwardLimit);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "DropLimit");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->DropLimit = malloc(sizeof(*(entry->DropLimit)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->DropLimit);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_BoundaryTRUNK(
    val_value_t *parentval,
    struct devicepb_BoundaryTRUNK *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "IDRange");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->IDRange = malloc(sizeof(*(entry->IDRange)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->IDRange);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "PriorityRange");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->PriorityRange = malloc(sizeof(*(entry->PriorityRange)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->PriorityRange);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "MemberRange");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->MemberRange = malloc(sizeof(*(entry->MemberRange)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->MemberRange);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_BoundaryMulticast(
    val_value_t *parentval,
    struct devicepb_BoundaryMulticast *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VIDXRange");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->VIDXRange = malloc(sizeof(*(entry->VIDXRange)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->VIDXRange);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "StaticEntries");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->StaticEntries = malloc(sizeof(*(entry->StaticEntries)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->StaticEntries);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "DynamicEntries");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->DynamicEntries = malloc(sizeof(*(entry->DynamicEntries)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->DynamicEntries);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_BoundaryQoS(
    val_value_t *parentval,
    struct devicepb_BoundaryQoS *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "QueueListRange");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->QueueListRange = malloc(sizeof(*(entry->QueueListRange)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->QueueListRange);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "CoSRange");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->CoSRange = malloc(sizeof(*(entry->CoSRange)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->CoSRange);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "DSCPRange");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->DSCPRange = malloc(sizeof(*(entry->DSCPRange)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->DSCPRange);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "WRRRange");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->WRRRange = malloc(sizeof(*(entry->WRRRange)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->WRRRange);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_BoundaryPoE(
    val_value_t *parentval,
    struct devicepb_BoundaryPoE *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "BudgetRange");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->BudgetRange = malloc(sizeof(*(entry->BudgetRange)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->BudgetRange);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_BoundaryFiles(
    val_value_t *parentval,
    struct devicepb_BoundaryFiles *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "CertificatedRange");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->CertificatedRange = malloc(sizeof(*(entry->CertificatedRange)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->CertificatedRange);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_BoundaryTimeRange(
    val_value_t *parentval,
    struct devicepb_BoundaryTimeRange *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "EntryRange");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->EntryRange = malloc(sizeof(*(entry->EntryRange)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->EntryRange);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_BoundaryMonitor(
    val_value_t *parentval,
    struct devicepb_BoundaryMonitor *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Temperature");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Temperature = malloc(sizeof(*(entry->Temperature)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->Temperature);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Power");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Power = malloc(sizeof(*(entry->Power)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->Power);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Cpu");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Cpu = malloc(sizeof(*(entry->Cpu)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->Cpu);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Memory");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Memory = malloc(sizeof(*(entry->Memory)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->Memory);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "PowerRedundantConsumption");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->PowerRedundantConsumption = malloc(sizeof(*(entry->PowerRedundantConsumption)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->PowerRedundantConsumption);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "PowerRedundantTemperature");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->PowerRedundantTemperature = malloc(sizeof(*(entry->PowerRedundantTemperature)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->PowerRedundantTemperature);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "PowerRedundantVoltage");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->PowerRedundantVoltage = malloc(sizeof(*(entry->PowerRedundantVoltage)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->PowerRedundantVoltage);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "PowerRedundantCurrent");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->PowerRedundantCurrent = malloc(sizeof(*(entry->PowerRedundantCurrent)));
    res = build_to_priv_device_Boundary(
        childval,
        entry->PowerRedundantCurrent);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_FunctionControlAll(
    val_value_t *parentval,
    struct devicepb_FunctionControlAll *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "VLAN");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->VLAN = malloc(sizeof(*(entry->VLAN)));
    res = build_to_priv_device_FunctionControlVLAN(
        childval,
        entry->VLAN);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Acl");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Acl = malloc(sizeof(*(entry->Acl)));
    res = build_to_priv_device_FunctionControlACL(
        childval,
        entry->Acl);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Mirroring");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->Mirroring = malloc(sizeof(*(entry->Mirroring)));
    res = build_to_priv_device_FunctionControlMirroring(
        childval,
        entry->Mirroring);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "FDB");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->FDB = malloc(sizeof(*(entry->FDB)));
    res = build_to_priv_device_FunctionControlFDB(
        childval,
        entry->FDB);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_device_FunctionControlVLAN(
    val_value_t *parentval,
    struct devicepb_FunctionControlVLAN *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Voice");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->Voice = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "SelectiveQinq");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->SelectiveQinq = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MACBased");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->MACBased = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "SubnetBased");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->SubnetBased = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "ProtocolBased");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->ProtocolBased = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Translation");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->Translation = VAL_BOOL(childval);
  }
  return res;
}
status_t build_to_priv_device_FunctionControlACL(
    val_value_t *parentval,
    struct devicepb_FunctionControlACL *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "TimeRange");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->TimeRange = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Binding");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->Binding = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "FlowMirroring");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->FlowMirroring = VAL_BOOL(childval);
  }
  return res;
}
status_t build_to_priv_device_FunctionControlMirroring(
    val_value_t *parentval,
    struct devicepb_FunctionControlMirroring *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "RSPAN");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->RSPAN = VAL_BOOL(childval);
  }
  return res;
}
status_t build_to_priv_device_FunctionControlFDB(
    val_value_t *parentval,
    struct devicepb_FunctionControlFDB *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "PortSecurity");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->PortSecurity = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "LearningLimit");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->LearningLimit = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Forward");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->Forward = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Drop");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->Drop = VAL_BOOL(childval);
  }
  return res;
}
status_t build_to_priv_device_PathAll(
    val_value_t *parentval,
    struct devicepb_PathAll *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "LogRamDisk");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->LogRamDisk = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "LogFlash");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->LogFlash = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "ConfigDefault");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->ConfigDefault = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "ConfigSaved");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->ConfigSaved = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "User");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->User = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "IPTables");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->IPTables = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "CoreReboot");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->CoreReboot = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "WarmStart");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->WarmStart = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "VlanMgmt");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->VlanMgmt = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "TimeCfg");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->TimeCfg = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "BootReady");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->BootReady = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "IPv6LinkLocal");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->IPv6LinkLocal = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "TimeZone");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->TimeZone = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Resolv");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Resolv = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "DropbearProc");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->DropbearProc = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "TelnetProc");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->TelnetProc = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "FTPProc");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->FTPProc = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "LocalUser");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->LocalUser = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Certificates");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Certificates = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "OpenSSLCertificates");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->OpenSSLCertificates = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "SNMPdCertificates");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->SNMPdCertificates = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "SNMPdCertificatesKey");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->SNMPdCertificatesKey = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "NetCfg");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->NetCfg = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "IPv4Script");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->IPv4Script = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "IPv6Script");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->IPv6Script = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "LastSaveTime");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->LastSaveTime = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Image");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Image = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "AltVersion");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->AltVersion = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "AltBuildDateTime");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->AltBuildDateTime = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Version");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Version = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "BuildDateTime");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->BuildDateTime = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "DhcpServerDnsmasqLeasePath");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->DhcpServerDnsmasqLeasePath = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "DhcpServerDnsmasqCfgPath");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->DhcpServerDnsmasqCfgPath = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "DhcpServerPortBasedInfo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->DhcpServerPortBasedInfo = VAL_STRING(childval);
  }
  return res;
}
status_t build_to_priv_device_InterfaceIdentify(
    val_value_t *parentval,
    struct devicepb_InterfaceIdentify *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Type");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->Type = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "DeviceID");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->DeviceID = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "PortNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->PortNo = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "LAGNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->LAGNo = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "VlanID");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->VlanID = VAL_INT(childval);
  }
  return res;
}
status_t build_to_priv_device_Info(
    val_value_t *parentval,
    struct devicepb_Info *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Model");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Model = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MACAddr");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->MACAddr = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MACAddrFactory");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->MACAddrFactory = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "SerialNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->SerialNo = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Vendor");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Vendor = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "AltBuildDateTime");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->AltBuildDateTime = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "CurrentBuildDateTime");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->CurrentBuildDateTime = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "AltSwVersion");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->AltSwVersion = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "CurrentSwVersion");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->CurrentSwVersion = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "HwVersion");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->HwVersion = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "CurrentImage");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->CurrentImage = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Board");
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Board = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "Layer");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->Layer = VAL_ENUM(childval);
  }
  return res;
}
status_t build_to_priv_device_PortList(
    val_value_t *parentval,
    struct devicepb_PortList *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "List");
  entry->List_Len = 0;
  entry->List = malloc(sizeof(*entry->List));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->List_Len = dlq_count(&childval->v.childQ);
    entry->List = malloc((entry->List_Len + 1) * sizeof(*entry->List));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->List[cnt] = malloc(sizeof(*(entry->List[cnt])));
      res = build_to_priv_device_InterfaceIdentify(
          listval,
          entry->List[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
