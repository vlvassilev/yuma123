
/*
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.13-0

  Combined SIL module
  module intri-vlan
  revision 2022-06-23
  namespace intri:intri-vlan
  organization Intrising Inc.

 */

#include <libxml/xmlstring.h>

#include "agt.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "intri-vlan-trans.h"
#include "intri-vlan.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "procdefs.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"

/* module static variables */
static ncx_module_t *intri_vlan_mod;
static obj_template_t *intri_vlan_GetConfig_obj;
static obj_template_t *intri_vlan_GetStatus_obj;
static obj_template_t *intri_vlan_GetManagementConfig_obj;
static obj_template_t *intri_vlan_UpdateManagementConfig_obj;
static obj_template_t *intri_vlan_GetVoiceConfig_obj;
static obj_template_t *intri_vlan_UpdateVoiceConfig_obj;
static obj_template_t *intri_vlan_GetFiltersConfig_obj;
static obj_template_t *intri_vlan_AddFilter_obj;
static obj_template_t *intri_vlan_UpdateFilter_obj;
static obj_template_t *intri_vlan_DeleteFilter_obj;
static obj_template_t *intri_vlan_GetPortsConfig_obj;
static obj_template_t *intri_vlan_UpdatePortsConfig_obj;
static obj_template_t *intri_vlan_GetMappingConfig_obj;
static obj_template_t *intri_vlan_AddMapping_obj;
static obj_template_t *intri_vlan_DeleteMapping_obj;
static obj_template_t *intri_vlan_UpdateMappingPortEntry_obj;
static obj_template_t *intri_vlan_GetSelectiveQinQConfig_obj;
static obj_template_t *intri_vlan_AddSelectiveQinQ_obj;
static obj_template_t *intri_vlan_UpdateSelectiveQinQ_obj;
static obj_template_t *intri_vlan_DeleteSelectiveQinQ_obj;
static obj_template_t *intri_vlan_GetProtocolBasedConfig_obj;
static obj_template_t *intri_vlan_AddProtocolBasedGroup_obj;
static obj_template_t *intri_vlan_UpdateProtocolBasedGroup_obj;
static obj_template_t *intri_vlan_DeleteProtocolBasedGroup_obj;
static obj_template_t *intri_vlan_AddProtocolBasedGroupMember_obj;
static obj_template_t *intri_vlan_UpdateProtocolBasedGroupMember_obj;
static obj_template_t *intri_vlan_DeleteProtocolBasedGroupMember_obj;
static obj_template_t *intri_vlan_GetMACBasedConfig_obj;
static obj_template_t *intri_vlan_AddMACBasedGroup_obj;
static obj_template_t *intri_vlan_UpdateMACBasedGroup_obj;
static obj_template_t *intri_vlan_DeleteMACBasedGroup_obj;
static obj_template_t *intri_vlan_AddMACBasedGroupMember_obj;
static obj_template_t *intri_vlan_UpdateMACBasedGroupMember_obj;
static obj_template_t *intri_vlan_DeleteMACBasedGroupMember_obj;
static obj_template_t *intri_vlan_GetSubnetBasedConfig_obj;
static obj_template_t *intri_vlan_AddSubnetBasedGroup_obj;
static obj_template_t *intri_vlan_UpdateSubnetBasedGroup_obj;
static obj_template_t *intri_vlan_DeleteSubnetBasedGroup_obj;
static obj_template_t *intri_vlan_AddSubnetBasedGroupMember_obj;
static obj_template_t *intri_vlan_UpdateSubnetBasedGroupMember_obj;
static obj_template_t *intri_vlan_DeleteSubnetBasedGroupMember_obj;
static obj_template_t *intri_vlan_GetManagementVlanPorts_obj;
static obj_template_t *intri_vlan_SetDefaultPortVlan_obj;
static obj_template_t *intri_vlan_ClearDefaultPortVlan_obj;
static obj_template_t *intri_vlan_UpdateVlanPortVlanStatus_obj;
static obj_template_t *intri_vlan_DeleteVlanPortVlanStatus_obj;

/* put your static variables here */

/********************************************************************
 * FUNCTION y_intri_vlan_init_static_vars
 *
 * initialize module static variables
 *
 ********************************************************************/
static void y_intri_vlan_init_static_vars(void) {
  intri_vlan_mod = NULL;
  intri_vlan_GetConfig_obj = NULL;
  intri_vlan_GetStatus_obj = NULL;
  intri_vlan_GetManagementConfig_obj = NULL;
  intri_vlan_UpdateManagementConfig_obj = NULL;
  intri_vlan_GetVoiceConfig_obj = NULL;
  intri_vlan_UpdateVoiceConfig_obj = NULL;
  intri_vlan_GetFiltersConfig_obj = NULL;
  intri_vlan_AddFilter_obj = NULL;
  intri_vlan_UpdateFilter_obj = NULL;
  intri_vlan_DeleteFilter_obj = NULL;
  intri_vlan_GetPortsConfig_obj = NULL;
  intri_vlan_UpdatePortsConfig_obj = NULL;
  intri_vlan_GetMappingConfig_obj = NULL;
  intri_vlan_AddMapping_obj = NULL;
  intri_vlan_DeleteMapping_obj = NULL;
  intri_vlan_UpdateMappingPortEntry_obj = NULL;
  intri_vlan_GetSelectiveQinQConfig_obj = NULL;
  intri_vlan_AddSelectiveQinQ_obj = NULL;
  intri_vlan_UpdateSelectiveQinQ_obj = NULL;
  intri_vlan_DeleteSelectiveQinQ_obj = NULL;
  intri_vlan_GetProtocolBasedConfig_obj = NULL;
  intri_vlan_AddProtocolBasedGroup_obj = NULL;
  intri_vlan_UpdateProtocolBasedGroup_obj = NULL;
  intri_vlan_DeleteProtocolBasedGroup_obj = NULL;
  intri_vlan_AddProtocolBasedGroupMember_obj = NULL;
  intri_vlan_UpdateProtocolBasedGroupMember_obj = NULL;
  intri_vlan_DeleteProtocolBasedGroupMember_obj = NULL;
  intri_vlan_GetMACBasedConfig_obj = NULL;
  intri_vlan_AddMACBasedGroup_obj = NULL;
  intri_vlan_UpdateMACBasedGroup_obj = NULL;
  intri_vlan_DeleteMACBasedGroup_obj = NULL;
  intri_vlan_AddMACBasedGroupMember_obj = NULL;
  intri_vlan_UpdateMACBasedGroupMember_obj = NULL;
  intri_vlan_DeleteMACBasedGroupMember_obj = NULL;
  intri_vlan_GetSubnetBasedConfig_obj = NULL;
  intri_vlan_AddSubnetBasedGroup_obj = NULL;
  intri_vlan_UpdateSubnetBasedGroup_obj = NULL;
  intri_vlan_DeleteSubnetBasedGroup_obj = NULL;
  intri_vlan_AddSubnetBasedGroupMember_obj = NULL;
  intri_vlan_UpdateSubnetBasedGroupMember_obj = NULL;
  intri_vlan_DeleteSubnetBasedGroupMember_obj = NULL;
  intri_vlan_GetManagementVlanPorts_obj = NULL;
  intri_vlan_SetDefaultPortVlan_obj = NULL;
  intri_vlan_ClearDefaultPortVlan_obj = NULL;
  intri_vlan_UpdateVlanPortVlanStatus_obj = NULL;
  intri_vlan_DeleteVlanPortVlanStatus_obj = NULL;

  /* init your static variables here */

} /* y_intri_vlan_init_static_vars */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetConfig_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetConfig_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_GetConfig_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetConfig_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_GetConfig_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetStatus_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetStatus_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *Used_val;
  const xmlChar *Used;

  Used_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Used);
  if (Used_val != NULL && Used_val->res == NO_ERR) {
    Used = VAL_ENUM_NAME(Used_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_GetStatus_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetStatus_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetStatus_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *Used_val;
  const xmlChar *Used;

  Used_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Used);
  if (Used_val != NULL && Used_val->res == NO_ERR) {
    Used = VAL_ENUM_NAME(Used_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_GetStatus_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetManagementConfig_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetManagementConfig_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_GetManagementConfig_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetManagementConfig_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetManagementConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_GetManagementConfig_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateManagementConfig_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateManagementConfig_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *ManagementVlanID_val;
  int32 ManagementVlanID;

  ManagementVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_ManagementVlanID);
  if (ManagementVlanID_val != NULL && ManagementVlanID_val->res == NO_ERR) {
    ManagementVlanID = VAL_INT(ManagementVlanID_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_UpdateManagementConfig_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateManagementConfig_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateManagementConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *ManagementVlanID_val;
  int32 ManagementVlanID;

  ManagementVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_ManagementVlanID);
  if (ManagementVlanID_val != NULL && ManagementVlanID_val->res == NO_ERR) {
    ManagementVlanID = VAL_INT(ManagementVlanID_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_UpdateManagementConfig_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetVoiceConfig_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetVoiceConfig_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_GetVoiceConfig_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetVoiceConfig_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetVoiceConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_GetVoiceConfig_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateVoiceConfig_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateVoiceConfig_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *Prio_val;
  int32 Prio;
  val_value_t *SignalPrio_val;
  int32 SignalPrio;
  val_value_t *DSCP_val;
  int32 DSCP;
  val_value_t *SignalDSCP_val;
  int32 SignalDSCP;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  Prio_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Prio);
  if (Prio_val != NULL && Prio_val->res == NO_ERR) {
    Prio = VAL_INT(Prio_val);
  }

  SignalPrio_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_SignalPrio);
  if (SignalPrio_val != NULL && SignalPrio_val->res == NO_ERR) {
    SignalPrio = VAL_INT(SignalPrio_val);
  }

  DSCP_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_DSCP);
  if (DSCP_val != NULL && DSCP_val->res == NO_ERR) {
    DSCP = VAL_INT(DSCP_val);
  }

  SignalDSCP_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_SignalDSCP);
  if (SignalDSCP_val != NULL && SignalDSCP_val->res == NO_ERR) {
    SignalDSCP = VAL_INT(SignalDSCP_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_UpdateVoiceConfig_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateVoiceConfig_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateVoiceConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *Prio_val;
  int32 Prio;
  val_value_t *SignalPrio_val;
  int32 SignalPrio;
  val_value_t *DSCP_val;
  int32 DSCP;
  val_value_t *SignalDSCP_val;
  int32 SignalDSCP;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  Prio_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Prio);
  if (Prio_val != NULL && Prio_val->res == NO_ERR) {
    Prio = VAL_INT(Prio_val);
  }

  SignalPrio_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_SignalPrio);
  if (SignalPrio_val != NULL && SignalPrio_val->res == NO_ERR) {
    SignalPrio = VAL_INT(SignalPrio_val);
  }

  DSCP_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_DSCP);
  if (DSCP_val != NULL && DSCP_val->res == NO_ERR) {
    DSCP = VAL_INT(DSCP_val);
  }

  SignalDSCP_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_SignalDSCP);
  if (SignalDSCP_val != NULL && SignalDSCP_val->res == NO_ERR) {
    SignalDSCP = VAL_INT(SignalDSCP_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_UpdateVoiceConfig_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetFiltersConfig_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetFiltersConfig_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_GetFiltersConfig_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetFiltersConfig_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetFiltersConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_GetFiltersConfig_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddFilter_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddFilter_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *Enabled_val;
  boolean Enabled;
  val_value_t *Name_val;
  const xmlChar *Name;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  Enabled_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Enabled);
  if (Enabled_val != NULL && Enabled_val->res == NO_ERR) {
    Enabled = VAL_BOOL(Enabled_val);
  }

  Name_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Name);
  if (Name_val != NULL && Name_val->res == NO_ERR) {
    Name = VAL_STRING(Name_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_AddFilter_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddFilter_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddFilter_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *Enabled_val;
  boolean Enabled;
  val_value_t *Name_val;
  const xmlChar *Name;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  Enabled_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Enabled);
  if (Enabled_val != NULL && Enabled_val->res == NO_ERR) {
    Enabled = VAL_BOOL(Enabled_val);
  }

  Name_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Name);
  if (Name_val != NULL && Name_val->res == NO_ERR) {
    Name = VAL_STRING(Name_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_AddFilter_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateFilter_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateFilter_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *Enabled_val;
  boolean Enabled;
  val_value_t *Name_val;
  const xmlChar *Name;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  Enabled_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Enabled);
  if (Enabled_val != NULL && Enabled_val->res == NO_ERR) {
    Enabled = VAL_BOOL(Enabled_val);
  }

  Name_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Name);
  if (Name_val != NULL && Name_val->res == NO_ERR) {
    Name = VAL_STRING(Name_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_UpdateFilter_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateFilter_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateFilter_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *Enabled_val;
  boolean Enabled;
  val_value_t *Name_val;
  const xmlChar *Name;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  Enabled_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Enabled);
  if (Enabled_val != NULL && Enabled_val->res == NO_ERR) {
    Enabled = VAL_BOOL(Enabled_val);
  }

  Name_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Name);
  if (Name_val != NULL && Name_val->res == NO_ERR) {
    Name = VAL_STRING(Name_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_UpdateFilter_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteFilter_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteFilter_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *Enabled_val;
  boolean Enabled;
  val_value_t *Name_val;
  const xmlChar *Name;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  Enabled_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Enabled);
  if (Enabled_val != NULL && Enabled_val->res == NO_ERR) {
    Enabled = VAL_BOOL(Enabled_val);
  }

  Name_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Name);
  if (Name_val != NULL && Name_val->res == NO_ERR) {
    Name = VAL_STRING(Name_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_DeleteFilter_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteFilter_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteFilter_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *Enabled_val;
  boolean Enabled;
  val_value_t *Name_val;
  const xmlChar *Name;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  Enabled_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Enabled);
  if (Enabled_val != NULL && Enabled_val->res == NO_ERR) {
    Enabled = VAL_BOOL(Enabled_val);
  }

  Name_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Name);
  if (Name_val != NULL && Name_val->res == NO_ERR) {
    Name = VAL_STRING(Name_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_DeleteFilter_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetPortsConfig_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetPortsConfig_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_GetPortsConfig_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetPortsConfig_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetPortsConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_GetPortsConfig_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdatePortsConfig_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdatePortsConfig_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *List_val;
  y_intri_vlan_T_intri_vlan_UpdatePortsConfig_input_List List;

  List_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_List);
  if (List_val != NULL && List_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)List;
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_UpdatePortsConfig_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdatePortsConfig_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdatePortsConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *List_val;
  y_intri_vlan_T_intri_vlan_UpdatePortsConfig_input_List List;

  List_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_List);
  if (List_val != NULL && List_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)List;
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_UpdatePortsConfig_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetMappingConfig_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetMappingConfig_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_GetMappingConfig_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetMappingConfig_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetMappingConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_GetMappingConfig_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddMapping_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddMapping_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *SourceVlanID_val;
  int32 SourceVlanID;
  val_value_t *TranslatedVlanID_val;
  int32 TranslatedVlanID;

  SourceVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_SourceVlanID);
  if (SourceVlanID_val != NULL && SourceVlanID_val->res == NO_ERR) {
    SourceVlanID = VAL_INT(SourceVlanID_val);
  }

  TranslatedVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_TranslatedVlanID);
  if (TranslatedVlanID_val != NULL && TranslatedVlanID_val->res == NO_ERR) {
    TranslatedVlanID = VAL_INT(TranslatedVlanID_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_AddMapping_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddMapping_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddMapping_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *SourceVlanID_val;
  int32 SourceVlanID;
  val_value_t *TranslatedVlanID_val;
  int32 TranslatedVlanID;

  SourceVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_SourceVlanID);
  if (SourceVlanID_val != NULL && SourceVlanID_val->res == NO_ERR) {
    SourceVlanID = VAL_INT(SourceVlanID_val);
  }

  TranslatedVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_TranslatedVlanID);
  if (TranslatedVlanID_val != NULL && TranslatedVlanID_val->res == NO_ERR) {
    TranslatedVlanID = VAL_INT(TranslatedVlanID_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_AddMapping_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteMapping_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteMapping_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *SourceVlanID_val;
  int32 SourceVlanID;
  val_value_t *TranslatedVlanID_val;
  int32 TranslatedVlanID;

  SourceVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_SourceVlanID);
  if (SourceVlanID_val != NULL && SourceVlanID_val->res == NO_ERR) {
    SourceVlanID = VAL_INT(SourceVlanID_val);
  }

  TranslatedVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_TranslatedVlanID);
  if (TranslatedVlanID_val != NULL && TranslatedVlanID_val->res == NO_ERR) {
    TranslatedVlanID = VAL_INT(TranslatedVlanID_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_DeleteMapping_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteMapping_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteMapping_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *SourceVlanID_val;
  int32 SourceVlanID;
  val_value_t *TranslatedVlanID_val;
  int32 TranslatedVlanID;

  SourceVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_SourceVlanID);
  if (SourceVlanID_val != NULL && SourceVlanID_val->res == NO_ERR) {
    SourceVlanID = VAL_INT(SourceVlanID_val);
  }

  TranslatedVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_TranslatedVlanID);
  if (TranslatedVlanID_val != NULL && TranslatedVlanID_val->res == NO_ERR) {
    TranslatedVlanID = VAL_INT(TranslatedVlanID_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_DeleteMapping_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateMappingPortEntry_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateMappingPortEntry_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *IdentifyNo_val;
  y_intri_vlan_T_intri_vlan_UpdateMappingPortEntry_input_IdentifyNo IdentifyNo;
  val_value_t *Enabled_val;
  boolean Enabled;

  IdentifyNo_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyNo);
  if (IdentifyNo_val != NULL && IdentifyNo_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyNo;
  }

  Enabled_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Enabled);
  if (Enabled_val != NULL && Enabled_val->res == NO_ERR) {
    Enabled = VAL_BOOL(Enabled_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_UpdateMappingPortEntry_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateMappingPortEntry_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateMappingPortEntry_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *IdentifyNo_val;
  y_intri_vlan_T_intri_vlan_UpdateMappingPortEntry_input_IdentifyNo IdentifyNo;
  val_value_t *Enabled_val;
  boolean Enabled;

  IdentifyNo_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyNo);
  if (IdentifyNo_val != NULL && IdentifyNo_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyNo;
  }

  Enabled_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Enabled);
  if (Enabled_val != NULL && Enabled_val->res == NO_ERR) {
    Enabled = VAL_BOOL(Enabled_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_UpdateMappingPortEntry_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetSelectiveQinQConfig_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetSelectiveQinQConfig_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_GetSelectiveQinQConfig_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetSelectiveQinQConfig_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetSelectiveQinQConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_GetSelectiveQinQConfig_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddSelectiveQinQ_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddSelectiveQinQ_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *SourceVlanID_val;
  int32 SourceVlanID;
  val_value_t *TranslatedVlanID_val;
  int32 TranslatedVlanID;

  SourceVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_SourceVlanID);
  if (SourceVlanID_val != NULL && SourceVlanID_val->res == NO_ERR) {
    SourceVlanID = VAL_INT(SourceVlanID_val);
  }

  TranslatedVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_TranslatedVlanID);
  if (TranslatedVlanID_val != NULL && TranslatedVlanID_val->res == NO_ERR) {
    TranslatedVlanID = VAL_INT(TranslatedVlanID_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_AddSelectiveQinQ_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddSelectiveQinQ_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddSelectiveQinQ_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *SourceVlanID_val;
  int32 SourceVlanID;
  val_value_t *TranslatedVlanID_val;
  int32 TranslatedVlanID;

  SourceVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_SourceVlanID);
  if (SourceVlanID_val != NULL && SourceVlanID_val->res == NO_ERR) {
    SourceVlanID = VAL_INT(SourceVlanID_val);
  }

  TranslatedVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_TranslatedVlanID);
  if (TranslatedVlanID_val != NULL && TranslatedVlanID_val->res == NO_ERR) {
    TranslatedVlanID = VAL_INT(TranslatedVlanID_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_AddSelectiveQinQ_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateSelectiveQinQ_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateSelectiveQinQ_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *SourceVlanID_val;
  int32 SourceVlanID;
  val_value_t *TranslatedVlanID_val;
  int32 TranslatedVlanID;

  SourceVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_SourceVlanID);
  if (SourceVlanID_val != NULL && SourceVlanID_val->res == NO_ERR) {
    SourceVlanID = VAL_INT(SourceVlanID_val);
  }

  TranslatedVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_TranslatedVlanID);
  if (TranslatedVlanID_val != NULL && TranslatedVlanID_val->res == NO_ERR) {
    TranslatedVlanID = VAL_INT(TranslatedVlanID_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_UpdateSelectiveQinQ_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateSelectiveQinQ_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateSelectiveQinQ_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *SourceVlanID_val;
  int32 SourceVlanID;
  val_value_t *TranslatedVlanID_val;
  int32 TranslatedVlanID;

  SourceVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_SourceVlanID);
  if (SourceVlanID_val != NULL && SourceVlanID_val->res == NO_ERR) {
    SourceVlanID = VAL_INT(SourceVlanID_val);
  }

  TranslatedVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_TranslatedVlanID);
  if (TranslatedVlanID_val != NULL && TranslatedVlanID_val->res == NO_ERR) {
    TranslatedVlanID = VAL_INT(TranslatedVlanID_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_UpdateSelectiveQinQ_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteSelectiveQinQ_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteSelectiveQinQ_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *SourceVlanID_val;
  int32 SourceVlanID;
  val_value_t *TranslatedVlanID_val;
  int32 TranslatedVlanID;

  SourceVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_SourceVlanID);
  if (SourceVlanID_val != NULL && SourceVlanID_val->res == NO_ERR) {
    SourceVlanID = VAL_INT(SourceVlanID_val);
  }

  TranslatedVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_TranslatedVlanID);
  if (TranslatedVlanID_val != NULL && TranslatedVlanID_val->res == NO_ERR) {
    TranslatedVlanID = VAL_INT(TranslatedVlanID_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_DeleteSelectiveQinQ_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteSelectiveQinQ_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteSelectiveQinQ_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *SourceVlanID_val;
  int32 SourceVlanID;
  val_value_t *TranslatedVlanID_val;
  int32 TranslatedVlanID;

  SourceVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_SourceVlanID);
  if (SourceVlanID_val != NULL && SourceVlanID_val->res == NO_ERR) {
    SourceVlanID = VAL_INT(SourceVlanID_val);
  }

  TranslatedVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_TranslatedVlanID);
  if (TranslatedVlanID_val != NULL && TranslatedVlanID_val->res == NO_ERR) {
    TranslatedVlanID = VAL_INT(TranslatedVlanID_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_DeleteSelectiveQinQ_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetProtocolBasedConfig_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetProtocolBasedConfig_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_GetProtocolBasedConfig_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetProtocolBasedConfig_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetProtocolBasedConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_GetProtocolBasedConfig_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddProtocolBasedGroup_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddProtocolBasedGroup_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *Encapsulation_val;
  const xmlChar *Encapsulation;
  val_value_t *Protocol_val;
  const xmlChar *Protocol;

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  Encapsulation_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Encapsulation);
  if (Encapsulation_val != NULL && Encapsulation_val->res == NO_ERR) {
    Encapsulation = VAL_ENUM_NAME(Encapsulation_val);
  }

  Protocol_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Protocol);
  if (Protocol_val != NULL && Protocol_val->res == NO_ERR) {
    Protocol = VAL_STRING(Protocol_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_AddProtocolBasedGroup_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddProtocolBasedGroup_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddProtocolBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *Encapsulation_val;
  const xmlChar *Encapsulation;
  val_value_t *Protocol_val;
  const xmlChar *Protocol;

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  Encapsulation_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Encapsulation);
  if (Encapsulation_val != NULL && Encapsulation_val->res == NO_ERR) {
    Encapsulation = VAL_ENUM_NAME(Encapsulation_val);
  }

  Protocol_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Protocol);
  if (Protocol_val != NULL && Protocol_val->res == NO_ERR) {
    Protocol = VAL_STRING(Protocol_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_AddProtocolBasedGroup_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateProtocolBasedGroup_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateProtocolBasedGroup_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *Encapsulation_val;
  const xmlChar *Encapsulation;
  val_value_t *Protocol_val;
  const xmlChar *Protocol;

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  Encapsulation_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Encapsulation);
  if (Encapsulation_val != NULL && Encapsulation_val->res == NO_ERR) {
    Encapsulation = VAL_ENUM_NAME(Encapsulation_val);
  }

  Protocol_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Protocol);
  if (Protocol_val != NULL && Protocol_val->res == NO_ERR) {
    Protocol = VAL_STRING(Protocol_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_UpdateProtocolBasedGroup_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateProtocolBasedGroup_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateProtocolBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *Encapsulation_val;
  const xmlChar *Encapsulation;
  val_value_t *Protocol_val;
  const xmlChar *Protocol;

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  Encapsulation_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Encapsulation);
  if (Encapsulation_val != NULL && Encapsulation_val->res == NO_ERR) {
    Encapsulation = VAL_ENUM_NAME(Encapsulation_val);
  }

  Protocol_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Protocol);
  if (Protocol_val != NULL && Protocol_val->res == NO_ERR) {
    Protocol = VAL_STRING(Protocol_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_UpdateProtocolBasedGroup_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteProtocolBasedGroup_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteProtocolBasedGroup_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *Encapsulation_val;
  const xmlChar *Encapsulation;
  val_value_t *Protocol_val;
  const xmlChar *Protocol;

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  Encapsulation_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Encapsulation);
  if (Encapsulation_val != NULL && Encapsulation_val->res == NO_ERR) {
    Encapsulation = VAL_ENUM_NAME(Encapsulation_val);
  }

  Protocol_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Protocol);
  if (Protocol_val != NULL && Protocol_val->res == NO_ERR) {
    Protocol = VAL_STRING(Protocol_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_DeleteProtocolBasedGroup_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteProtocolBasedGroup_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteProtocolBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *Encapsulation_val;
  const xmlChar *Encapsulation;
  val_value_t *Protocol_val;
  const xmlChar *Protocol;

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  Encapsulation_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Encapsulation);
  if (Encapsulation_val != NULL && Encapsulation_val->res == NO_ERR) {
    Encapsulation = VAL_ENUM_NAME(Encapsulation_val);
  }

  Protocol_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Protocol);
  if (Protocol_val != NULL && Protocol_val->res == NO_ERR) {
    Protocol = VAL_STRING(Protocol_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_DeleteProtocolBasedGroup_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddProtocolBasedGroupMember_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddProtocolBasedGroupMember_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_AddProtocolBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_AddProtocolBasedGroupMember_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddProtocolBasedGroupMember_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddProtocolBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_AddProtocolBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_AddProtocolBasedGroupMember_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateProtocolBasedGroupMember_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateProtocolBasedGroupMember_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_UpdateProtocolBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_UpdateProtocolBasedGroupMember_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateProtocolBasedGroupMember_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateProtocolBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_UpdateProtocolBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_UpdateProtocolBasedGroupMember_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteProtocolBasedGroupMember_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteProtocolBasedGroupMember_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_DeleteProtocolBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_DeleteProtocolBasedGroupMember_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteProtocolBasedGroupMember_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteProtocolBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_DeleteProtocolBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_DeleteProtocolBasedGroupMember_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetMACBasedConfig_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetMACBasedConfig_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_GetMACBasedConfig_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetMACBasedConfig_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetMACBasedConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_GetMACBasedConfig_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddMACBasedGroup_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddMACBasedGroup_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *MACAddress_val;
  const xmlChar *MACAddress;
  val_value_t *MACAddressMask_val;
  const xmlChar *MACAddressMask;
  val_value_t *GroupID_val;
  int32 GroupID;

  MACAddress_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_MACAddress);
  if (MACAddress_val != NULL && MACAddress_val->res == NO_ERR) {
    MACAddress = VAL_STRING(MACAddress_val);
  }

  MACAddressMask_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_MACAddressMask);
  if (MACAddressMask_val != NULL && MACAddressMask_val->res == NO_ERR) {
    MACAddressMask = VAL_STRING(MACAddressMask_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_AddMACBasedGroup_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddMACBasedGroup_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddMACBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *MACAddress_val;
  const xmlChar *MACAddress;
  val_value_t *MACAddressMask_val;
  const xmlChar *MACAddressMask;
  val_value_t *GroupID_val;
  int32 GroupID;

  MACAddress_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_MACAddress);
  if (MACAddress_val != NULL && MACAddress_val->res == NO_ERR) {
    MACAddress = VAL_STRING(MACAddress_val);
  }

  MACAddressMask_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_MACAddressMask);
  if (MACAddressMask_val != NULL && MACAddressMask_val->res == NO_ERR) {
    MACAddressMask = VAL_STRING(MACAddressMask_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_AddMACBasedGroup_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateMACBasedGroup_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateMACBasedGroup_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *MACAddress_val;
  const xmlChar *MACAddress;
  val_value_t *MACAddressMask_val;
  const xmlChar *MACAddressMask;
  val_value_t *GroupID_val;
  int32 GroupID;

  MACAddress_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_MACAddress);
  if (MACAddress_val != NULL && MACAddress_val->res == NO_ERR) {
    MACAddress = VAL_STRING(MACAddress_val);
  }

  MACAddressMask_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_MACAddressMask);
  if (MACAddressMask_val != NULL && MACAddressMask_val->res == NO_ERR) {
    MACAddressMask = VAL_STRING(MACAddressMask_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_UpdateMACBasedGroup_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateMACBasedGroup_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateMACBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *MACAddress_val;
  const xmlChar *MACAddress;
  val_value_t *MACAddressMask_val;
  const xmlChar *MACAddressMask;
  val_value_t *GroupID_val;
  int32 GroupID;

  MACAddress_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_MACAddress);
  if (MACAddress_val != NULL && MACAddress_val->res == NO_ERR) {
    MACAddress = VAL_STRING(MACAddress_val);
  }

  MACAddressMask_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_MACAddressMask);
  if (MACAddressMask_val != NULL && MACAddressMask_val->res == NO_ERR) {
    MACAddressMask = VAL_STRING(MACAddressMask_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_UpdateMACBasedGroup_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteMACBasedGroup_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteMACBasedGroup_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *MACAddress_val;
  const xmlChar *MACAddress;
  val_value_t *MACAddressMask_val;
  const xmlChar *MACAddressMask;
  val_value_t *GroupID_val;
  int32 GroupID;

  MACAddress_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_MACAddress);
  if (MACAddress_val != NULL && MACAddress_val->res == NO_ERR) {
    MACAddress = VAL_STRING(MACAddress_val);
  }

  MACAddressMask_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_MACAddressMask);
  if (MACAddressMask_val != NULL && MACAddressMask_val->res == NO_ERR) {
    MACAddressMask = VAL_STRING(MACAddressMask_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_DeleteMACBasedGroup_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteMACBasedGroup_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteMACBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *MACAddress_val;
  const xmlChar *MACAddress;
  val_value_t *MACAddressMask_val;
  const xmlChar *MACAddressMask;
  val_value_t *GroupID_val;
  int32 GroupID;

  MACAddress_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_MACAddress);
  if (MACAddress_val != NULL && MACAddress_val->res == NO_ERR) {
    MACAddress = VAL_STRING(MACAddress_val);
  }

  MACAddressMask_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_MACAddressMask);
  if (MACAddressMask_val != NULL && MACAddressMask_val->res == NO_ERR) {
    MACAddressMask = VAL_STRING(MACAddressMask_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_DeleteMACBasedGroup_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddMACBasedGroupMember_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddMACBasedGroupMember_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_AddMACBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_AddMACBasedGroupMember_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddMACBasedGroupMember_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddMACBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_AddMACBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_AddMACBasedGroupMember_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateMACBasedGroupMember_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateMACBasedGroupMember_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_UpdateMACBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_UpdateMACBasedGroupMember_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateMACBasedGroupMember_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateMACBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_UpdateMACBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_UpdateMACBasedGroupMember_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteMACBasedGroupMember_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteMACBasedGroupMember_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_DeleteMACBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_DeleteMACBasedGroupMember_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteMACBasedGroupMember_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteMACBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_DeleteMACBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_DeleteMACBasedGroupMember_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetSubnetBasedConfig_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetSubnetBasedConfig_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_GetSubnetBasedConfig_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetSubnetBasedConfig_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetSubnetBasedConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_GetSubnetBasedConfig_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddSubnetBasedGroup_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddSubnetBasedGroup_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *IPAddress_val;
  const xmlChar *IPAddress;
  val_value_t *IPAddressMask_val;
  const xmlChar *IPAddressMask;
  val_value_t *IPVersion_val;
  const xmlChar *IPVersion;
  val_value_t *GroupID_val;
  int32 GroupID;

  IPAddress_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPAddress);
  if (IPAddress_val != NULL && IPAddress_val->res == NO_ERR) {
    IPAddress = VAL_STRING(IPAddress_val);
  }

  IPAddressMask_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPAddressMask);
  if (IPAddressMask_val != NULL && IPAddressMask_val->res == NO_ERR) {
    IPAddressMask = VAL_STRING(IPAddressMask_val);
  }

  IPVersion_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPVersion);
  if (IPVersion_val != NULL && IPVersion_val->res == NO_ERR) {
    IPVersion = VAL_ENUM_NAME(IPVersion_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_AddSubnetBasedGroup_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddSubnetBasedGroup_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddSubnetBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *IPAddress_val;
  const xmlChar *IPAddress;
  val_value_t *IPAddressMask_val;
  const xmlChar *IPAddressMask;
  val_value_t *IPVersion_val;
  const xmlChar *IPVersion;
  val_value_t *GroupID_val;
  int32 GroupID;

  IPAddress_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPAddress);
  if (IPAddress_val != NULL && IPAddress_val->res == NO_ERR) {
    IPAddress = VAL_STRING(IPAddress_val);
  }

  IPAddressMask_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPAddressMask);
  if (IPAddressMask_val != NULL && IPAddressMask_val->res == NO_ERR) {
    IPAddressMask = VAL_STRING(IPAddressMask_val);
  }

  IPVersion_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPVersion);
  if (IPVersion_val != NULL && IPVersion_val->res == NO_ERR) {
    IPVersion = VAL_ENUM_NAME(IPVersion_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_AddSubnetBasedGroup_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateSubnetBasedGroup_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateSubnetBasedGroup_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *IPAddress_val;
  const xmlChar *IPAddress;
  val_value_t *IPAddressMask_val;
  const xmlChar *IPAddressMask;
  val_value_t *IPVersion_val;
  const xmlChar *IPVersion;
  val_value_t *GroupID_val;
  int32 GroupID;

  IPAddress_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPAddress);
  if (IPAddress_val != NULL && IPAddress_val->res == NO_ERR) {
    IPAddress = VAL_STRING(IPAddress_val);
  }

  IPAddressMask_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPAddressMask);
  if (IPAddressMask_val != NULL && IPAddressMask_val->res == NO_ERR) {
    IPAddressMask = VAL_STRING(IPAddressMask_val);
  }

  IPVersion_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPVersion);
  if (IPVersion_val != NULL && IPVersion_val->res == NO_ERR) {
    IPVersion = VAL_ENUM_NAME(IPVersion_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_UpdateSubnetBasedGroup_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateSubnetBasedGroup_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateSubnetBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *IPAddress_val;
  const xmlChar *IPAddress;
  val_value_t *IPAddressMask_val;
  const xmlChar *IPAddressMask;
  val_value_t *IPVersion_val;
  const xmlChar *IPVersion;
  val_value_t *GroupID_val;
  int32 GroupID;

  IPAddress_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPAddress);
  if (IPAddress_val != NULL && IPAddress_val->res == NO_ERR) {
    IPAddress = VAL_STRING(IPAddress_val);
  }

  IPAddressMask_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPAddressMask);
  if (IPAddressMask_val != NULL && IPAddressMask_val->res == NO_ERR) {
    IPAddressMask = VAL_STRING(IPAddressMask_val);
  }

  IPVersion_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPVersion);
  if (IPVersion_val != NULL && IPVersion_val->res == NO_ERR) {
    IPVersion = VAL_ENUM_NAME(IPVersion_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_UpdateSubnetBasedGroup_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteSubnetBasedGroup_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteSubnetBasedGroup_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *IPAddress_val;
  const xmlChar *IPAddress;
  val_value_t *IPAddressMask_val;
  const xmlChar *IPAddressMask;
  val_value_t *IPVersion_val;
  const xmlChar *IPVersion;
  val_value_t *GroupID_val;
  int32 GroupID;

  IPAddress_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPAddress);
  if (IPAddress_val != NULL && IPAddress_val->res == NO_ERR) {
    IPAddress = VAL_STRING(IPAddress_val);
  }

  IPAddressMask_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPAddressMask);
  if (IPAddressMask_val != NULL && IPAddressMask_val->res == NO_ERR) {
    IPAddressMask = VAL_STRING(IPAddressMask_val);
  }

  IPVersion_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPVersion);
  if (IPVersion_val != NULL && IPVersion_val->res == NO_ERR) {
    IPVersion = VAL_ENUM_NAME(IPVersion_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_DeleteSubnetBasedGroup_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteSubnetBasedGroup_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteSubnetBasedGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *IPAddress_val;
  const xmlChar *IPAddress;
  val_value_t *IPAddressMask_val;
  const xmlChar *IPAddressMask;
  val_value_t *IPVersion_val;
  const xmlChar *IPVersion;
  val_value_t *GroupID_val;
  int32 GroupID;

  IPAddress_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPAddress);
  if (IPAddress_val != NULL && IPAddress_val->res == NO_ERR) {
    IPAddress = VAL_STRING(IPAddress_val);
  }

  IPAddressMask_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPAddressMask);
  if (IPAddressMask_val != NULL && IPAddressMask_val->res == NO_ERR) {
    IPAddressMask = VAL_STRING(IPAddressMask_val);
  }

  IPVersion_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IPVersion);
  if (IPVersion_val != NULL && IPVersion_val->res == NO_ERR) {
    IPVersion = VAL_ENUM_NAME(IPVersion_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_DeleteSubnetBasedGroup_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddSubnetBasedGroupMember_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddSubnetBasedGroupMember_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_AddSubnetBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_AddSubnetBasedGroupMember_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_AddSubnetBasedGroupMember_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_AddSubnetBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_AddSubnetBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_AddSubnetBasedGroupMember_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateSubnetBasedGroupMember_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateSubnetBasedGroupMember_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_UpdateSubnetBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_UpdateSubnetBasedGroupMember_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateSubnetBasedGroupMember_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateSubnetBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_UpdateSubnetBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_UpdateSubnetBasedGroupMember_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteSubnetBasedGroupMember_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteSubnetBasedGroupMember_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_DeleteSubnetBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_DeleteSubnetBasedGroupMember_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteSubnetBasedGroupMember_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteSubnetBasedGroupMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *GroupID_val;
  int32 GroupID;
  val_value_t *IdentifyList_val;
  y_intri_vlan_T_intri_vlan_DeleteSubnetBasedGroupMember_input_IdentifyList IdentifyList;

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  GroupID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_GroupID);
  if (GroupID_val != NULL && GroupID_val->res == NO_ERR) {
    GroupID = VAL_INT(GroupID_val);
  }

  IdentifyList_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyList);
  if (IdentifyList_val != NULL && IdentifyList_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyList;
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_DeleteSubnetBasedGroupMember_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetManagementVlanPorts_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetManagementVlanPorts_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_GetManagementVlanPorts_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_GetManagementVlanPorts_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_GetManagementVlanPorts_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if msg is used */
  (void)msg;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_GetManagementVlanPorts_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_SetDefaultPortVlan_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_SetDefaultPortVlan_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *IdentifyNo_val;
  y_intri_vlan_T_intri_vlan_SetDefaultPortVlan_input_IdentifyNo IdentifyNo;
  val_value_t *DefaultVlanID_val;
  int32 DefaultVlanID;
  val_value_t *LastUpdateMethod_val;
  const xmlChar *LastUpdateMethod;

  IdentifyNo_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyNo);
  if (IdentifyNo_val != NULL && IdentifyNo_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyNo;
  }

  DefaultVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_DefaultVlanID);
  if (DefaultVlanID_val != NULL && DefaultVlanID_val->res == NO_ERR) {
    DefaultVlanID = VAL_INT(DefaultVlanID_val);
  }

  LastUpdateMethod_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_LastUpdateMethod);
  if (LastUpdateMethod_val != NULL && LastUpdateMethod_val->res == NO_ERR) {
    LastUpdateMethod = VAL_ENUM_NAME(LastUpdateMethod_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_SetDefaultPortVlan_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_SetDefaultPortVlan_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_SetDefaultPortVlan_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *IdentifyNo_val;
  y_intri_vlan_T_intri_vlan_SetDefaultPortVlan_input_IdentifyNo IdentifyNo;
  val_value_t *DefaultVlanID_val;
  int32 DefaultVlanID;
  val_value_t *LastUpdateMethod_val;
  const xmlChar *LastUpdateMethod;

  IdentifyNo_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyNo);
  if (IdentifyNo_val != NULL && IdentifyNo_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyNo;
  }

  DefaultVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_DefaultVlanID);
  if (DefaultVlanID_val != NULL && DefaultVlanID_val->res == NO_ERR) {
    DefaultVlanID = VAL_INT(DefaultVlanID_val);
  }

  LastUpdateMethod_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_LastUpdateMethod);
  if (LastUpdateMethod_val != NULL && LastUpdateMethod_val->res == NO_ERR) {
    LastUpdateMethod = VAL_ENUM_NAME(LastUpdateMethod_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_SetDefaultPortVlan_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_ClearDefaultPortVlan_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_ClearDefaultPortVlan_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *IdentifyNo_val;
  y_intri_vlan_T_intri_vlan_ClearDefaultPortVlan_input_IdentifyNo IdentifyNo;
  val_value_t *DefaultVlanID_val;
  int32 DefaultVlanID;
  val_value_t *LastUpdateMethod_val;
  const xmlChar *LastUpdateMethod;

  IdentifyNo_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyNo);
  if (IdentifyNo_val != NULL && IdentifyNo_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyNo;
  }

  DefaultVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_DefaultVlanID);
  if (DefaultVlanID_val != NULL && DefaultVlanID_val->res == NO_ERR) {
    DefaultVlanID = VAL_INT(DefaultVlanID_val);
  }

  LastUpdateMethod_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_LastUpdateMethod);
  if (LastUpdateMethod_val != NULL && LastUpdateMethod_val->res == NO_ERR) {
    LastUpdateMethod = VAL_ENUM_NAME(LastUpdateMethod_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_ClearDefaultPortVlan_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_ClearDefaultPortVlan_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_ClearDefaultPortVlan_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *IdentifyNo_val;
  y_intri_vlan_T_intri_vlan_ClearDefaultPortVlan_input_IdentifyNo IdentifyNo;
  val_value_t *DefaultVlanID_val;
  int32 DefaultVlanID;
  val_value_t *LastUpdateMethod_val;
  const xmlChar *LastUpdateMethod;

  IdentifyNo_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyNo);
  if (IdentifyNo_val != NULL && IdentifyNo_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyNo;
  }

  DefaultVlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_DefaultVlanID);
  if (DefaultVlanID_val != NULL && DefaultVlanID_val->res == NO_ERR) {
    DefaultVlanID = VAL_INT(DefaultVlanID_val);
  }

  LastUpdateMethod_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_LastUpdateMethod);
  if (LastUpdateMethod_val != NULL && LastUpdateMethod_val->res == NO_ERR) {
    LastUpdateMethod = VAL_ENUM_NAME(LastUpdateMethod_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_ClearDefaultPortVlan_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateVlanPortVlanStatus_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateVlanPortVlanStatus_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *IdentifyNo_val;
  y_intri_vlan_T_intri_vlan_UpdateVlanPortVlanStatus_input_IdentifyNo IdentifyNo;
  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *Used_val;
  const xmlChar *Used;

  IdentifyNo_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyNo);
  if (IdentifyNo_val != NULL && IdentifyNo_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyNo;
  }

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  Used_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Used);
  if (Used_val != NULL && Used_val->res == NO_ERR) {
    Used = VAL_ENUM_NAME(Used_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_UpdateVlanPortVlanStatus_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_UpdateVlanPortVlanStatus_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_UpdateVlanPortVlanStatus_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *IdentifyNo_val;
  y_intri_vlan_T_intri_vlan_UpdateVlanPortVlanStatus_input_IdentifyNo IdentifyNo;
  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *Used_val;
  const xmlChar *Used;

  IdentifyNo_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyNo);
  if (IdentifyNo_val != NULL && IdentifyNo_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyNo;
  }

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  Used_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Used);
  if (Used_val != NULL && Used_val->res == NO_ERR) {
    Used = VAL_ENUM_NAME(Used_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_UpdateVlanPortVlanStatus_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteVlanPortVlanStatus_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteVlanPortVlanStatus_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *IdentifyNo_val;
  y_intri_vlan_T_intri_vlan_DeleteVlanPortVlanStatus_input_IdentifyNo IdentifyNo;
  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *Used_val;
  const xmlChar *Used;

  IdentifyNo_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyNo);
  if (IdentifyNo_val != NULL && IdentifyNo_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyNo;
  }

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  Used_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Used);
  if (Used_val != NULL && Used_val->res == NO_ERR) {
    Used = VAL_ENUM_NAME(Used_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_vlan_intri_vlan_DeleteVlanPortVlanStatus_validate */

/********************************************************************
 * FUNCTION y_intri_vlan_intri_vlan_DeleteVlanPortVlanStatus_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_vlan_intri_vlan_DeleteVlanPortVlanStatus_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *IdentifyNo_val;
  y_intri_vlan_T_intri_vlan_DeleteVlanPortVlanStatus_input_IdentifyNo IdentifyNo;
  val_value_t *VlanID_val;
  int32 VlanID;
  val_value_t *Used_val;
  const xmlChar *Used;

  IdentifyNo_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_IdentifyNo);
  if (IdentifyNo_val != NULL && IdentifyNo_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)IdentifyNo;
  }

  VlanID_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_VlanID);
  if (VlanID_val != NULL && VlanID_val->res == NO_ERR) {
    VlanID = VAL_INT(VlanID_val);
  }

  Used_val = val_find_child(
      msg->rpc_input,
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_Used);
  if (Used_val != NULL && Used_val->res == NO_ERR) {
    Used = VAL_ENUM_NAME(Used_val);
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_vlan_intri_vlan_DeleteVlanPortVlanStatus_invoke */

/********************************************************************
 * FUNCTION y_intri_vlan_init
 *
 * initialize the intri-vlan server instrumentation library
 *
 * INPUTS:
 *    modname == requested module name
 *    revision == requested version (NULL for any)
 *
 * RETURNS:
 *     error status
 ********************************************************************/
status_t y_intri_vlan_init(
    const xmlChar *modname,
    const xmlChar *revision) {
  status_t res = NO_ERR;
  agt_profile_t *agt_profile = agt_get_profile();

  y_intri_vlan_init_static_vars();

  /* change if custom handling done */
  if (xml_strcmp(modname, y_intri_vlan_M_intri_vlan)) {
    return ERR_NCX_UNKNOWN_MODULE;
  }

  if (revision && xml_strcmp(revision, y_intri_vlan_R_intri_vlan)) {
    return ERR_NCX_WRONG_VERSION;
  }
  res = ncxmod_load_module(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_R_intri_vlan,
      &agt_profile->agt_savedevQ,
      &intri_vlan_mod);
  if (res != NO_ERR) {
    return res;
  }

  intri_vlan_GetConfig_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_GetConfig);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_GetStatus_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_GetStatus);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_GetManagementConfig_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_GetManagementConfig);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_UpdateManagementConfig_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_UpdateManagementConfig);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_GetVoiceConfig_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_GetVoiceConfig);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_UpdateVoiceConfig_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_UpdateVoiceConfig);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_GetFiltersConfig_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_GetFiltersConfig);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_AddFilter_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_AddFilter);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_UpdateFilter_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_UpdateFilter);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_DeleteFilter_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_DeleteFilter);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_GetPortsConfig_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_GetPortsConfig);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_UpdatePortsConfig_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_UpdatePortsConfig);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_GetMappingConfig_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_GetMappingConfig);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_AddMapping_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_AddMapping);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_DeleteMapping_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_DeleteMapping);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_UpdateMappingPortEntry_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_UpdateMappingPortEntry);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_GetSelectiveQinQConfig_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_GetSelectiveQinQConfig);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_AddSelectiveQinQ_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_AddSelectiveQinQ);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_UpdateSelectiveQinQ_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_UpdateSelectiveQinQ);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_DeleteSelectiveQinQ_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_DeleteSelectiveQinQ);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_GetProtocolBasedConfig_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_GetProtocolBasedConfig);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_AddProtocolBasedGroup_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_AddProtocolBasedGroup);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_UpdateProtocolBasedGroup_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_UpdateProtocolBasedGroup);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_DeleteProtocolBasedGroup_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_DeleteProtocolBasedGroup);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_AddProtocolBasedGroupMember_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_AddProtocolBasedGroupMember);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_UpdateProtocolBasedGroupMember_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_UpdateProtocolBasedGroupMember);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_DeleteProtocolBasedGroupMember_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_DeleteProtocolBasedGroupMember);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_GetMACBasedConfig_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_GetMACBasedConfig);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_AddMACBasedGroup_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_AddMACBasedGroup);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_UpdateMACBasedGroup_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_UpdateMACBasedGroup);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_DeleteMACBasedGroup_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_DeleteMACBasedGroup);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_AddMACBasedGroupMember_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_AddMACBasedGroupMember);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_UpdateMACBasedGroupMember_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_UpdateMACBasedGroupMember);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_DeleteMACBasedGroupMember_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_DeleteMACBasedGroupMember);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_GetSubnetBasedConfig_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_GetSubnetBasedConfig);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_AddSubnetBasedGroup_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_AddSubnetBasedGroup);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_UpdateSubnetBasedGroup_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_UpdateSubnetBasedGroup);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_DeleteSubnetBasedGroup_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_DeleteSubnetBasedGroup);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_AddSubnetBasedGroupMember_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_AddSubnetBasedGroupMember);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_UpdateSubnetBasedGroupMember_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_UpdateSubnetBasedGroupMember);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_DeleteSubnetBasedGroupMember_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_DeleteSubnetBasedGroupMember);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_GetManagementVlanPorts_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_GetManagementVlanPorts);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_SetDefaultPortVlan_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_SetDefaultPortVlan);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_ClearDefaultPortVlan_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_ClearDefaultPortVlan);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_UpdateVlanPortVlanStatus_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_UpdateVlanPortVlanStatus);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_vlan_DeleteVlanPortVlanStatus_obj = ncx_find_object(
      intri_vlan_mod,
      y_intri_vlan_N_intri_vlan_DeleteVlanPortVlanStatus);
  if (intri_vlan_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetConfig,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_GetConfig_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetConfig,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_GetConfig_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetStatus,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_GetStatus_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetStatus,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_GetStatus_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetManagementConfig,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_GetManagementConfig_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetManagementConfig,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_GetManagementConfig_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateManagementConfig,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_UpdateManagementConfig_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateManagementConfig,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_UpdateManagementConfig_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetVoiceConfig,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_GetVoiceConfig_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetVoiceConfig,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_GetVoiceConfig_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateVoiceConfig,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_UpdateVoiceConfig_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateVoiceConfig,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_UpdateVoiceConfig_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetFiltersConfig,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_GetFiltersConfig_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetFiltersConfig,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_GetFiltersConfig_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddFilter,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_AddFilter_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddFilter,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_AddFilter_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateFilter,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_UpdateFilter_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateFilter,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_UpdateFilter_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteFilter,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_DeleteFilter_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteFilter,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_DeleteFilter_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetPortsConfig,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_GetPortsConfig_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetPortsConfig,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_GetPortsConfig_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdatePortsConfig,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_UpdatePortsConfig_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdatePortsConfig,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_UpdatePortsConfig_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetMappingConfig,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_GetMappingConfig_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetMappingConfig,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_GetMappingConfig_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddMapping,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_AddMapping_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddMapping,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_AddMapping_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteMapping,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_DeleteMapping_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteMapping,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_DeleteMapping_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateMappingPortEntry,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_UpdateMappingPortEntry_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateMappingPortEntry,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_UpdateMappingPortEntry_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetSelectiveQinQConfig,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_GetSelectiveQinQConfig_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetSelectiveQinQConfig,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_GetSelectiveQinQConfig_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddSelectiveQinQ,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_AddSelectiveQinQ_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddSelectiveQinQ,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_AddSelectiveQinQ_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateSelectiveQinQ,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_UpdateSelectiveQinQ_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateSelectiveQinQ,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_UpdateSelectiveQinQ_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteSelectiveQinQ,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_DeleteSelectiveQinQ_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteSelectiveQinQ,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_DeleteSelectiveQinQ_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetProtocolBasedConfig,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_GetProtocolBasedConfig_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetProtocolBasedConfig,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_GetProtocolBasedConfig_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddProtocolBasedGroup,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_AddProtocolBasedGroup_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddProtocolBasedGroup,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_AddProtocolBasedGroup_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateProtocolBasedGroup,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_UpdateProtocolBasedGroup_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateProtocolBasedGroup,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_UpdateProtocolBasedGroup_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteProtocolBasedGroup,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_DeleteProtocolBasedGroup_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteProtocolBasedGroup,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_DeleteProtocolBasedGroup_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddProtocolBasedGroupMember,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_AddProtocolBasedGroupMember_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddProtocolBasedGroupMember,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_AddProtocolBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateProtocolBasedGroupMember,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_UpdateProtocolBasedGroupMember_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateProtocolBasedGroupMember,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_UpdateProtocolBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteProtocolBasedGroupMember,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_DeleteProtocolBasedGroupMember_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteProtocolBasedGroupMember,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_DeleteProtocolBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetMACBasedConfig,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_GetMACBasedConfig_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetMACBasedConfig,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_GetMACBasedConfig_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddMACBasedGroup,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_AddMACBasedGroup_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddMACBasedGroup,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_AddMACBasedGroup_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateMACBasedGroup,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_UpdateMACBasedGroup_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateMACBasedGroup,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_UpdateMACBasedGroup_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteMACBasedGroup,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_DeleteMACBasedGroup_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteMACBasedGroup,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_DeleteMACBasedGroup_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddMACBasedGroupMember,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_AddMACBasedGroupMember_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddMACBasedGroupMember,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_AddMACBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateMACBasedGroupMember,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_UpdateMACBasedGroupMember_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateMACBasedGroupMember,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_UpdateMACBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteMACBasedGroupMember,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_DeleteMACBasedGroupMember_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteMACBasedGroupMember,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_DeleteMACBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetSubnetBasedConfig,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_GetSubnetBasedConfig_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetSubnetBasedConfig,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_GetSubnetBasedConfig_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddSubnetBasedGroup,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_AddSubnetBasedGroup_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddSubnetBasedGroup,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_AddSubnetBasedGroup_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateSubnetBasedGroup,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_UpdateSubnetBasedGroup_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateSubnetBasedGroup,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_UpdateSubnetBasedGroup_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteSubnetBasedGroup,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_DeleteSubnetBasedGroup_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteSubnetBasedGroup,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_DeleteSubnetBasedGroup_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddSubnetBasedGroupMember,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_AddSubnetBasedGroupMember_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddSubnetBasedGroupMember,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_AddSubnetBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateSubnetBasedGroupMember,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_UpdateSubnetBasedGroupMember_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateSubnetBasedGroupMember,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_UpdateSubnetBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteSubnetBasedGroupMember,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_DeleteSubnetBasedGroupMember_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteSubnetBasedGroupMember,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_DeleteSubnetBasedGroupMember_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetManagementVlanPorts,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_GetManagementVlanPorts_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetManagementVlanPorts,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_GetManagementVlanPorts_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_SetDefaultPortVlan,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_SetDefaultPortVlan_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_SetDefaultPortVlan,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_SetDefaultPortVlan_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_ClearDefaultPortVlan,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_ClearDefaultPortVlan_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_ClearDefaultPortVlan,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_ClearDefaultPortVlan_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateVlanPortVlanStatus,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_UpdateVlanPortVlanStatus_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateVlanPortVlanStatus,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_UpdateVlanPortVlanStatus_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteVlanPortVlanStatus,
      AGT_RPC_PH_VALIDATE,
      y_intri_vlan_intri_vlan_DeleteVlanPortVlanStatus_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteVlanPortVlanStatus,
      AGT_RPC_PH_INVOKE,
      y_intri_vlan_intri_vlan_DeleteVlanPortVlanStatus_invoke);
  if (res != NO_ERR) {
    return res;
  }

  /* put your module initialization code here */

  ian_test_func();

  return res;
} /* y_intri_vlan_init */

/********************************************************************
 * FUNCTION y_intri_vlan_init2
 *
 * SIL init phase 2: non-config data structures
 * Called after running config is loaded
 *
 * RETURNS:
 *     error status
 ********************************************************************/
status_t y_intri_vlan_init2(void) {
  status_t res = NO_ERR;

  /* put your init2 code here */

  return res;
} /* y_intri_vlan_init2 */

/********************************************************************
 * FUNCTION y_intri_vlan_cleanup
 *    cleanup the server instrumentation library
 *
 ********************************************************************/
void y_intri_vlan_cleanup(void) {
  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetConfig);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetStatus);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetManagementConfig);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateManagementConfig);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetVoiceConfig);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateVoiceConfig);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetFiltersConfig);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddFilter);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateFilter);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteFilter);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetPortsConfig);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdatePortsConfig);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetMappingConfig);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddMapping);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteMapping);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateMappingPortEntry);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetSelectiveQinQConfig);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddSelectiveQinQ);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateSelectiveQinQ);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteSelectiveQinQ);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetProtocolBasedConfig);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddProtocolBasedGroup);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateProtocolBasedGroup);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteProtocolBasedGroup);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddProtocolBasedGroupMember);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateProtocolBasedGroupMember);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteProtocolBasedGroupMember);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetMACBasedConfig);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddMACBasedGroup);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateMACBasedGroup);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteMACBasedGroup);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddMACBasedGroupMember);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateMACBasedGroupMember);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteMACBasedGroupMember);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetSubnetBasedConfig);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddSubnetBasedGroup);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateSubnetBasedGroup);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteSubnetBasedGroup);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_AddSubnetBasedGroupMember);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateSubnetBasedGroupMember);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteSubnetBasedGroupMember);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_GetManagementVlanPorts);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_SetDefaultPortVlan);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_ClearDefaultPortVlan);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_UpdateVlanPortVlanStatus);

  agt_rpc_unregister_method(
      y_intri_vlan_M_intri_vlan,
      y_intri_vlan_N_intri_vlan_DeleteVlanPortVlanStatus);
  /* put your cleanup code here */

} /* y_intri_vlan_cleanup */

/* END intri_vlan.c */
