// Code generated by protoc-gen-yang(*.c) DO NOT EDIT.

/*****************************************************************************************************
 * Copyright (C) 2017-2022 by Intrising
 *  - ian0113@intrising.com.tw
 * 
 * Generated by protoc-gen-yang@gen-yang
 * 
 *****************************************************************************************************/

#include <libxml/xmlstring.h>
#include "agt.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "procdefs.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"

#include "intri-portauthentication-trans.h"
#include "../../../../../../../../.libintrishare/libintrishare.h"

#include "../../../../../github.com/Intrising/intri-type/common/intri-common-trans.h"
#include "../../../../../github.com/Intrising/intri-type/core/access/intri-access-trans.h"
#include "../../../../../github.com/Intrising/intri-type/device/intri-device-trans.h"
#include "../../../../../github.com/golang/protobuf/ptypes/empty/intri-empty-trans.h"

status_t build_to_xml_portauthentication_Config(
    val_value_t *parentval,
    struct portauthenticationpb_Config *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "SystemConfig",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_portauthentication_SystemConfig(
      childval,
      entry->SystemConfig);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "PortConfig",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_portauthentication_PortConfig(
      childval,
      entry->PortConfig);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "AuthorizedMACs",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_portauthentication_AuthorizedMACs(
      childval,
      entry->AuthorizedMACs);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  return res;
}
status_t build_to_xml_portauthentication_AuthorizedMACsEntry(
    val_value_t *parentval,
    struct portauthenticationpb_AuthorizedMACsEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Name",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->Name;
  childval = agt_make_object(
      parentval->obj,
      "MACAddress",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->MACAddress;
  childval = agt_make_object(
      parentval->obj,
      "PermittedPortList",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->PermittedPortList_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "PermittedPortList_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_device_InterfaceIdentify(
        listval,
        entry->PermittedPortList[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = agt_make_object(
      parentval->obj,
      "TreatAsVendorMAC",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->TreatAsVendorMAC;
  return res;
}
status_t build_to_xml_portauthentication_AuthorizedMACs(
    val_value_t *parentval,
    struct portauthenticationpb_AuthorizedMACs *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "List",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->List_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "List_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_portauthentication_AuthorizedMACsEntry(
        listval,
        entry->List[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_portauthentication_SystemConfig(
    val_value_t *parentval,
    struct portauthenticationpb_SystemConfig *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "PortAccessControlEnabled",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* bool */
  VAL_BOOL(childval) = entry->PortAccessControlEnabled;
  childval = agt_make_object(
      parentval->obj,
      "ReauthenticationPeriod",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->ReauthenticationPeriod;
  childval = agt_make_object(
      parentval->obj,
      "NASIdentifier",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->NASIdentifier;
  childval = agt_make_object(
      parentval->obj,
      "MACSeparatorChar",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->MACSeparatorChar;
  childval = agt_make_object(
      parentval->obj,
      "MACSpelling",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->MACSpelling) {
    case portauthenticationpb_MACSpellingTypeOptions_MAC_SPELLING_TYPE_LOWERCASE:
      enum_str = "MAC_SPELLING_TYPE_LOWERCASE";
      break;
    case portauthenticationpb_MACSpellingTypeOptions_MAC_SPELLING_TYPE_UPPERCASE:
      enum_str = "MAC_SPELLING_TYPE_UPPERCASE";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "MACPasswordSource",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->MACPasswordSource) {
    case portauthenticationpb_MACPasswordSourceTypeOptions_MAC_PASSWORD_SOURCE_TYPE_USEMAC:
      enum_str = "MAC_PASSWORD_SOURCE_TYPE_USEMAC";
      break;
    case portauthenticationpb_MACPasswordSourceTypeOptions_MAC_PASSWORD_SOURCE_TYPE_USEPASSWORD:
      enum_str = "MAC_PASSWORD_SOURCE_TYPE_USEPASSWORD";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "MACPasswordString",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->MACPasswordString;
  childval = agt_make_object(
      parentval->obj,
      "PrimaryAuthServerName",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->PrimaryAuthServerName;
  childval = agt_make_object(
      parentval->obj,
      "PrimaryAcctServerName",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->PrimaryAcctServerName;
  childval = agt_make_object(
      parentval->obj,
      "FallbackAuthServerName",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->FallbackAuthServerName;
  childval = agt_make_object(
      parentval->obj,
      "FallbackAcctServerName",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->FallbackAcctServerName;
  childval = agt_make_object(
      parentval->obj,
      "ServerDownTimeout",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->ServerDownTimeout;
  return res;
}
status_t build_to_xml_portauthentication_PortConfig(
    val_value_t *parentval,
    struct portauthenticationpb_PortConfig *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "List",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->List_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "List_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_portauthentication_PortConfigEntry(
        listval,
        entry->List[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_portauthentication_PortConfigEntry(
    val_value_t *parentval,
    struct portauthenticationpb_PortConfigEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "IdentifyNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_InterfaceIdentify(
      childval,
      entry->IdentifyNo);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "AuthorizedMode",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->AuthorizedMode) {
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_ALWAYSAUTH:
      enum_str = "AUTHORIZATION_MODE_TYPE_ALWAYSAUTH";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_FORCEUNAUTH:
      enum_str = "AUTHORIZATION_MODE_TYPE_FORCEUNAUTH";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_VIAMACTABLE:
      enum_str = "AUTHORIZATION_MODE_TYPE_VIAMACTABLE";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_MACVIARADIUS:
      enum_str = "AUTHORIZATION_MODE_TYPE_MACVIARADIUS";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_8021XVIARADIUS:
      enum_str = "AUTHORIZATION_MODE_TYPE_8021XVIARADIUS";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_MAC8021XVIARADIUS:
      enum_str = "AUTHORIZATION_MODE_TYPE_MAC8021XVIARADIUS";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_8021XMACVIARADIUS:
      enum_str = "AUTHORIZATION_MODE_TYPE_8021XMACVIARADIUS";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_NONE:
      enum_str = "AUTHORIZATION_MODE_TYPE_NONE";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "UnAuthorizedMode",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->UnAuthorizedMode) {
    case portauthenticationpb_UnAuthorizationModeTypeOptions_UNAUTHORIZATION_MODE_TYPE_BLOCKED:
      enum_str = "UNAUTHORIZATION_MODE_TYPE_BLOCKED";
      break;
    case portauthenticationpb_UnAuthorizationModeTypeOptions_UNAUTHORIZATION_MODE_TYPE_USE_UNAUTHORIZEDVLAN:
      enum_str = "UNAUTHORIZATION_MODE_TYPE_USE_UNAUTHORIZEDVLAN";
      break;
    case portauthenticationpb_UnAuthorizationModeTypeOptions_UNAUTHORIZATION_MODE_TYPE_INCOMING_BLOCKED:
      enum_str = "UNAUTHORIZATION_MODE_TYPE_INCOMING_BLOCKED";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "AuthFailRetryInterval",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->AuthFailRetryInterval;
  childval = agt_make_object(
      parentval->obj,
      "LimitedNumberOfMACs",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->LimitedNumberOfMACs;
  childval = agt_make_object(
      parentval->obj,
      "MACTimeout",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->MACTimeout) {
    case portauthenticationpb_MACTimeoutTypeOptions_MAC_TIMEOUT_TYPE_NONE:
      enum_str = "MAC_TIMEOUT_TYPE_NONE";
      break;
    case portauthenticationpb_MACTimeoutTypeOptions_MAC_TIMEOUT_TYPE_SLOW:
      enum_str = "MAC_TIMEOUT_TYPE_SLOW";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  return res;
}
status_t build_to_xml_portauthentication_PortStatus(
    val_value_t *parentval,
    struct portauthenticationpb_PortStatus *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "List",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->List_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "List_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_portauthentication_PortStatusEntry(
        listval,
        entry->List[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_portauthentication_PortStatusEntry(
    val_value_t *parentval,
    struct portauthenticationpb_PortStatusEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "IdentifyNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_InterfaceIdentify(
      childval,
      entry->IdentifyNo);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "AuthorizationState",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->AuthorizationState) {
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_UNDEFINED:
      enum_str = "AUTHORIZATION_STATE_TYPE_UNDEFINED";
      break;
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_DISABLED:
      enum_str = "AUTHORIZATION_STATE_TYPE_DISABLED";
      break;
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_UNAUTHORIZED:
      enum_str = "AUTHORIZATION_STATE_TYPE_UNAUTHORIZED";
      break;
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_PROCESSING:
      enum_str = "AUTHORIZATION_STATE_TYPE_PROCESSING";
      break;
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_AUTHORIZED:
      enum_str = "AUTHORIZATION_STATE_TYPE_AUTHORIZED";
      break;
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_REJECTED:
      enum_str = "AUTHORIZATION_STATE_TYPE_REJECTED";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "AuthorizationMode",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->AuthorizationMode) {
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_ALWAYSAUTH:
      enum_str = "AUTHORIZATION_MODE_TYPE_ALWAYSAUTH";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_FORCEUNAUTH:
      enum_str = "AUTHORIZATION_MODE_TYPE_FORCEUNAUTH";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_VIAMACTABLE:
      enum_str = "AUTHORIZATION_MODE_TYPE_VIAMACTABLE";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_MACVIARADIUS:
      enum_str = "AUTHORIZATION_MODE_TYPE_MACVIARADIUS";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_8021XVIARADIUS:
      enum_str = "AUTHORIZATION_MODE_TYPE_8021XVIARADIUS";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_MAC8021XVIARADIUS:
      enum_str = "AUTHORIZATION_MODE_TYPE_MAC8021XVIARADIUS";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_8021XMACVIARADIUS:
      enum_str = "AUTHORIZATION_MODE_TYPE_8021XMACVIARADIUS";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_NONE:
      enum_str = "AUTHORIZATION_MODE_TYPE_NONE";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "LastStateChange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->LastStateChange;
  childval = agt_make_object(
      parentval->obj,
      "NumberOfMACsToLearn",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->NumberOfMACsToLearn;
  childval = agt_make_object(
      parentval->obj,
      "NumberOfLearnedMACs",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->NumberOfLearnedMACs;
  return res;
}
status_t build_to_xml_portauthentication_PortAuthorizationStatus(
    val_value_t *parentval,
    struct portauthenticationpb_PortAuthorizationStatus *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "List",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->List_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "List_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_portauthentication_PortAuthorizationStatusEntry(
        listval,
        entry->List[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_portauthentication_PortAuthorizationStatusEntry(
    val_value_t *parentval,
    struct portauthenticationpb_PortAuthorizationStatusEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "IdentifyNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_InterfaceIdentify(
      childval,
      entry->IdentifyNo);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "AuthorizationState",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->AuthorizationState) {
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_UNDEFINED:
      enum_str = "AUTHORIZATION_STATE_TYPE_UNDEFINED";
      break;
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_DISABLED:
      enum_str = "AUTHORIZATION_STATE_TYPE_DISABLED";
      break;
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_UNAUTHORIZED:
      enum_str = "AUTHORIZATION_STATE_TYPE_UNAUTHORIZED";
      break;
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_PROCESSING:
      enum_str = "AUTHORIZATION_STATE_TYPE_PROCESSING";
      break;
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_AUTHORIZED:
      enum_str = "AUTHORIZATION_STATE_TYPE_AUTHORIZED";
      break;
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_REJECTED:
      enum_str = "AUTHORIZATION_STATE_TYPE_REJECTED";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "UserMAC",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->UserMAC;
  childval = agt_make_object(
      parentval->obj,
      "UserName",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->UserName;
  childval = agt_make_object(
      parentval->obj,
      "IdleTimeout",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->IdleTimeout;
  childval = agt_make_object(
      parentval->obj,
      "SessionTimeout",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->SessionTimeout;
  childval = agt_make_object(
      parentval->obj,
      "LastStateChange",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->LastStateChange;
  return res;
}
status_t build_to_xml_portauthentication_UserStatus(
    val_value_t *parentval,
    struct portauthenticationpb_UserStatus *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "List",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < entry->List_Len; i++) {
    val_value_t *listval = NULL;
    listval = agt_make_object(
        childval->obj,
        "List_Entry",
        &res);
    if (listval != NULL) {
      val_add_child(listval, childval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    /* message */
    res = build_to_xml_portauthentication_UserStatusEntry(
        listval,
        entry->List[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_xml_portauthentication_UserStatusEntry(
    val_value_t *parentval,
    struct portauthenticationpb_UserStatusEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "EntryState",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->EntryState) {
    case portauthenticationpb_EntryStateTypeOptions_ENTRY_STATE_TYPE_UNUSED:
      enum_str = "ENTRY_STATE_TYPE_UNUSED";
      break;
    case portauthenticationpb_EntryStateTypeOptions_ENTRY_STATE_TYPE_INACTIVE:
      enum_str = "ENTRY_STATE_TYPE_INACTIVE";
      break;
    case portauthenticationpb_EntryStateTypeOptions_ENTRY_STATE_TYPE_ACTIVE:
      enum_str = "ENTRY_STATE_TYPE_ACTIVE";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "AuthorizationState",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->AuthorizationState) {
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_UNDEFINED:
      enum_str = "AUTHORIZATION_STATE_TYPE_UNDEFINED";
      break;
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_DISABLED:
      enum_str = "AUTHORIZATION_STATE_TYPE_DISABLED";
      break;
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_UNAUTHORIZED:
      enum_str = "AUTHORIZATION_STATE_TYPE_UNAUTHORIZED";
      break;
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_PROCESSING:
      enum_str = "AUTHORIZATION_STATE_TYPE_PROCESSING";
      break;
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_AUTHORIZED:
      enum_str = "AUTHORIZATION_STATE_TYPE_AUTHORIZED";
      break;
    case portauthenticationpb_AuthorizationStateTypeOptions_AUTHORIZATION_STATE_TYPE_REJECTED:
      enum_str = "AUTHORIZATION_STATE_TYPE_REJECTED";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "AuthorizationMode",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->AuthorizationMode) {
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_ALWAYSAUTH:
      enum_str = "AUTHORIZATION_MODE_TYPE_ALWAYSAUTH";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_FORCEUNAUTH:
      enum_str = "AUTHORIZATION_MODE_TYPE_FORCEUNAUTH";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_VIAMACTABLE:
      enum_str = "AUTHORIZATION_MODE_TYPE_VIAMACTABLE";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_MACVIARADIUS:
      enum_str = "AUTHORIZATION_MODE_TYPE_MACVIARADIUS";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_8021XVIARADIUS:
      enum_str = "AUTHORIZATION_MODE_TYPE_8021XVIARADIUS";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_MAC8021XVIARADIUS:
      enum_str = "AUTHORIZATION_MODE_TYPE_MAC8021XVIARADIUS";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_8021XMACVIARADIUS:
      enum_str = "AUTHORIZATION_MODE_TYPE_8021XMACVIARADIUS";
      break;
    case portauthenticationpb_AuthorizationModeTypeOptions_AUTHORIZATION_MODE_TYPE_NONE:
      enum_str = "AUTHORIZATION_MODE_TYPE_NONE";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  childval = agt_make_object(
      parentval->obj,
      "IdentifyNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_InterfaceIdentify(
      childval,
      entry->IdentifyNo);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "UserMAC",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->UserMAC;
  childval = agt_make_object(
      parentval->obj,
      "UserName",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->UserName;
  childval = agt_make_object(
      parentval->obj,
      "VlanID",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->VlanID;
  childval = agt_make_object(
      parentval->obj,
      "IdleTimeout",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->IdleTimeout;
  childval = agt_make_object(
      parentval->obj,
      "SessionTimeout",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->SessionTimeout;
  childval = agt_make_object(
      parentval->obj,
      "LoginTimeStamp",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->LoginTimeStamp;
  return res;
}
status_t build_to_xml_portauthentication_LearnMACNowEntry(
    val_value_t *parentval,
    struct portauthenticationpb_LearnMACNowEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "IdentifyNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_InterfaceIdentify(
      childval,
      entry->IdentifyNo);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "Amount",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* int32 */
  VAL_INT(childval) = entry->Amount;
  return res;
}
status_t build_to_xml_portauthentication_UnauthorizeMACEntry(
    val_value_t *parentval,
    struct portauthenticationpb_UnauthorizeMACEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "IdentifyNo",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* message */
  res = build_to_xml_device_InterfaceIdentify(
      childval,
      entry->IdentifyNo);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_object(
      parentval->obj,
      "MACAddress",
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* string */
  VAL_STRING(childval) = entry->MACAddress;
  return res;
}

status_t build_to_priv_portauthentication_Config(
    val_value_t *parentval,
    struct portauthenticationpb_Config *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "SystemConfig");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->SystemConfig = malloc(sizeof(*(entry->SystemConfig)));
    res = build_to_priv_portauthentication_SystemConfig(
        childval,
        entry->SystemConfig);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "PortConfig");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->PortConfig = malloc(sizeof(*(entry->PortConfig)));
    res = build_to_priv_portauthentication_PortConfig(
        childval,
        entry->PortConfig);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "AuthorizedMACs");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->AuthorizedMACs = malloc(sizeof(*(entry->AuthorizedMACs)));
    res = build_to_priv_portauthentication_AuthorizedMACs(
        childval,
        entry->AuthorizedMACs);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  return res;
}
status_t build_to_priv_portauthentication_AuthorizedMACsEntry(
    val_value_t *parentval,
    struct portauthenticationpb_AuthorizedMACsEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Name");
  entry->Name = malloc(sizeof(*entry->Name));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->Name = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MACAddress");
  entry->MACAddress = malloc(sizeof(*entry->MACAddress));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->MACAddress = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "PermittedPortList");
  entry->PermittedPortList_Len = 0;
  entry->PermittedPortList = malloc(sizeof(*entry->PermittedPortList));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->PermittedPortList_Len = dlq_count(&childval->v.childQ);
    entry->PermittedPortList = malloc((entry->PermittedPortList_Len + 1) * sizeof(*entry->PermittedPortList));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->PermittedPortList[cnt] = malloc(sizeof(*(entry->PermittedPortList[cnt])));
      res = build_to_priv_device_InterfaceIdentify(
          listval,
          entry->PermittedPortList[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  childval = val_first_child_name(
      parentval,
      "TreatAsVendorMAC");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->TreatAsVendorMAC = VAL_BOOL(childval);
  }
  return res;
}
status_t build_to_priv_portauthentication_AuthorizedMACs(
    val_value_t *parentval,
    struct portauthenticationpb_AuthorizedMACs *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "List");
  entry->List_Len = 0;
  entry->List = malloc(sizeof(*entry->List));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->List_Len = dlq_count(&childval->v.childQ);
    entry->List = malloc((entry->List_Len + 1) * sizeof(*entry->List));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->List[cnt] = malloc(sizeof(*(entry->List[cnt])));
      res = build_to_priv_portauthentication_AuthorizedMACsEntry(
          listval,
          entry->List[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_portauthentication_SystemConfig(
    val_value_t *parentval,
    struct portauthenticationpb_SystemConfig *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "PortAccessControlEnabled");
  if (childval != NULL && childval->res == NO_ERR) {
    /* bool */
    entry->PortAccessControlEnabled = VAL_BOOL(childval);
  }
  childval = val_first_child_name(
      parentval,
      "ReauthenticationPeriod");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->ReauthenticationPeriod = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "NASIdentifier");
  entry->NASIdentifier = malloc(sizeof(*entry->NASIdentifier));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->NASIdentifier = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MACSeparatorChar");
  entry->MACSeparatorChar = malloc(sizeof(*entry->MACSeparatorChar));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->MACSeparatorChar = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MACSpelling");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->MACSpelling = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MACPasswordSource");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->MACPasswordSource = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MACPasswordString");
  entry->MACPasswordString = malloc(sizeof(*entry->MACPasswordString));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->MACPasswordString = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "PrimaryAuthServerName");
  entry->PrimaryAuthServerName = malloc(sizeof(*entry->PrimaryAuthServerName));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->PrimaryAuthServerName = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "PrimaryAcctServerName");
  entry->PrimaryAcctServerName = malloc(sizeof(*entry->PrimaryAcctServerName));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->PrimaryAcctServerName = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "FallbackAuthServerName");
  entry->FallbackAuthServerName = malloc(sizeof(*entry->FallbackAuthServerName));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->FallbackAuthServerName = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "FallbackAcctServerName");
  entry->FallbackAcctServerName = malloc(sizeof(*entry->FallbackAcctServerName));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->FallbackAcctServerName = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "ServerDownTimeout");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->ServerDownTimeout = VAL_INT(childval);
  }
  return res;
}
status_t build_to_priv_portauthentication_PortConfig(
    val_value_t *parentval,
    struct portauthenticationpb_PortConfig *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "List");
  entry->List_Len = 0;
  entry->List = malloc(sizeof(*entry->List));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->List_Len = dlq_count(&childval->v.childQ);
    entry->List = malloc((entry->List_Len + 1) * sizeof(*entry->List));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->List[cnt] = malloc(sizeof(*(entry->List[cnt])));
      res = build_to_priv_portauthentication_PortConfigEntry(
          listval,
          entry->List[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_portauthentication_PortConfigEntry(
    val_value_t *parentval,
    struct portauthenticationpb_PortConfigEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "IdentifyNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->IdentifyNo = malloc(sizeof(*(entry->IdentifyNo)));
    res = build_to_priv_device_InterfaceIdentify(
        childval,
        entry->IdentifyNo);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "AuthorizedMode");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->AuthorizedMode = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "UnAuthorizedMode");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->UnAuthorizedMode = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "AuthFailRetryInterval");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->AuthFailRetryInterval = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "LimitedNumberOfMACs");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->LimitedNumberOfMACs = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "MACTimeout");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->MACTimeout = VAL_ENUM(childval);
  }
  return res;
}
status_t build_to_priv_portauthentication_PortStatus(
    val_value_t *parentval,
    struct portauthenticationpb_PortStatus *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "List");
  entry->List_Len = 0;
  entry->List = malloc(sizeof(*entry->List));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->List_Len = dlq_count(&childval->v.childQ);
    entry->List = malloc((entry->List_Len + 1) * sizeof(*entry->List));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->List[cnt] = malloc(sizeof(*(entry->List[cnt])));
      res = build_to_priv_portauthentication_PortStatusEntry(
          listval,
          entry->List[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_portauthentication_PortStatusEntry(
    val_value_t *parentval,
    struct portauthenticationpb_PortStatusEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "IdentifyNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->IdentifyNo = malloc(sizeof(*(entry->IdentifyNo)));
    res = build_to_priv_device_InterfaceIdentify(
        childval,
        entry->IdentifyNo);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "AuthorizationState");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->AuthorizationState = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "AuthorizationMode");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->AuthorizationMode = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "LastStateChange");
  entry->LastStateChange = malloc(sizeof(*entry->LastStateChange));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->LastStateChange = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "NumberOfMACsToLearn");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->NumberOfMACsToLearn = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "NumberOfLearnedMACs");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->NumberOfLearnedMACs = VAL_INT(childval);
  }
  return res;
}
status_t build_to_priv_portauthentication_PortAuthorizationStatus(
    val_value_t *parentval,
    struct portauthenticationpb_PortAuthorizationStatus *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "List");
  entry->List_Len = 0;
  entry->List = malloc(sizeof(*entry->List));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->List_Len = dlq_count(&childval->v.childQ);
    entry->List = malloc((entry->List_Len + 1) * sizeof(*entry->List));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->List[cnt] = malloc(sizeof(*(entry->List[cnt])));
      res = build_to_priv_portauthentication_PortAuthorizationStatusEntry(
          listval,
          entry->List[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_portauthentication_PortAuthorizationStatusEntry(
    val_value_t *parentval,
    struct portauthenticationpb_PortAuthorizationStatusEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "IdentifyNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->IdentifyNo = malloc(sizeof(*(entry->IdentifyNo)));
    res = build_to_priv_device_InterfaceIdentify(
        childval,
        entry->IdentifyNo);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "AuthorizationState");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->AuthorizationState = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "UserMAC");
  entry->UserMAC = malloc(sizeof(*entry->UserMAC));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->UserMAC = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "UserName");
  entry->UserName = malloc(sizeof(*entry->UserName));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->UserName = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "IdleTimeout");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->IdleTimeout = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "SessionTimeout");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->SessionTimeout = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "LastStateChange");
  entry->LastStateChange = malloc(sizeof(*entry->LastStateChange));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->LastStateChange = VAL_STRING(childval);
  }
  return res;
}
status_t build_to_priv_portauthentication_UserStatus(
    val_value_t *parentval,
    struct portauthenticationpb_UserStatus *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "List");
  entry->List_Len = 0;
  entry->List = malloc(sizeof(*entry->List));
  if (childval != NULL && childval->res == NO_ERR) {
    entry->List_Len = dlq_count(&childval->v.childQ);
    entry->List = malloc((entry->List_Len + 1) * sizeof(*entry->List));
    unsigned int cnt = 0;
    val_value_t *listval = NULL;
    for (listval = (val_value_t *)dlq_firstEntry(&childval->v.childQ);
         listval != NULL;
         listval = (val_value_t *)dlq_nextEntry(listval)) {
      /* message */
      entry->List[cnt] = malloc(sizeof(*(entry->List[cnt])));
      res = build_to_priv_portauthentication_UserStatusEntry(
          listval,
          entry->List[cnt]);
      if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      cnt++;
    }
  }
  return res;
}
status_t build_to_priv_portauthentication_UserStatusEntry(
    val_value_t *parentval,
    struct portauthenticationpb_UserStatusEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "EntryState");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->EntryState = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "AuthorizationState");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->AuthorizationState = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "AuthorizationMode");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->AuthorizationMode = VAL_ENUM(childval);
  }
  childval = val_first_child_name(
      parentval,
      "IdentifyNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->IdentifyNo = malloc(sizeof(*(entry->IdentifyNo)));
    res = build_to_priv_device_InterfaceIdentify(
        childval,
        entry->IdentifyNo);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "UserMAC");
  entry->UserMAC = malloc(sizeof(*entry->UserMAC));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->UserMAC = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "UserName");
  entry->UserName = malloc(sizeof(*entry->UserName));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->UserName = VAL_STRING(childval);
  }
  childval = val_first_child_name(
      parentval,
      "VlanID");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->VlanID = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "IdleTimeout");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->IdleTimeout = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "SessionTimeout");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->SessionTimeout = VAL_INT(childval);
  }
  childval = val_first_child_name(
      parentval,
      "LoginTimeStamp");
  entry->LoginTimeStamp = malloc(sizeof(*entry->LoginTimeStamp));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->LoginTimeStamp = VAL_STRING(childval);
  }
  return res;
}
status_t build_to_priv_portauthentication_LearnMACNowEntry(
    val_value_t *parentval,
    struct portauthenticationpb_LearnMACNowEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "IdentifyNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->IdentifyNo = malloc(sizeof(*(entry->IdentifyNo)));
    res = build_to_priv_device_InterfaceIdentify(
        childval,
        entry->IdentifyNo);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "Amount");
  if (childval != NULL && childval->res == NO_ERR) {
    /* int32 */
    entry->Amount = VAL_INT(childval);
  }
  return res;
}
status_t build_to_priv_portauthentication_UnauthorizeMACEntry(
    val_value_t *parentval,
    struct portauthenticationpb_UnauthorizeMACEntry *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "IdentifyNo");
  if (childval != NULL && childval->res == NO_ERR) {
    /* message */
    entry->IdentifyNo = malloc(sizeof(*(entry->IdentifyNo)));
    res = build_to_priv_device_InterfaceIdentify(
        childval,
        entry->IdentifyNo);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }
  childval = val_first_child_name(
      parentval,
      "MACAddress");
  entry->MACAddress = malloc(sizeof(*entry->MACAddress));
  if (childval != NULL && childval->res == NO_ERR) {
    /* string */
    entry->MACAddress = VAL_STRING(childval);
  }
  return res;
}
