
/*
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.13-0

  Combined SIL module
  module intri-device
  revision 2022-05-24
  namespace http://intri.com.tw
  organization Intrising Inc.

 */

#include <libxml/xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "status.h"
#include "intri-device@2022-05-24.h"

/* module static variables */
static ncx_module_t *intri_device_mod;
static obj_template_t *intri_device_obj;

/* put your static variables here */

/********************************************************************
* FUNCTION y_intri_device_init_static_vars
*
* initialize module static variables
*
********************************************************************/
static void y_intri_device_init_static_vars (void)
{
  intri_device_mod = NULL;
  intri_device_obj = NULL;

  /* init your static variables here */

} /* y_intri_device_init_static_vars */

/********************************************************************
* FUNCTION intri_device_intri_device_mac_addr_mac_addr_get
*
* Get database object callback
* Path: /intri-device/mac-addr/mac-addr
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_mac_addr_mac_addr_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *mac_addr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_mac_addr_mac_addr_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the mac_addr var here, change EMPTY_STRING */
  mac_addr = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    mac_addr);

  return res;

} /* intri_device_intri_device_mac_addr_mac_addr_get */

/********************************************************************
* FUNCTION intri_device_intri_device_mac_addr_mro
*
* Make read-only child nodes
* Path: /intri-device/mac-addr
*
* INPUTS:
*     parentval == the parent struct to use for new child nodes
*
* RETURNS:
*     error status
********************************************************************/
static status_t
  intri_device_intri_device_mac_addr_mro (val_value_t *parentval)
{
  status_t res = NO_ERR;
  val_value_t *childval = NULL;


  /* add /intri-device/mac-addr/mac-addr */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_mac_addr,
    intri_device_intri_device_mac_addr_mac_addr_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_mac_addr_mro */

/********************************************************************
* FUNCTION intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_Type_get
*
* Get database object callback
* Path: /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_Type
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_Type_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *InterfaceIdentify_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_Type_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_Type var here, change enum */
  InterfaceIdentify_Type = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    InterfaceIdentify_Type);

  return res;

} /* intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_Type_get */

/********************************************************************
* FUNCTION intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get
*
* Get database object callback
* Path: /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_DeviceID
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int32 InterfaceIdentify_DeviceID;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_DeviceID var here, change zero */
  InterfaceIdentify_DeviceID = 0;
  VAL_INT(dstval) = InterfaceIdentify_DeviceID;

  return res;

} /* intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get */

/********************************************************************
* FUNCTION intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get
*
* Get database object callback
* Path: /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_PortNo
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int32 InterfaceIdentify_PortNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_PortNo var here, change zero */
  InterfaceIdentify_PortNo = 0;
  VAL_INT(dstval) = InterfaceIdentify_PortNo;

  return res;

} /* intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get */

/********************************************************************
* FUNCTION intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get
*
* Get database object callback
* Path: /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_LAGNo
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int32 InterfaceIdentify_LAGNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_LAGNo var here, change zero */
  InterfaceIdentify_LAGNo = 0;
  VAL_INT(dstval) = InterfaceIdentify_LAGNo;

  return res;

} /* intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get */

/********************************************************************
* FUNCTION intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get
*
* Get database object callback
* Path: /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_VlanID
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int32 InterfaceIdentify_VlanID;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_VlanID var here, change zero */
  InterfaceIdentify_VlanID = 0;
  VAL_INT(dstval) = InterfaceIdentify_VlanID;

  return res;

} /* intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get */

/********************************************************************
* FUNCTION intri_device_intri_device_port_list_List_IdentifyNo_mro
*
* Make read-only child nodes
* Path: /intri-device/port-list/List/IdentifyNo
*
* INPUTS:
*     parentval == the parent struct to use for new child nodes
*
* RETURNS:
*     error status
********************************************************************/
static status_t
  intri_device_intri_device_port_list_List_IdentifyNo_mro (val_value_t *parentval)
{
  status_t res = NO_ERR;
  val_value_t *childval = NULL;


  /* add /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_Type */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_InterfaceIdentify_Type,
    intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_Type_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_DeviceID */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_InterfaceIdentify_DeviceID,
    intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_PortNo */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_InterfaceIdentify_PortNo,
    intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_LAGNo */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_InterfaceIdentify_LAGNo,
    intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_VlanID */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_InterfaceIdentify_VlanID,
    intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_port_list_List_IdentifyNo_mro */

/********************************************************************
* FUNCTION intri_device_intri_device_port_list_mro
*
* Make read-only child nodes
* Path: /intri-device/port-list
*
* INPUTS:
*     parentval == the parent struct to use for new child nodes
*
* RETURNS:
*     error status
********************************************************************/
static status_t
  intri_device_intri_device_port_list_mro (val_value_t *parentval)
{
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* container port-list not handled!!! */

  return res;

} /* intri_device_intri_device_port_list_mro */

/********************************************************************
* FUNCTION intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_Type_get
*
* Get database object callback
* Path: /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_Type
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_Type_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *InterfaceIdentify_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_Type_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_Type var here, change enum */
  InterfaceIdentify_Type = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    InterfaceIdentify_Type);

  return res;

} /* intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_Type_get */

/********************************************************************
* FUNCTION intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get
*
* Get database object callback
* Path: /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_DeviceID
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int32 InterfaceIdentify_DeviceID;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_DeviceID var here, change zero */
  InterfaceIdentify_DeviceID = 0;
  VAL_INT(dstval) = InterfaceIdentify_DeviceID;

  return res;

} /* intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get */

/********************************************************************
* FUNCTION intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get
*
* Get database object callback
* Path: /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_PortNo
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int32 InterfaceIdentify_PortNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_PortNo var here, change zero */
  InterfaceIdentify_PortNo = 0;
  VAL_INT(dstval) = InterfaceIdentify_PortNo;

  return res;

} /* intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get */

/********************************************************************
* FUNCTION intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get
*
* Get database object callback
* Path: /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_LAGNo
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int32 InterfaceIdentify_LAGNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_LAGNo var here, change zero */
  InterfaceIdentify_LAGNo = 0;
  VAL_INT(dstval) = InterfaceIdentify_LAGNo;

  return res;

} /* intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get */

/********************************************************************
* FUNCTION intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get
*
* Get database object callback
* Path: /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_VlanID
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int32 InterfaceIdentify_VlanID;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_VlanID var here, change zero */
  InterfaceIdentify_VlanID = 0;
  VAL_INT(dstval) = InterfaceIdentify_VlanID;

  return res;

} /* intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get */

/********************************************************************
* FUNCTION intri_device_intri_device_lag_port_list_List_IdentifyNo_mro
*
* Make read-only child nodes
* Path: /intri-device/lag-port-list/List/IdentifyNo
*
* INPUTS:
*     parentval == the parent struct to use for new child nodes
*
* RETURNS:
*     error status
********************************************************************/
static status_t
  intri_device_intri_device_lag_port_list_List_IdentifyNo_mro (val_value_t *parentval)
{
  status_t res = NO_ERR;
  val_value_t *childval = NULL;


  /* add /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_Type */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_InterfaceIdentify_Type,
    intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_Type_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_DeviceID */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_InterfaceIdentify_DeviceID,
    intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_PortNo */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_InterfaceIdentify_PortNo,
    intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_LAGNo */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_InterfaceIdentify_LAGNo,
    intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_VlanID */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_InterfaceIdentify_VlanID,
    intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_lag_port_list_List_IdentifyNo_mro */

/********************************************************************
* FUNCTION intri_device_intri_device_lag_port_list_mro
*
* Make read-only child nodes
* Path: /intri-device/lag-port-list
*
* INPUTS:
*     parentval == the parent struct to use for new child nodes
*
* RETURNS:
*     error status
********************************************************************/
static status_t
  intri_device_intri_device_lag_port_list_mro (val_value_t *parentval)
{
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* container lag-port-list not handled!!! */

  return res;

} /* intri_device_intri_device_lag_port_list_mro */

/********************************************************************
* FUNCTION intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_Type_get
*
* Get database object callback
* Path: /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_Type
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_Type_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *InterfaceIdentify_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_Type_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_Type var here, change enum */
  InterfaceIdentify_Type = EMPTY_STRING;
  res = val_set_simval_obj(
    dstval,
    dstval->obj,
    InterfaceIdentify_Type);

  return res;

} /* intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_Type_get */

/********************************************************************
* FUNCTION intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get
*
* Get database object callback
* Path: /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_DeviceID
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int32 InterfaceIdentify_DeviceID;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_DeviceID var here, change zero */
  InterfaceIdentify_DeviceID = 0;
  VAL_INT(dstval) = InterfaceIdentify_DeviceID;

  return res;

} /* intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get */

/********************************************************************
* FUNCTION intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get
*
* Get database object callback
* Path: /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_PortNo
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int32 InterfaceIdentify_PortNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_PortNo var here, change zero */
  InterfaceIdentify_PortNo = 0;
  VAL_INT(dstval) = InterfaceIdentify_PortNo;

  return res;

} /* intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get */

/********************************************************************
* FUNCTION intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get
*
* Get database object callback
* Path: /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_LAGNo
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int32 InterfaceIdentify_LAGNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_LAGNo var here, change zero */
  InterfaceIdentify_LAGNo = 0;
  VAL_INT(dstval) = InterfaceIdentify_LAGNo;

  return res;

} /* intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get */

/********************************************************************
* FUNCTION intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get
*
* Get database object callback
* Path: /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_VlanID
* Fill in 'dstval' contents
*
* INPUTS:
*     see ncx/getcb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get (
  ses_cb_t *scb,
  getcb_mode_t cbmode,
  const val_value_t *virval,
  val_value_t *dstval)
{
  status_t res = NO_ERR;
  int32 InterfaceIdentify_VlanID;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get callback");
  }


  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_VlanID var here, change zero */
  InterfaceIdentify_VlanID = 0;
  VAL_INT(dstval) = InterfaceIdentify_VlanID;

  return res;

} /* intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get */

/********************************************************************
* FUNCTION intri_device_intri_device_poe_port_list_List_IdentifyNo_mro
*
* Make read-only child nodes
* Path: /intri-device/poe-port-list/List/IdentifyNo
*
* INPUTS:
*     parentval == the parent struct to use for new child nodes
*
* RETURNS:
*     error status
********************************************************************/
static status_t
  intri_device_intri_device_poe_port_list_List_IdentifyNo_mro (val_value_t *parentval)
{
  status_t res = NO_ERR;
  val_value_t *childval = NULL;


  /* add /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_Type */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_InterfaceIdentify_Type,
    intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_Type_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_DeviceID */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_InterfaceIdentify_DeviceID,
    intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_PortNo */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_InterfaceIdentify_PortNo,
    intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_LAGNo */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_InterfaceIdentify_LAGNo,
    intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_VlanID */
  childval = agt_make_virtual_leaf(
    parentval->obj,
    y_intri_device_N_InterfaceIdentify_VlanID,
    intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get,
    &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_poe_port_list_List_IdentifyNo_mro */

/********************************************************************
* FUNCTION intri_device_intri_device_poe_port_list_mro
*
* Make read-only child nodes
* Path: /intri-device/poe-port-list
*
* INPUTS:
*     parentval == the parent struct to use for new child nodes
*
* RETURNS:
*     error status
********************************************************************/
static status_t
  intri_device_intri_device_poe_port_list_mro (val_value_t *parentval)
{
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* container poe-port-list not handled!!! */

  return res;

} /* intri_device_intri_device_poe_port_list_mro */


/********************************************************************
* FUNCTION intri_device_intri_device_mro
*
* Make read-only top-level node
* Path: /intri-device
*
* RETURNS:
*     error status
********************************************************************/
static status_t
  intri_device_intri_device_mro (void)
{
  val_value_t *parentval = NULL, *childval = NULL;
  status_t res = NO_ERR;


  /* add /intri-device */
  res = agt_add_top_container(intri_device_obj, &parentval);
  if (res != NO_ERR) {
    return res;
  }
  res = agt_add_container(
    y_intri_device_M_intri_device,
    y_intri_device_N_mac_addr,
    parentval,
    &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_mac_addr_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
    y_intri_device_M_intri_device,
    y_intri_device_N_port_list,
    parentval,
    &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_port_list_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
    y_intri_device_M_intri_device,
    y_intri_device_N_lag_port_list,
    parentval,
    &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_lag_port_list_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
    y_intri_device_M_intri_device,
    y_intri_device_N_poe_port_list,
    parentval,
    &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_poe_port_list_mro(childval);
  if (res != NO_ERR) {
    return res;
  }


  return res;

} /* intri_device_intri_device_mro */

/********************************************************************
* FUNCTION y_intri_device_init
*
* initialize the intri-device server instrumentation library
*
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
*
* RETURNS:
*     error status
********************************************************************/
status_t y_intri_device_init (
  const xmlChar *modname,
  const xmlChar *revision)
{
  status_t res = NO_ERR;
  agt_profile_t *agt_profile = agt_get_profile();

  y_intri_device_init_static_vars();

  /* change if custom handling done */
  if (xml_strcmp(modname, y_intri_device_M_intri_device)) {
    return ERR_NCX_UNKNOWN_MODULE;
  }

  if (revision && xml_strcmp(revision, y_intri_device_R_intri_device)) {
    return ERR_NCX_WRONG_VERSION;
  }
  res = ncxmod_load_module(
    y_intri_device_M_intri_device,
    y_intri_device_R_intri_device,
    &agt_profile->agt_savedevQ,
    &intri_device_mod);
  if (res != NO_ERR) {
    return res;
  }

  intri_device_obj = ncx_find_object(
    intri_device_mod,
    y_intri_device_N_intri_device);
  if (intri_device_mod == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  /* put your module initialization code here */

  return res;
} /* y_intri_device_init */

/********************************************************************
* FUNCTION y_intri_device_init2
*
* SIL init phase 2: non-config data structures
* Called after running config is loaded
*
* RETURNS:
*     error status
********************************************************************/
status_t y_intri_device_init2 (void)
{
  status_t res = NO_ERR;

  res = intri_device_intri_device_mro();
  if (res != NO_ERR) {
    return res;
  }

  /* put your init2 code here */

  return res;
} /* y_intri_device_init2 */

/********************************************************************
* FUNCTION y_intri_device_cleanup
*    cleanup the server instrumentation library
*
********************************************************************/
void y_intri_device_cleanup (void)
{
  /* put your cleanup code here */

} /* y_intri_device_cleanup */

/* END intri_device.c */
