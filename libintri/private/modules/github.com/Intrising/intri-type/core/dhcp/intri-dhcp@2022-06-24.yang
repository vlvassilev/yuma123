module intri-dhcp {

  namespace "intri:intri-dhcp";
  prefix "intri-dhcp";
  organization "
    Intrising Inc.";
  contact "
    intrising@intrising.com.tw";
  revision 2022-06-24 {
    description "Build date.";
  }

  import intri-device {
    prefix intri-device;
  }
  import intri-empty {
    prefix intri-empty;
  }
  typedef RemoteIDSourceTypeOptions {
    type enumeration {
      enum REMOTE_ID_SOURCE_TYPE_HOSTNAME {
        description "[Hostname] Hostname of this switch";
        value 0;
      }
      enum REMOTE_ID_SOURCE_TYPE_MAC_ADDRESS {
        description "[MacAddress] MAC address of this switch";
        value 1;
      }
      enum REMOTE_ID_SOURCE_TYPE_SYS_NAME {
        description "[SysName] SNMP sysName of this switch";
        value 2;
      }
      enum REMOTE_ID_SOURCE_TYPE_USER_DEFINED {
        description "[User defined] A user defined string as defined in custom remote ID is used";
        value 3;
      }
      enum REMOTE_ID_SOURCE_TYPE_PORT_ALIAS {
        description "[Port alias] The port alias value of the incoming port is used";
        value 4;
      }
    }
  }
  typedef CircuitIDSourceTypeOptions {
    type enumeration {
      enum CIRCUIT_ID_SOURCE_TYPE_PORT_ALIAS {
        description "[Port alias] Use port alias as the circuit ID";
        value 0;
      }
      enum CIRCUIT_ID_SOURCE_TYPE_IP_PORT_VLAN {
        description "[IP-Port-VLAN] Use the format {IP}-{port}-{VLANID} as the circuit ID";
        value 1;
      }
    }
  }
  typedef SnoopingPortDHCPFilteringTypeOptions {
    type enumeration {
      enum SNOOPING_PORT_DHCP_FILTERING_TYPE_DISABLED {
        description "[Disabled] DHCP frames are not removed";
        value 0;
      }
      enum SNOOPING_PORT_DHCP_FILTERING_TYPE_DROP_AND_EVENT {
        description "[Drop and event] DHCP response frames incoming from a user port are removed and a PACKET_INTERCEPTED event is send";
        value 1;
      }
      enum SNOOPING_PORT_DHCP_FILTERING_BLOCK_AND_EVENT {
        description "[Block and event] Port is blocked when an DHCP response incoming from a user port is detected. Needs operator intervention to unblock. Also a PACKET_INTERCEPTED event is send.";
        value 2;
      }
    }
  }
  typedef SnoopingPortSnoopingTrustTypeOptions {
    type enumeration {
      enum SNOOPING_PORT_SNOOPING_TYPE_TRUST_UNTRUSTED {
        description "[Untrusted] This port is untrusted and DHCP filtering applies";
        value 0;
      }
      enum SNOOPING_PORT_SNOOPING_TYPE_TRUST_TRUSTED {
        description "[Trusted] This port is trusted and no filtering occurs. Use when a DHCP server should be permitted on a local access port";
        value 1;
      }
    }
  }
  typedef SnoopingLastDropReasonTypeOptions {
    type enumeration {
      enum SNOOPING_LAST_DROP_REASON_TYPE_OK {
        description "[Ok] The packet is normal and will be forwarded";
        value 0;
      }
      enum SNOOPING_LAST_DROP_REASON_TYPE_ILLEGAL_DHCP_SERVER {
        description "[Illegal DHCP Server] Forbidden DHCP message on untrusted port";
        value 1;
      }
      enum SNOOPING_LAST_DROP_REASON_TYPE_DHCP_SERVER_SPOOFED {
        description "[DHCP Server Sproofed] Source MAC and DHCP client MAC did not match";
        value 2;
      }
      enum SNOOPING_LAST_DROP_REASON_TYPE_ILLEGAL_RELAY_AGENT {
        description "[DHCP Illegal Relay Agent]";
        value 3;
      }
      enum SNOOPING_LAST_DROP_REASON_TYPE_BINDING_MISMATCH {
        description "[DHCP Binding mismatch] DHCPRELEASE or DHCPDECLINE interface information did not match the binding table information";
        value 4;
      }
      enum SNOOPING_LAST_DROP_REASON_TYPE_FLOODING {
        description "[Flooding] Too many DHCP messages which appears to be an attack.";
        value 5;
      }
      enum SNOOPING_LAST_DROP_REASON_TYPE_DHCP_FILTERING {
        description "[DHCP Filtering] DHCP reponse is dropped by DHCP Filtering";
        value 6;
      }
    }
  }
  typedef ARPInspectionDatabaseTypeOptions {
    type enumeration {
      enum ARP_INSPECTION_DATABASE_TYPE_NONE {
        description "[None] Don't use any database";
        value 0;
      }
      enum ARP_INSPECTION_DATABASE_TYPE_DHCP {
        description "[DHCP] Use the DHCP snooping binding database as the arp inspection database";
        value 1;
      }
      enum ARP_INSPECTION_DATABASE_TYPE_ARP_ACL {
        description "[ACL] Use the ACL list as the arp inspection database";
        value 2;
      }
      enum ARP_INSPECTION_DATABASE_TYPE_BOTH {
        description "[Both] Use both DHCP and ACL";
        value 3;
      }
    }
  }
  typedef ARPInspectionACLRuleUnmatchedActionTypeOptions {
    type enumeration {
      enum ARP_INSPECTION_ACL_RULE_UNMATCHED_ACTION_TYPE_DENY {
        description "[Deny] The packet will be denied";
        value 0;
      }
      enum ARP_INSPECTION_ACL_RULE_UNMATCHED_ACTION_TYPE_PERMIT {
        description "[Permit] The packet will be passed";
        value 1;
      }
    }
  }
  typedef ARPInspectionACLRuleModeTypeOptions {
    type enumeration {
      enum ARP_INSPECTION_RULE_MODE_TYPE_UNUSED {
        description "[Unused] The ACL rule entry won't use this rule";
        value 0;
      }
      enum ARP_INSPECTION_RULE_MODE_TYPE_PERMIT {
        description "[Permit] The ACL rule entry will permit the packet if this mode is permitted";
        value 1;
      }
      enum ARP_INSPECTION_RULE_MODE_TYPE_DENY {
        description "[Deny] The ACL rule entry will deny the packet if this mode is denied";
        value 2;
      }
    }
  }
  grouping ARPInspectionConfig {
    leaf Enabled {
      mandatory "true";
      type boolean;
    }
    container Ports {
      list Ports_Entry {
        uses ARPInspectionPortEntry;
      }
    }
  }
  grouping ARPInspectionPortEntry {
    container IdentifyNo {
      uses intri-device:InterfaceIdentify;
    }
    leaf Enabled {
      mandatory "true";
      type boolean;
    }
    leaf RateLimiting {
      mandatory "true";
      type int32;
    }
    leaf Database {
      mandatory "true";
      type ARPInspectionDatabaseTypeOptions;
    }
    container ACL {
      uses ARPInspectionACLConfig;
    }
    leaf SrcMACValid {
      mandatory "true";
      type boolean;
    }
    leaf DstMACValid {
      mandatory "true";
      type boolean;
    }
    leaf IPRangeValid {
      mandatory "true";
      type boolean;
    }
  }
  grouping ARPInspectionACLConfig {
    leaf ACLRuleUnmatchedAction {
      mandatory "true";
      type ARPInspectionACLRuleUnmatchedActionTypeOptions;
    }
    container Rules {
      leaf-list Rules_Entry {
        type string;
      }
    }
  }
  grouping ARPInspectionACLRuleEntry {
    leaf VID {
      mandatory "true";
      type int32;
    }
    leaf SrcMAC {
      mandatory "true";
      type string;
    }
    leaf SrcIP {
      mandatory "true";
      type string;
    }
    leaf SrcIPMask {
      mandatory "true";
      type string;
    }
    leaf Mode {
      mandatory "true";
      type ARPInspectionACLRuleModeTypeOptions;
    }
  }
  grouping Config {
    container Relay {
      uses RelayConfig;
    }
    container Snooping {
      uses SnoopingConfig;
    }
  }
  grouping RelayConfig {
    leaf Enabled {
      mandatory "true";
      type boolean;
    }
    container RelayPorts {
      list RelayPorts_Entry {
        uses ConfigRelayPortEntry;
      }
    }
    leaf DHCPServerAddress {
      mandatory "true";
      type string;
    }
    leaf RemoteIDSource {
      mandatory "true";
      type RemoteIDSourceTypeOptions;
    }
    leaf CustomRemoteID {
      mandatory "true";
      type string;
    }
    leaf CircuitIDSource {
      mandatory "true";
      type CircuitIDSourceTypeOptions;
    }
  }
  grouping ConfigRelayPortEntry {
    container IdentifyNo {
      uses intri-device:InterfaceIdentify;
    }
    leaf Enabled {
      mandatory "true";
      type boolean;
    }
    leaf Option82Enabled {
      mandatory "true";
      type boolean;
    }
  }
  grouping SnoopingConfig {
    leaf Enabled {
      mandatory "true";
      type boolean;
    }
    container Ports {
      list Ports_Entry {
        uses SnoopingConfigPortEntry;
      }
    }
  }
  grouping SnoopingConfigPortEntry {
    container IdentifyNo {
      uses intri-device:InterfaceIdentify;
    }
    leaf Enabled {
      mandatory "true";
      type boolean;
    }
    leaf DHCPFiltering {
      mandatory "true";
      type SnoopingPortDHCPFilteringTypeOptions;
    }
    leaf SnoopingTrust {
      mandatory "true";
      type SnoopingPortSnoopingTrustTypeOptions;
    }
    leaf AcceptIngressOption82 {
      mandatory "true";
      type boolean;
    }
    leaf MACAddressVerification {
      mandatory "true";
      type boolean;
    }
    leaf DHCPRateLimiting {
      mandatory "true";
      type int32;
    }
  }
  grouping SnoopingStatisticsEntry {
    container IdentifyNo {
      uses intri-device:InterfaceIdentify;
    }
    leaf TrustMode {
      mandatory "true";
      type SnoopingPortSnoopingTrustTypeOptions;
    }
    leaf Processed {
      mandatory "true";
      type int32;
    }
    leaf Dropped {
      mandatory "true";
      type int32;
    }
    leaf LastDropReason {
      mandatory "true";
      type SnoopingLastDropReasonTypeOptions;
    }
  }
  grouping SnoopingStatisticsList {
    container List {
      list List_Entry {
        uses SnoopingStatisticsEntry;
      }
    }
  }
  grouping SnoopingBindingDatabaseEntry {
    leaf MACAddress {
      mandatory "true";
      type string;
    }
    leaf IP {
      mandatory "true";
      type string;
    }
    container IdentifyNo {
      uses intri-device:InterfaceIdentify;
    }
    leaf VID {
      mandatory "true";
      type int32;
    }
    leaf LastUpdated {
      mandatory "true";
      type string;
    }
    leaf LastUpdatedEpoch {
      mandatory "true";
      type string;
    }
    leaf LeaseTime {
      mandatory "true";
      type int64;
    }
  }
  grouping SnoopingBindingDatabaseList {
    container List {
      list List_Entry {
        uses SnoopingBindingDatabaseEntry;
      }
    }
  }
  rpc intri-dhcp-ARPInspection-GetConfig {
    output {
      uses ARPInspectionConfig;
    }
  }
  rpc intri-dhcp-ARPInspection-SetConfig {
    input {
      uses ARPInspectionConfig;
    }
  }
  rpc intri-dhcp-DHCP-GetRelayConfig {
    output {
      uses RelayConfig;
    }
  }
  rpc intri-dhcp-DHCP-GetSnoopingConfig {
    output {
      uses SnoopingConfig;
    }
  }
  rpc intri-dhcp-DHCP-SetRelayConfig {
    input {
      uses RelayConfig;
    }
  }
  rpc intri-dhcp-DHCP-SetSnoopingConfig {
    input {
      uses SnoopingConfig;
    }
  }
  rpc intri-dhcp-DHCP-RunUnblockPort {
    input {
      uses intri-device:InterfaceIdentify;
    }
  }
  rpc intri-dhcp-DHCP-GetSnoopingStatistic {
    output {
      uses SnoopingStatisticsList;
    }
  }
  rpc intri-dhcp-DHCP-GetSnoopingBindingDatabase {
    output {
      uses SnoopingBindingDatabaseList;
    }
  }
  rpc intri-dhcp-DHCP-ClearSnoopingStatistic {
  }
  rpc intri-dhcp-DHCP-ClearSnoopingBindingDatabase {
  }
}
