module sercom-device {

  namespace "sercom:sercom-device";
  prefix "sercom-device";
  organization "
    Sercomm Inc.";
  contact "
    sercomm@sercomm.com.tw";
  revision 2022-06-24 {
    description "Build date.";
  }

  import sercom-empty {
    prefix sercom-empty;
  }
  import sercom-common {
    prefix sercom-common;
  }
  typedef RCLKTypeOptions {
    type enumeration {
      enum RCLK_TYPE_0 {
        description "[RCLK 0] RCLK 0";
        value 0;
      }
      enum RCLK_TYPE_1 {
        description "[RCLK 1] RCLK 1";
        value 1;
      }
    }
  }
  typedef InputClockIndexTypeOptions {
    type enumeration {
      enum INPUT_CLOCK_INDEX_TYPE_0 {
        description "[Clock Index 0] Clock Index 0";
        value 0;
      }
      enum INPUT_CLOCK_INDEX_TYPE_1 {
        description "[Clock Index 1] Clock Index 1";
        value 1;
      }
      enum INPUT_CLOCK_INDEX_TYPE_2 {
        description "[Clock Index 2] Clock Index 2";
        value 2;
      }
      enum INPUT_CLOCK_INDEX_TYPE_3 {
        description "[Clock Index 3] Clock Index 3";
        value 3;
      }
      enum INPUT_CLOCK_INDEX_TYPE_4 {
        description "[Clock Index 4] Clock Index 4";
        value 4;
      }
      enum INPUT_CLOCK_INDEX_TYPE_5 {
        description "[Clock Index 5] Clock Index 5";
        value 5;
      }
      enum INPUT_CLOCK_INDEX_TYPE_6 {
        description "[Clock Index 6] Clock Index 6";
        value 6;
      }
      enum INPUT_CLOCK_INDEX_TYPE_7 {
        description "[Clock Index 7] Clock Index 7";
        value 7;
      }
      enum INPUT_CLOCK_INDEX_TYPE_8 {
        description "[Clock Index 8] Clock Index 8";
        value 8;
      }
      enum INPUT_CLOCK_INDEX_TYPE_9 {
        description "[Clock Index 9] Clock Index 9";
        value 9;
      }
      enum INPUT_CLOCK_INDEX_TYPE_10 {
        description "[Clock Index 10] Clock Index 10";
        value 10;
      }
      enum INPUT_CLOCK_INDEX_TYPE_11 {
        description "[Clock Index 11] Clock Index 11";
        value 11;
      }
      enum INPUT_CLOCK_INDEX_TYPE_12 {
        description "[Clock Index 12] Clock Index 12";
        value 12;
      }
      enum INPUT_CLOCK_INDEX_TYPE_13 {
        description "[Clock Index 13] Clock Index 13";
        value 13;
      }
      enum INPUT_CLOCK_INDEX_TYPE_14 {
        description "[Clock Index 14] Clock Index 14";
        value 14;
      }
      enum INPUT_CLOCK_INDEX_TYPE_15 {
        description "[Clock Index 15] Clock Index 15";
        value 15;
      }
    }
  }
  typedef InputClockTypeOptions {
    type enumeration {
      enum INPUT_CLOCK_TYPE_MAC_CLOCK_0 {
        description "[MAC Clock 0] MAC Clock 0";
        value 0;
      }
      enum INPUT_CLOCK_TYPE_MAC_CLOCK_1 {
        description "[MAC Clock 1] MAC Clock 1";
        value 1;
      }
      enum INPUT_CLOCK_TYPE_PHY_A_CLOCK_0 {
        description "[PHY A Clock 0] PHY A Clock 0";
        value 2;
      }
      enum INPUT_CLOCK_TYPE_PHY_A_CLOCK_1 {
        description "[PHY A Clock 1] PHY A Clock 1";
        value 3;
      }
      enum INPUT_CLOCK_TYPE_PHY_B_CLOCK_0 {
        description "[PHY B Clock 0] PHY B Clock 0";
        value 4;
      }
      enum INPUT_CLOCK_TYPE_PHY_B_CLOCK_1 {
        description "[PHY B Clock 1] PHY B Clock 1";
        value 5;
      }
      enum INPUT_CLOCK_TYPE_PHY_C_CLOCK_0 {
        description "[PHY C Clock 0] PHY C Clock 0";
        value 6;
      }
      enum INPUT_CLOCK_TYPE_PHY_C_CLOCK_1 {
        description "[PHY C Clock 1] PHY C Clock 1";
        value 7;
      }
      enum INPUT_CLOCK_TYPE_BITS_IN {
        description "[Bits In] Bits In";
        value 8;
      }
      enum INPUT_CLOCK_TYPE_1PPS_GPS {
        description "[1pps GPS] 1pps GPS";
        value 10;
      }
      enum INPUT_CLOCK_TYPE_1PPS_IN {
        description "[1pps In] 1pps In";
        value 11;
      }
      enum INPUT_CLOCK_TYPE_10MHZ_IN {
        description "[10Mhz In] 10Mhz In";
        value 12;
      }
      enum INPUT_CLOCK_TYPE_1PPS_FEEDBACK {
        description "[1pps Feedback] 1pps Feedback";
        value 13;
      }
    }
  }
  typedef LedTypeOptions {
    type enumeration {
      enum LED_TYPE_OFF {
        description "[Off]";
        value 0;
      }
      enum LED_TYPE_ON {
        description "[On]";
        value 1;
      }
      enum LED_TYPE_ORANGE {
        description "[Orange]";
        value 2;
      }
      enum LED_TYPE_GREEN {
        description "[Green]";
        value 3;
      }
    }
  }
  typedef PhyInterfaceTypeOptions {
    type enumeration {
      enum PHY_INTERFACE_TYPE_SMI {
        description "[Smi]";
        value 0;
      }
      enum PHY_INTERFACE_TYPE_XSMI {
        description "[Xsmi]";
        value 1;
      }
      enum PHY_INTERFACE_TYPE_UNUSED {
        description "[Unused]";
        value 2;
      }
    }
  }
  typedef FactoryHwFeatureTypeOptions {
    type enumeration {
      enum FACTORY_HW_FEATURE_TYPE_POE_PLUS_PLUS {
        description "[PoE++] Power over Ethernet plus (30W ports) supported";
        value 0;
      }
      enum FACTORY_HW_FEATURE_TYPE_POE_PLUS {
        description "[PoE+] Power over Ethernet plus (30W ports) supported";
        value 1;
      }
      enum FACTORY_HW_FEATURE_TYPE_EEE {
        description "[EEE] Energy Efficient Ethernet";
        value 2;
      }
      enum FACTORY_HW_FEATURE_TYPE_RTC {
        description "[RTC] Local real time clock";
        value 3;
      }
      enum FACTORY_HW_FEATURE_TYPE_SFP {
        description "[SFP] Pluggable optical port";
        value 4;
      }
    }
  }
  typedef PortPropertyTypeOptions {
    type enumeration {
      enum PORT_PROPERTIES_TYPE_10M_FULL {
        description "[10M FULL] This port is capable of running at 10Mbit/s";
        value 0;
      }
      enum PORT_PROPERTIES_TYPE_10M_HALF {
        description "[10M HALF] This port is capable of running at 10Mbit/s";
        value 1;
      }
      enum PORT_PROPERTIES_TYPE_100M_FULL {
        description "[100M FULL] This port is capable of running at 100Mbit/s";
        value 2;
      }
      enum PORT_PROPERTIES_TYPE_100M_HALF {
        description "[100M HALF] This port is capable of running at 100Mbit/s";
        value 3;
      }
      enum PORT_PROPERTIES_TYPE_1000M_FULL {
        description "[1G FULL] This port is capable of running at 1000Mbit/s";
        value 4;
      }
      enum PORT_PROPERTIES_TYPE_2500M_FULL {
        description "[2.5G FULL] This port is capable of running at 2500Mbit/s";
        value 5;
      }
      enum PORT_PROPERTIES_TYPE_5G_FULL {
        description "[5G FULL] This port is capable of running at 5Gbit/s";
        value 6;
      }
      enum PORT_PROPERTIES_TYPE_10G_FULL {
        description "[10G FULL] This port is capable of running at 10Gbit/s";
        value 7;
      }
      enum PORT_PROPERTIES_TYPE_25G_FULL {
        description "[25G FULL] This port is capable of running at 25Gbit/s";
        value 8;
      }
      enum PORT_PROPERTIES_TYPE_RJ45 {
        description "[RJ45] This port uses as RJ45 connector";
        value 9;
      }
      enum PORT_PROPERTIES_TYPE_SFP {
        description "[SFP] This port uses a pluggable SFP";
        value 10;
      }
      enum PORT_PROPERTIES_TYPE_POE {
        description "[PoE] This port is capable to supply Power over Ethernet (PoE)";
        value 11;
      }
      enum PORT_PROPERTIES_TYPE_POE_PLUS {
        description "[PoE+] This port is capable to supply Power over Ethernet Extended (PoE+)";
        value 12;
      }
      enum PORT_PROPERTIES_TYPE_POE_PLUS_PLUS {
        description "[PoE++] This port is capable to supply Power over Ethernet Extended (PoE+)";
        value 13;
      }
      enum PORT_PROPERTIES_TYPE_LINK_PORT {
        description "[Link Port] This port is capable to supply Power over Ethernet Extended (PoE+)";
        value 14;
      }
    }
  }
  typedef DevicePortSpeedDuplexTypeOptions {
    type enumeration {
      enum DEVICE_PORT_SPEED_DUPLEX_TYPE_AUTO {
        description "[Auto]";
        value 0;
      }
      enum DEVICE_PORT_SPEED_DUPLEX_TYPE_10M_FULL {
        description "[10 Mbps / Full]";
        value 1;
      }
      enum DEVICE_PORT_SPEED_DUPLEX_TYPE_10M_HALF {
        description "[10 Mbps / Half]";
        value 2;
      }
      enum DEVICE_PORT_SPEED_DUPLEX_TYPE_100M_FULL {
        description "[100 Mbps / Full]";
        value 3;
      }
      enum DEVICE_PORT_SPEED_DUPLEX_TYPE_100M_HALF {
        description "[100 Mbps / Half]";
        value 4;
      }
      enum DEVICE_PORT_SPEED_DUPLEX_TYPE_1000M_FULL {
        description "[1 Gbps  / Full]";
        value 5;
      }
      enum DEVICE_PORT_SPEED_DUPLEX_TYPE_2500M_FULL {
        description "[2.5 Gbps / Full]";
        value 6;
      }
      enum DEVICE_PORT_SPEED_DUPLEX_TYPE_5G_FULL {
        description "[5 Gbps / Full]";
        value 7;
      }
      enum DEVICE_PORT_SPEED_DUPLEX_TYPE_10G_FULL {
        description "[10 Gbps / Full]";
        value 8;
      }
      enum DEVICE_PORT_SPEED_DUPLEX_TYPE_25G_FULL {
        description "[25 Gbps / Full]";
        value 9;
      }
      enum DEVICE_PORT_SPEED_DUPLEX_TYPE_40G_FULL {
        description "[40 Gbps / Full]";
        value 10;
      }
      enum DEVICE_PORT_SPEED_DUPLEX_TYPE_100G_FULL {
        description "[100 Gbps / Full]";
        value 11;
      }
      enum DEVICE_PORT_SPEED_DUPLEX_TYPE_NA {
        description "[NA]";
        value 12;
      }
    }
  }
  typedef PortInterfaceTypeOptions {
    type enumeration {
      enum PORT_INTERFACE_TYPE_COPPER {
        description "[Copper] Normal copper interface";
        value 0;
      }
      enum PORT_INTERFACE_TYPE_OPTICAL {
        description "[Optical] Optical interface";
        value 1;
      }
    }
  }
  typedef DeviceTypeOptions {
    type enumeration {
      enum DEVICE_TYPE_MCU {
        description "[MCU] MCU";
        value 0;
      }
      enum DEVICE_TYPE_I2C {
        description "[I2C] I2C";
        value 1;
      }
      enum DEVICE_TYPE_GPIO {
        description "[GPIO] GPIO";
        value 2;
      }
    }
  }
  typedef MonitorTypeOptions {
    type enumeration {
      enum MONITOR_TYPE_TEMP_OK {
        description "[Temperature Normal] Temperature Normal";
        value 0;
      }
      enum MONITOR_TYPE_TEMP_WARN {
        description "[Temperature Warning] Temperature Warning";
        value 1;
      }
      enum MONITOR_TYPE_FAN_OK {
        description "[Fan Speed Ok] Fan Speed Ok";
        value 2;
      }
      enum MONITOR_TYPE_FAN_WARN {
        description "[Fan Speed Warn] Fan Speed Warn";
        value 3;
      }
    }
  }
  typedef PSUTypeOptions {
    type enumeration {
      enum PSU_TYPE_LOCATION_OK {
        description "[Location Ok] Location Ok";
        value 0;
      }
      enum PSU_TYPE_LOCATION_WARN {
        description "[Location Warn] Location Warn";
        value 1;
      }
      enum PSU_TYPE_AC_OK {
        description "[AC Ok] AC Ok";
        value 2;
      }
      enum PSU_TYPE_AC_WARN {
        description "[AC Warning] AC Warning";
        value 3;
      }
      enum PSU_TYPE_PW_OK {
        description "[Power Ok] Power Ok";
        value 4;
      }
      enum PSU_TYPE_PW_WARN {
        description "[Power Warning] Power Warning";
        value 5;
      }
      enum PSU_TYPE_FAIL {
        description "[PSU Failed] Failed";
        value 6;
      }
    }
  }
  typedef FanTypeOptions {
    type enumeration {
      enum FAN_TYPE_RPM {
        description "[RPM] RPM";
        value 0;
      }
    }
  }
  typedef FanDeviceTypeOptions {
    type enumeration {
      enum FAN_DEVICE_TYPE_RPM {
        description "[RPM] RPM";
        value 0;
      }
    }
  }
  typedef PoEDeviceTypeOptions {
    type enumeration {
      enum POE_DEVICE_TYPE_I2C {
        description "[I2C] I2C";
        value 0;
      }
      enum POE_DEVICE_TYPE_UART {
        description "[UART] UART";
        value 1;
      }
    }
  }
  typedef BoundaryTypeOptions {
    type enumeration {
      enum BOUNDARY_TYPE_INT {
        description "[Int]";
        value 0;
      }
      enum BOUNDARY_TYPE_DOUBLE {
        description "[Double]";
        value 1;
      }
    }
  }
  typedef LayerTypeOptions {
    type enumeration {
      enum LAYER_TYPE_L2 {
        description "[L2]";
        value 0;
      }
      enum LAYER_TYPE_L3 {
        description "[L3]";
        value 1;
      }
    }
  }
  typedef InterfaceTypeOptions {
    type enumeration {
      enum INTERFACE_TYPE_VLAN {
        description "[VLAN]";
        value 0;
      }
      enum INTERFACE_TYPE_PORT {
        description "[Port]";
        value 1;
      }
      enum INTERFACE_TYPE_TRUNK {
        description "[LAG]";
        value 2;
      }
      enum INTERFACE_TYPE_MULTICAST {
        description "[Multicast]";
        value 3;
      }
    }
  }
  grouping LedInfo {
    leaf Name {
      mandatory "true";
      type string;
    }
    leaf PortNo {
      mandatory "true";
      type int32;
    }
    leaf Type {
      mandatory "true";
      type DeviceTypeOptions;
    }
    leaf Direction {
      mandatory "true";
      type string;
    }
    choice Device {
    mandatory "true";
      container LEDDevice {
        uses MCULedDevice;
      }
      container I2CDevice {
        uses I2CDevice;
      }
      container GPIODevice {
        uses GPIODevice;
      }
    }
  }
  grouping MonitorInfo {
    leaf Name {
      mandatory "true";
      type string;
    }
    leaf Type {
      mandatory "true";
      type DeviceTypeOptions;
    }
    leaf Direction {
      mandatory "true";
      type string;
    }
    choice Device {
    mandatory "true";
      container MonitorDevice {
        uses MCUMonitorDevice;
      }
      container I2CDevice {
        uses I2CDevice;
      }
      container GPIODevice {
        uses GPIODevice;
      }
    }
  }
  grouping PSUInfo {
    leaf Name {
      mandatory "true";
      type string;
    }
    leaf Type {
      mandatory "true";
      type DeviceTypeOptions;
    }
    leaf Direction {
      mandatory "true";
      type string;
    }
    choice Device {
    mandatory "true";
      container PSUDevice {
        uses MCUPSUDevice;
      }
      container I2CDevice {
        uses I2CDevice;
      }
      container GPIODevice {
        uses GPIODevice;
      }
    }
  }
  grouping MCULedDevice {
    leaf I2CAddr {
      mandatory "true";
      type int32;
    }
    leaf AddrRegister {
      mandatory "true";
      type int32;
    }
    leaf LedAction {
      mandatory "true";
      type LedTypeOptions;
    }
    leaf ActiveBit {
      mandatory "true";
      type int32;
    }
  }
  grouping MCUMonitorDevice {
    leaf I2CAddr {
      mandatory "true";
      type int32;
    }
    leaf AddrRegister {
      mandatory "true";
      type int32;
    }
    leaf MonitorAction {
      mandatory "true";
      type MonitorTypeOptions;
    }
    leaf ActiveBit {
      mandatory "true";
      type int32;
    }
  }
  grouping MCUPSUDevice {
    leaf I2CAddr {
      mandatory "true";
      type int32;
    }
    leaf AddrRegister {
      mandatory "true";
      type int32;
    }
    leaf PSUAction {
      mandatory "true";
      type PSUTypeOptions;
    }
    leaf ActiveBit {
      mandatory "true";
      type int32;
    }
  }
  grouping MCUFanDevice {
    leaf I2CAddr {
      mandatory "true";
      type int32;
    }
    leaf AddrRegister {
      mandatory "true";
      type int32;
    }
    leaf FANAction {
      mandatory "true";
      type FanTypeOptions;
    }
    leaf ActiveBit {
      mandatory "true";
      type int32;
    }
  }
  grouping I2CDevice {
    leaf I2CAddr {
      mandatory "true";
      type int32;
    }
    leaf AddrRegister {
      mandatory "true";
      type int32;
    }
    leaf Action {
      mandatory "true";
      type int32;
    }
    leaf ActiveBit {
      mandatory "true";
      type int32;
    }
  }
  grouping GPIODevice {
    leaf Register {
      mandatory "true";
      type int32;
    }
    leaf Pin {
      mandatory "true";
      type int32;
    }
    leaf Action {
      mandatory "true";
      type boolean;
    }
    leaf Enable {
      mandatory "true";
      type boolean;
    }
  }
  grouping I2Cinfo {
    leaf Name {
      mandatory "true";
      type string;
    }
    leaf Direction {
      mandatory "true";
      type string;
    }
    container Device {
      uses I2CDevice;
    }
  }
  grouping GPIOInfo {
    leaf Name {
      mandatory "true";
      type string;
    }
    leaf Direction {
      mandatory "true";
      type string;
    }
    container Device {
      uses GPIODevice;
    }
  }
  grouping PTPClockSynchronizerInfo {
    leaf Name {
      mandatory "true";
      type string;
    }
    leaf Direction {
      mandatory "true";
      type string;
    }
    container Device {
      uses I2CDevice;
    }
  }
  grouping GPSInfo {
    leaf Name {
      mandatory "true";
      type string;
    }
    leaf Path {
      mandatory "true";
      type string;
    }
    leaf Direction {
      mandatory "true";
      type string;
    }
  }
  grouping ToDInfo {
    leaf Name {
      mandatory "true";
      type string;
    }
    leaf Path {
      mandatory "true";
      type string;
    }
    leaf Direction {
      mandatory "true";
      type string;
    }
  }
  grouping UARTDevice {
    leaf Name {
      mandatory "true";
      type string;
    }
    leaf Path {
      mandatory "true";
      type string;
    }
    leaf Direction {
      mandatory "true";
      type string;
    }
    leaf Bandwidth {
      mandatory "true";
      type int32;
    }
  }
  grouping FanInfo {
    leaf Name {
      mandatory "true";
      type string;
    }
    leaf Type {
      mandatory "true";
      type FanDeviceTypeOptions;
    }
    leaf FanNumber {
      mandatory "true";
      type int32;
    }
    choice Device {
    mandatory "true";
      container FANDevice {
        uses MCUFanDevice;
      }
      container I2CDevice {
        uses I2CDevice;
      }
      container GPIODevice {
        uses GPIODevice;
      }
    }
  }
  grouping PoEInfo {
    leaf Name {
      mandatory "true";
      type string;
    }
    leaf Type {
      mandatory "true";
      type PoEDeviceTypeOptions;
    }
    choice Device {
    mandatory "true";
      container I2CDevice {
        uses I2CDevice;
      }
      container UartDevice {
        uses UARTDevice;
      }
    }
  }
  grouping HardwareInfo {
    container DeviceLed {
      list DeviceLed_Entry {
        uses LedInfo;
      }
    }
    container DeviceHWMonitor {
      list DeviceHWMonitor_Entry {
        uses MonitorInfo;
      }
    }
    container DevicePSU {
      list DevicePSU_Entry {
        uses PSUInfo;
      }
    }
    container DeviceI2C {
      list DeviceI2C_Entry {
        uses I2Cinfo;
      }
    }
    container DeviceHW {
      list DeviceHW_Entry {
        uses GPIOInfo;
      }
    }
    container DevicePTP {
      list DevicePTP_Entry {
        uses PTPClockSynchronizerInfo;
      }
    }
    container DeviceGPS {
      list DeviceGPS_Entry {
        uses GPSInfo;
      }
    }
    container DeviceToD {
      list DeviceToD_Entry {
        uses ToDInfo;
      }
    }
    container DeviceFan {
      list DeviceFan_Entry {
        uses FanInfo;
      }
    }
    container DevicePoE {
      list DevicePoE_Entry {
        uses PoEInfo;
      }
    }
  }
  grouping HardwareTableSize {
    leaf TcamSize {
      mandatory "true";
      type int32;
    }
    leaf BridgeFDBEntries {
      mandatory "true";
      type int32;
    }
    leaf VirtualPorts {
      mandatory "true";
      type int32;
    }
    leaf VirtualBridgeDomains {
      mandatory "true";
      type int32;
    }
    leaf ARPTableEntries {
      mandatory "true";
      type int32;
    }
    leaf RouterIPv4HostEntries {
      mandatory "true";
      type int32;
    }
    leaf RouterIPv6HostEntries {
      mandatory "true";
      type int32;
    }
    leaf RouterNextHopEntries {
      mandatory "true";
      type int32;
    }
    leaf MulticastPhysicalPortGroups {
      mandatory "true";
      type int32;
    }
    leaf MulticastLinkedListEntries {
      mandatory "true";
      type int32;
    }
    leaf CentralizedCounters {
      mandatory "true";
      type int32;
    }
    leaf SpanningTreeGroups {
      mandatory "true";
      type int32;
    }
    leaf QoSProfiles {
      mandatory "true";
      type int32;
    }
    leaf L2L3PortIsolation {
      mandatory "true";
      type int32;
    }
  }
  grouping PhyInterface {
    leaf Interface {
      mandatory "true";
      type int32;
    }
    leaf Type {
      mandatory "true";
      type PhyInterfaceTypeOptions;
    }
  }
  grouping PortInfo {
    leaf PortNo {
      mandatory "true";
      type int32;
    }
    leaf MACChip {
      mandatory "true";
      type int32;
    }
    leaf MACNo {
      mandatory "true";
      type int32;
    }
    leaf PortGroup {
      mandatory "true";
      type int32;
    }
    leaf PhyID1 {
      mandatory "true";
      type int32;
    }
    leaf PhyID2 {
      mandatory "true";
      type int32;
    }
    container PhyInterface {
      uses PhyInterface;
    }
    leaf PoENo {
      mandatory "true";
      type int32;
    }
    container PoEChannel {
      leaf-list PoEChannel_Entry {
        type int32;
      }
    }
    leaf PoEChipNo {
      mandatory "true";
      type int32;
    }
    leaf MacsecEncLen {
      mandatory "true";
      type int32;
    }
    leaf InterfaceType {
      mandatory "true";
      type PortInterfaceTypeOptions;
    }
    container Properties {
      leaf-list Properties_Entry {
        type PortPropertyTypeOptions;
      }
    }
    leaf DeviceID {
      mandatory "true";
      type int32;
    }
    container SpeedProperties {
      leaf-list SpeedProperties_Entry {
        type DevicePortSpeedDuplexTypeOptions;
      }
    }
  }
  grouping BoardInfo {
    leaf SystemDescription {
      mandatory "true";
      type string;
    }
    container PortLists {
      list PortLists_Entry {
        uses PortInfo;
      }
    }
    container HwFeatures {
      leaf-list HwFeatures_Entry {
        type FactoryHwFeatureTypeOptions;
      }
    }
    container HwSize {
      uses HardwareTableSize;
    }
    leaf CPUPort {
      mandatory "true";
      type int32;
    }
    container BoardDevice {
      uses HardwareInfo;
    }
    container TimeControl {
      uses TimeControlInfo;
    }
    leaf EnterpriseOID {
      mandatory "true";
      type string;
    }
  }
  grouping TimeControlSpeedFrequencyEntry {
    leaf Speed {
      mandatory "true";
      type PortPropertyTypeOptions;
    }
    leaf Frequency {
      mandatory "true";
      type int64;
    }
    leaf M {
      mandatory "true";
      type int64;
    }
    leaf N {
      mandatory "true";
      type int64;
    }
    leaf Div {
      mandatory "true";
      type int64;
    }
  }
  grouping TimeControlPortInfoEntry {
    leaf PortNo {
      mandatory "true";
      type int32;
    }
    leaf RCLKPin {
      mandatory "true";
      type RCLKTypeOptions;
    }
    leaf Frequency {
      mandatory "true";
      type int64;
    }
    leaf InputClock {
      mandatory "true";
      type InputClockIndexTypeOptions;
    }
  }
  grouping TimeControlInfo {
    container InputClockMapping {
      list InputClockMapping_Entry {
        key "Key";
        unique "Key";
        leaf Key {
          mandatory "true";
          type string;
        }
        leaf Value {
          mandatory "true";
          type InputClockIndexTypeOptions;
        }
      }
    }
    container PortInfoList {
      list PortInfoList_Entry {
        uses TimeControlPortInfoEntry;
      }
    }
    container SpeedFrequencyList {
      list SpeedFrequencyList_Entry {
        uses TimeControlSpeedFrequencyEntry;
      }
    }
  }
  grouping Boundary {
    leaf Type {
      mandatory "true";
      type BoundaryTypeOptions;
    }
    leaf Max {
      mandatory "true";
      type int32;
    }
    leaf Min {
      mandatory "true";
      type int32;
    }
    leaf Lower {
      mandatory "true";
      type decimal64 {
        fraction-digits 2;
      }
    }
    leaf Upper {
      mandatory "true";
      type decimal64 {
        fraction-digits 2;
      }
    }
  }
  grouping BoundaryAll {
    container VLAN {
      uses BoundaryVLAN;
    }
    container Access {
      uses BoundaryAccess;
    }
    container DDM {
      uses BoundaryDDM;
    }
    container ACL {
      uses BoundaryACL;
    }
    container Log {
      uses BoundaryLog;
    }
    container Mirroring {
      uses BoundaryMirroring;
    }
    container Trunk {
      uses BoundaryTRUNK;
    }
    container FDB {
      uses BoundaryFDB;
    }
    container QoS {
      uses BoundaryQoS;
    }
    container Multicast {
      uses BoundaryMulticast;
    }
    container PoE {
      uses BoundaryPoE;
    }
    container Files {
      uses BoundaryFiles;
    }
    container TimeRange {
      uses BoundaryTimeRange;
    }
    container DHCPServer {
      uses BoundaryDHCPServer;
    }
    container Monitor {
      uses BoundaryMonitor;
    }
  }
  grouping BoundaryDHCPServer {
    container MACBased {
      uses Boundary;
    }
  }
  grouping BoundaryVLAN {
    container VlanID {
      uses Boundary;
    }
    container VlanFilter {
      uses Boundary;
    }
    container ProtocolBased {
      uses Boundary;
    }
    container MACBased {
      uses Boundary;
    }
    container SubnetBased {
      uses Boundary;
    }
    container TPIDsRange {
      uses Boundary;
    }
    container ProtocolClasses {
      uses Boundary;
    }
    container SelectiveQinQ {
      uses Boundary;
    }
    container Mapping {
      uses Boundary;
    }
  }
  grouping BoundaryDDM {
    container DdmTemperature {
      uses Boundary;
    }
    container DdmVoltage {
      uses Boundary;
    }
    container DdmTxBias {
      uses Boundary;
    }
    container DdmRxPower {
      uses Boundary;
    }
    container DdmTxPower {
      uses Boundary;
    }
  }
  grouping BoundaryACL {
    container ACLs {
      uses Boundary;
    }
    container ACEs {
      uses Boundary;
    }
    container Binding {
      uses Boundary;
    }
    container Flow {
      uses Boundary;
    }
    container FlowRules {
      uses Boundary;
    }
    container Rules {
      uses Boundary;
    }
  }
  grouping BoundaryLog {
    container LogRotateSize {
      uses Boundary;
    }
    container LogRotateFileCount {
      uses Boundary;
    }
    container LogTargetList {
      uses Boundary;
    }
  }
  grouping BoundaryAccess {
    container Users {
      uses Boundary;
    }
    container UsersAssociatedGroups {
      uses Boundary;
    }
    container Groups {
      uses Boundary;
    }
    container GroupsPattern {
      uses Boundary;
    }
    container Restrictions {
      uses Boundary;
    }
    container Servers {
      uses Boundary;
    }
  }
  grouping BoundaryMirroring {
    container Session {
      uses Boundary;
    }
  }
  grouping BoundaryFDB {
    container FDBSize {
      uses Boundary;
    }
    container AgeTime {
      uses Boundary;
    }
    container PortLearningLimit {
      uses Boundary;
    }
    container PortSecurityLearningLimit {
      uses Boundary;
    }
    container ForwardLimit {
      uses Boundary;
    }
    container DropLimit {
      uses Boundary;
    }
  }
  grouping BoundaryTRUNK {
    container IDRange {
      uses Boundary;
    }
    container PriorityRange {
      uses Boundary;
    }
    container MemberRange {
      uses Boundary;
    }
  }
  grouping BoundaryMulticast {
    container VIDXRange {
      uses Boundary;
    }
    container StaticEntries {
      uses Boundary;
    }
    container DynamicEntries {
      uses Boundary;
    }
  }
  grouping BoundaryQoS {
    container QueueListRange {
      uses Boundary;
    }
    container CoSRange {
      uses Boundary;
    }
    container DSCPRange {
      uses Boundary;
    }
    container WRRRange {
      uses Boundary;
    }
  }
  grouping BoundaryPoE {
    container BudgetRange {
      uses Boundary;
    }
  }
  grouping BoundaryFiles {
    container CertificatedRange {
      uses Boundary;
    }
  }
  grouping BoundaryTimeRange {
    container EntryRange {
      uses Boundary;
    }
  }
  grouping BoundaryMonitor {
    container Temperature {
      uses Boundary;
    }
    container Power {
      uses Boundary;
    }
    container Cpu {
      uses Boundary;
    }
    container Memory {
      uses Boundary;
    }
    container PowerRedundantConsumption {
      uses Boundary;
    }
    container PowerRedundantTemperature {
      uses Boundary;
    }
    container PowerRedundantVoltage {
      uses Boundary;
    }
    container PowerRedundantCurrent {
      uses Boundary;
    }
  }
  grouping FunctionControlAll {
    container VLAN {
      uses FunctionControlVLAN;
    }
    container Acl {
      uses FunctionControlACL;
    }
    container Mirroring {
      uses FunctionControlMirroring;
    }
    container FDB {
      uses FunctionControlFDB;
    }
  }
  grouping FunctionControlVLAN {
    leaf Voice {
      mandatory "true";
      type boolean;
    }
    leaf SelectiveQinq {
      mandatory "true";
      type boolean;
    }
    leaf MACBased {
      mandatory "true";
      type boolean;
    }
    leaf SubnetBased {
      mandatory "true";
      type boolean;
    }
    leaf ProtocolBased {
      mandatory "true";
      type boolean;
    }
    leaf Translation {
      mandatory "true";
      type boolean;
    }
  }
  grouping FunctionControlACL {
    leaf TimeRange {
      mandatory "true";
      type boolean;
    }
    leaf Binding {
      mandatory "true";
      type boolean;
    }
    leaf FlowMirroring {
      mandatory "true";
      type boolean;
    }
  }
  grouping FunctionControlMirroring {
    leaf RSPAN {
      mandatory "true";
      type boolean;
    }
  }
  grouping FunctionControlFDB {
    leaf PortSecurity {
      mandatory "true";
      type boolean;
    }
    leaf LearningLimit {
      mandatory "true";
      type boolean;
    }
    leaf Forward {
      mandatory "true";
      type boolean;
    }
    leaf Drop {
      mandatory "true";
      type boolean;
    }
  }
  grouping PathAll {
    leaf LogRamDisk {
      mandatory "true";
      type string;
    }
    leaf LogFlash {
      mandatory "true";
      type string;
    }
    leaf ConfigDefault {
      mandatory "true";
      type string;
    }
    leaf ConfigSaved {
      mandatory "true";
      type string;
    }
    leaf User {
      mandatory "true";
      type string;
    }
    leaf IPTables {
      mandatory "true";
      type string;
    }
    leaf CoreReboot {
      mandatory "true";
      type string;
    }
    leaf WarmStart {
      mandatory "true";
      type string;
    }
    leaf VlanMgmt {
      mandatory "true";
      type string;
    }
    leaf TimeCfg {
      mandatory "true";
      type string;
    }
    leaf BootReady {
      mandatory "true";
      type string;
    }
    leaf IPv6LinkLocal {
      mandatory "true";
      type string;
    }
    leaf TimeZone {
      mandatory "true";
      type string;
    }
    leaf Resolv {
      mandatory "true";
      type string;
    }
    leaf DropbearProc {
      mandatory "true";
      type string;
    }
    leaf TelnetProc {
      mandatory "true";
      type string;
    }
    leaf FTPProc {
      mandatory "true";
      type string;
    }
    leaf LocalUser {
      mandatory "true";
      type string;
    }
    leaf Certificates {
      mandatory "true";
      type string;
    }
    leaf OpenSSLCertificates {
      mandatory "true";
      type string;
    }
    leaf SNMPdCertificates {
      mandatory "true";
      type string;
    }
    leaf SNMPdCertificatesKey {
      mandatory "true";
      type string;
    }
    leaf NetCfg {
      mandatory "true";
      type string;
    }
    leaf IPv4Script {
      mandatory "true";
      type string;
    }
    leaf IPv6Script {
      mandatory "true";
      type string;
    }
    leaf LastSaveTime {
      mandatory "true";
      type string;
    }
    leaf Image {
      mandatory "true";
      type string;
    }
    leaf AltVersion {
      mandatory "true";
      type string;
    }
    leaf AltBuildDateTime {
      mandatory "true";
      type string;
    }
    leaf Version {
      mandatory "true";
      type string;
    }
    leaf BuildDateTime {
      mandatory "true";
      type string;
    }
    leaf DhcpServerDnsmasqLeasePath {
      mandatory "true";
      type string;
    }
    leaf DhcpServerDnsmasqCfgPath {
      mandatory "true";
      type string;
    }
    leaf DhcpServerPortBasedInfo {
      mandatory "true";
      type string;
    }
  }
  grouping InterfaceIdentify {
    leaf Type {
      mandatory "true";
      type InterfaceTypeOptions;
    }
    leaf DeviceID {
      mandatory "true";
      type int32;
    }
    leaf PortNo {
      mandatory "true";
      type int32;
    }
    leaf LAGNo {
      mandatory "true";
      type int32;
    }
    leaf VlanID {
      mandatory "true";
      type int32;
    }
  }
  grouping Info {
    leaf Model {
      mandatory "true";
      type string;
    }
    leaf MACAddr {
      mandatory "true";
      type string;
    }
    leaf MACAddrFactory {
      mandatory "true";
      type string;
    }
    leaf SerialNo {
      mandatory "true";
      type string;
    }
    leaf Vendor {
      mandatory "true";
      type string;
    }
    leaf AltBuildDateTime {
      mandatory "true";
      type string;
    }
    leaf CurrentBuildDateTime {
      mandatory "true";
      type string;
    }
    leaf AltSwVersion {
      mandatory "true";
      type string;
    }
    leaf CurrentSwVersion {
      mandatory "true";
      type string;
    }
    leaf HwVersion {
      mandatory "true";
      type string;
    }
    leaf CurrentImage {
      mandatory "true";
      type string;
    }
    leaf Board {
      mandatory "true";
      type string;
    }
    leaf Layer {
      mandatory "true";
      type LayerTypeOptions;
    }
  }
  grouping PortList {
    container List {
      list List_Entry {
        uses InterfaceIdentify;
      }
    }
  }
  rpc sercom-device-Device-GetMACAddress {
    output {
      uses sercom-common:MACAddress;
    }
  }
  rpc sercom-device-Device-GetPortLists {
    output {
      uses PortList;
    }
  }
  rpc sercom-device-Device-GetLAGPortLists {
    output {
      uses PortList;
    }
  }
  rpc sercom-device-Device-GetPoEPortLists {
    output {
      uses PortList;
    }
  }
  rpc sercom-device-Device-GetHardwareTableSize {
    output {
      uses HardwareTableSize;
    }
  }
  rpc sercom-device-Device-GetDeviceInfo {
    output {
      uses Info;
    }
  }
  rpc sercom-device-Device-GetBoardInfo {
    output {
      uses BoardInfo;
    }
  }
  rpc sercom-device-Device-GetHardwareInfo {
    output {
      uses HardwareInfo;
    }
  }
}
