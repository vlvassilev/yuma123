// Code generated by protoc-gen-yang(*.c) DO NOT EDIT.

/*****************************************************************************************************
 * Copyright (C) 2017-2022 by Intrising
 *  - ian0113@intrising.com.tw
 * 
 * Generated by protoc-gen-yang@gen-yang
 * 
 *****************************************************************************************************/

#include <libxml/xmlstring.h>
#include "agt.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "procdefs.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"

#include "intri-error-trans.h"
#include "../../../../../../../.libintrishare/libintrishare.h"


status_t build_to_xml_error_Detail(
    val_value_t *parentval,
    struct errorpb_Detail *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "Code",
      &res);
  if (childval != NULL) {
    val_add_child_sorted(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* uint64 */
  VAL_ULONG(childval) = entry->Code;
  return res;
}
status_t build_to_xml_error_PreparingDetail(
    val_value_t *parentval,
    struct errorpb_PreparingDetail *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;
  if (entry == NULL) {
    return res;
  }
  childval = agt_make_object(
      parentval->obj,
      "ErrorOption",
      &res);
  if (childval != NULL) {
    val_add_child_sorted(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  /* enum */
  switch (entry->ErrorOption) {
    case errorpb_ErrorTypeOptions_ERROR_TYPE_UNKNOWN:
      enum_str = "ERROR_TYPE_UNKNOWN";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_OTHER_SERVICES:
      enum_str = "ERROR_TYPE_OTHER_SERVICES";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_LIST_FULL:
      enum_str = "ERROR_TYPE_LIST_FULL";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_UNREACHABLE:
      enum_str = "ERROR_TYPE_UNREACHABLE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CONFIG_EMPTY:
      enum_str = "ERROR_TYPE_CONFIG_EMPTY";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_TAGGED_LIST_SHOULD_BE_EMPTY:
      enum_str = "ERROR_TYPE_VLAN_TAGGED_LIST_SHOULD_BE_EMPTY";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_UNTAGGED_LIST_SHOULD_BE_EMPTY:
      enum_str = "ERROR_TYPE_VLAN_UNTAGGED_LIST_SHOULD_BE_EMPTY";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DIAGNOSTIC_DNS_EMPTY:
      enum_str = "ERROR_TYPE_DIAGNOSTIC_DNS_EMPTY";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DIAGNOSTIC_DNS_NOT_FOUND:
      enum_str = "ERROR_TYPE_DIAGNOSTIC_DNS_NOT_FOUND";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_BOARD_INFO_EMPTY:
      enum_str = "ERROR_TYPE_BOARD_INFO_EMPTY";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_FILE_EXTENSION_INVALID:
      enum_str = "ERROR_TYPE_FILE_EXTENSION_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_FILE_URL_SCHEME_INVALID:
      enum_str = "ERROR_TYPE_FILE_URL_SCHEME_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CONFIG_FILE_SAME_AS_LOCAL_INVALID:
      enum_str = "ERROR_TYPE_CONFIG_FILE_SAME_AS_LOCAL_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_STP_PRIORITY_INVALID:
      enum_str = "ERROR_TYPE_STP_PRIORITY_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INTERFACE_PORT_INVALID:
      enum_str = "ERROR_TYPE_INTERFACE_PORT_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INTERFACE_VLAN_INVALID:
      enum_str = "ERROR_TYPE_INTERFACE_VLAN_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INTERFACE_TRUNK_INVALID:
      enum_str = "ERROR_TYPE_INTERFACE_TRUNK_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_Q_IN_Q_ETHER_TYPE_INVALID:
      enum_str = "ERROR_TYPE_VLAN_Q_IN_Q_ETHER_TYPE_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MAINTENANCE_FIRMWARE_INVALID:
      enum_str = "ERROR_TYPE_MAINTENANCE_FIRMWARE_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CRT_FILE_URL_SCHEME_INVALID:
      enum_str = "ERROR_TYPE_CRT_FILE_URL_SCHEME_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_KEY_FILE_URL_SCHEME_INVALID:
      enum_str = "ERROR_TYPE_KEY_FILE_URL_SCHEME_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CA_FILE_URL_SCHEME_INVALID:
      enum_str = "ERROR_TYPE_CA_FILE_URL_SCHEME_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CRT_CONTENT_INVALID:
      enum_str = "ERROR_TYPE_CRT_CONTENT_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CA_CONTENT_INVALID:
      enum_str = "ERROR_TYPE_CA_CONTENT_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_TIME_ZONE_INVALID:
      enum_str = "ERROR_TYPE_TIME_ZONE_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_TIME_DATE_TIME_INVALID:
      enum_str = "ERROR_TYPE_TIME_DATE_TIME_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_POE_FIRMWARE_VERSION_INVALID:
      enum_str = "ERROR_TYPE_POE_FIRMWARE_VERSION_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DHCP_CUSTOM_REMOTE_ID_INVALID:
      enum_str = "ERROR_TYPE_DHCP_CUSTOM_REMOTE_ID_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DHCP_SERVER_BASIC_IP_INVALID:
      enum_str = "ERROR_TYPE_DHCP_SERVER_BASIC_IP_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DHCP_SERVER_BASIC_LEASE_TIME_INVALID:
      enum_str = "ERROR_TYPE_DHCP_SERVER_BASIC_LEASE_TIME_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DHCP_SERVER_MAC_BASED_IP_INVALID:
      enum_str = "ERROR_TYPE_DHCP_SERVER_MAC_BASED_IP_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DHCP_SERVER_MAC_BASED_MACADDRESS_INVALID:
      enum_str = "ERROR_TYPE_DHCP_SERVER_MAC_BASED_MACADDRESS_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DHCP_SERVER_PORT_BASED_IP_INVALID:
      enum_str = "ERROR_TYPE_DHCP_SERVER_PORT_BASED_IP_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DHCP_SERVER_PORT_BASED_PORT_NO_INVALID:
      enum_str = "ERROR_TYPE_DHCP_SERVER_PORT_BASED_PORT_NO_INVALID";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_FILE_WRITE_FAILED:
      enum_str = "ERROR_TYPE_FILE_WRITE_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CONFIG_IMPORT_FAILED:
      enum_str = "ERROR_TYPE_CONFIG_IMPORT_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CONFIG_EXPORT_FAILED:
      enum_str = "ERROR_TYPE_CONFIG_EXPORT_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CONFIG_FILE_READ_FAILED:
      enum_str = "ERROR_TYPE_CONFIG_FILE_READ_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CONFIG_FILE_UNMARSHAL_FALIED:
      enum_str = "ERROR_TYPE_CONFIG_FILE_UNMARSHAL_FALIED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CONFIG_FILE_VALIDATE_FAILED:
      enum_str = "ERROR_TYPE_CONFIG_FILE_VALIDATE_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CONFIG_FILE_WRITE_FAILED:
      enum_str = "ERROR_TYPE_CONFIG_FILE_WRITE_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CONFIG_MARSHAL_FALIED:
      enum_str = "ERROR_TYPE_CONFIG_MARSHAL_FALIED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CLI_ACTION_FAILED:
      enum_str = "ERROR_TYPE_CLI_ACTION_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACCESS_AUTHENTICATION_FAILED:
      enum_str = "ERROR_TYPE_ACCESS_AUTHENTICATION_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DIAGNOSTIC_TRACE_ROUTE_FAILED:
      enum_str = "ERROR_TYPE_DIAGNOSTIC_TRACE_ROUTE_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MAINTENANCE_EXECUTE_FAILED:
      enum_str = "ERROR_TYPE_MAINTENANCE_EXECUTE_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MAINTENANCE_UPLOAD_FAILED:
      enum_str = "ERROR_TYPE_MAINTENANCE_UPLOAD_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MAINTENANCE_DOWNLOAD_FAILED:
      enum_str = "ERROR_TYPE_MAINTENANCE_DOWNLOAD_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MAINTENANCE_UPGRADE_FAILED:
      enum_str = "ERROR_TYPE_MAINTENANCE_UPGRADE_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CRT_DOWNLOAD_FAILED:
      enum_str = "ERROR_TYPE_CRT_DOWNLOAD_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_KEY_DOWNLOAD_FAILED:
      enum_str = "ERROR_TYPE_KEY_DOWNLOAD_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CA_DOWNLOAD_FAILED:
      enum_str = "ERROR_TYPE_CA_DOWNLOAD_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CRT_UPLOAD_FAILED:
      enum_str = "ERROR_TYPE_CRT_UPLOAD_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_KEY_UPLOAD_FAILED:
      enum_str = "ERROR_TYPE_KEY_UPLOAD_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_CA_UPLOAD_FAILED:
      enum_str = "ERROR_TYPE_CA_UPLOAD_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_TIME_PARSE_FAILED:
      enum_str = "ERROR_TYPE_TIME_PARSE_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_I2C_READ_FAILED:
      enum_str = "ERROR_TYPE_I2C_READ_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_I2C_WRITE_FAILED:
      enum_str = "ERROR_TYPE_I2C_WRITE_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_POE_COMMAND_FAILED:
      enum_str = "ERROR_TYPE_POE_COMMAND_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ID_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_ID_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_GROUP_ID_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_GROUP_ID_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ENTRY_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_ENTRY_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_STP_HELLO_TIME_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_STP_HELLO_TIME_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_STP_MAX_AGE_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_STP_MAX_AGE_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_STP_FORWARD_DELAY_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_STP_FORWARD_DELAY_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_QOS_QUEUE_NO_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_QOS_QUEUE_NO_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_QOS_PRIORITY_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_QOS_PRIORITY_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_QOS_COS_NO_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_QOS_COS_NO_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_QOS_DSCP_NO_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_QOS_DSCP_NO_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_AU_DROP_LIST_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_AU_DROP_LIST_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_AU_FORWARD_LIST_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_AU_FORWARD_LIST_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_AU_LIMIT_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_AU_LIMIT_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_AU_SECUTIRY_LEARNING_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_AU_SECUTIRY_LEARNING_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_GROUP_ID_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_VLAN_GROUP_ID_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_LACP_GROUP_MEMBER_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_LACP_GROUP_MEMBER_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_LACP_PRIORITY_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_LACP_PRIORITY_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_LACP_ID_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_LACP_ID_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MIRRORING_SESSION_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_MIRRORING_SESSION_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_HW_VALUE_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_HW_VALUE_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_POE_KEY_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_POE_KEY_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_POE_BUDGET_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_POE_BUDGET_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MONITOR_SCORLL_VALUE_OUT_OF_RANGE:
      enum_str = "ERROR_TYPE_MONITOR_SCORLL_VALUE_OUT_OF_RANGE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_NAME_NOT_EXIST:
      enum_str = "ERROR_TYPE_NAME_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INDEX_NOT_EXIST:
      enum_str = "ERROR_TYPE_INDEX_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_GROUP_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_GROUP_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MAC_ADDRESS_NOT_EXIST:
      enum_str = "ERROR_TYPE_MAC_ADDRESS_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ENTRY_NOT_EXIST:
      enum_str = "ERROR_TYPE_ENTRY_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INTERFACE_NOT_EXIST:
      enum_str = "ERROR_TYPE_INTERFACE_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INTERFACE_PORT_NOT_EXIST:
      enum_str = "ERROR_TYPE_INTERFACE_PORT_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INTERFACE_VLAN_NOT_EXIST:
      enum_str = "ERROR_TYPE_INTERFACE_VLAN_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INTERFACE_TRUNK_NOT_EXIST:
      enum_str = "ERROR_TYPE_INTERFACE_TRUNK_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_QOS_QUEUE_NO_NOT_EXIST:
      enum_str = "ERROR_TYPE_QOS_QUEUE_NO_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACCESS_SERVER_NAME_NOT_EXIST:
      enum_str = "ERROR_TYPE_ACCESS_SERVER_NAME_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACCESS_GROUP_NAME_NOT_EXIST:
      enum_str = "ERROR_TYPE_ACCESS_GROUP_NAME_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACCESS_RESTRICTION_NAME_NOT_EXIST:
      enum_str = "ERROR_TYPE_ACCESS_RESTRICTION_NAME_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACCESS_USER_NAME_NOT_EXIST:
      enum_str = "ERROR_TYPE_ACCESS_USER_NAME_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACL_BINDING_NAME_NOT_EXIST:
      enum_str = "ERROR_TYPE_ACL_BINDING_NAME_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACL_FLOW_NAME_NOT_EXIST:
      enum_str = "ERROR_TYPE_ACL_FLOW_NAME_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACL_RULE_NAME_NOT_EXIST:
      enum_str = "ERROR_TYPE_ACL_RULE_NAME_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACL_NAME_NOT_EXIST:
      enum_str = "ERROR_TYPE_ACL_NAME_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACL_INGRESS_RULE_NAME_NOT_EXIST:
      enum_str = "ERROR_TYPE_ACL_INGRESS_RULE_NAME_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACL_EGRESS_RULE_NAME_NOT_EXIST:
      enum_str = "ERROR_TYPE_ACL_EGRESS_RULE_NAME_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_FILTER_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_VLAN_FILTER_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_GROUP_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_VLAN_GROUP_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_MANAGEMENT_VLAN_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_VLAN_MANAGEMENT_VLAN_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_UNAUTHORIZED_VLAN_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_VLAN_UNAUTHORIZED_VLAN_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_DEFAULT_VLAN_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_VLAN_DEFAULT_VLAN_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_TAGGED_VLAN_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_VLAN_TAGGED_VLAN_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_UNTAGGED_VLAN_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_VLAN_UNTAGGED_VLAN_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_SOURCE_VLAN_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_VLAN_SOURCE_VLAN_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_TRANSLATED_VLAN_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_VLAN_TRANSLATED_VLAN_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_FILES_WEB_CERTIFICATE_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_FILES_WEB_CERTIFICATE_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_FILES_SNMP_CERTIFICATE_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_FILES_SNMP_CERTIFICATE_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_FILES_SNMP_MANAGER_CERTIFICATE_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_FILES_SNMP_MANAGER_CERTIFICATE_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_FILES_SNMP_MANAGER_USER_NOT_EXIST:
      enum_str = "ERROR_TYPE_FILES_SNMP_MANAGER_USER_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_AU_DROP_ENTRY_NOT_EXIST:
      enum_str = "ERROR_TYPE_AU_DROP_ENTRY_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_AU_FORWARD_ENTRY_NOT_EXIST:
      enum_str = "ERROR_TYPE_AU_FORWARD_ENTRY_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_AU_MULTICAST_ENTRY_NOT_EXIST:
      enum_str = "ERROR_TYPE_AU_MULTICAST_ENTRY_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MULTICAST_IGMP_VLAN_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_MULTICAST_IGMP_VLAN_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MULTICAST_MLD_VLAN_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_MULTICAST_MLD_VLAN_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MULTICAST_UNREGISTERED_VLAN_ID_NOT_EXIST:
      enum_str = "ERROR_TYPE_MULTICAST_UNREGISTERED_VLAN_ID_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_POE_FIRMWARE_VERSION_NOT_EXIST:
      enum_str = "ERROR_TYPE_POE_FIRMWARE_VERSION_NOT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_NAME_EXIST:
      enum_str = "ERROR_TYPE_NAME_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ID_EXIST:
      enum_str = "ERROR_TYPE_ID_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_GROUP_ID_EXIST:
      enum_str = "ERROR_TYPE_GROUP_ID_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MAC_ADDRESS_EXIST:
      enum_str = "ERROR_TYPE_MAC_ADDRESS_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INDEX_EXIST:
      enum_str = "ERROR_TYPE_INDEX_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ENTRY_EXIST:
      enum_str = "ERROR_TYPE_ENTRY_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INTERFACE_PORT_EXIST:
      enum_str = "ERROR_TYPE_INTERFACE_PORT_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INTERFACE_VLAN_EXIST:
      enum_str = "ERROR_TYPE_INTERFACE_VLAN_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INTERFACE_TRUNK_EXIST:
      enum_str = "ERROR_TYPE_INTERFACE_TRUNK_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACCESS_SERVER_NAME_EXIST:
      enum_str = "ERROR_TYPE_ACCESS_SERVER_NAME_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACCESS_GROUP_NAME_EXIST:
      enum_str = "ERROR_TYPE_ACCESS_GROUP_NAME_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACCESS_RESTRICTION_NAME_EXIST:
      enum_str = "ERROR_TYPE_ACCESS_RESTRICTION_NAME_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACCESS_USER_NAME_EXIST:
      enum_str = "ERROR_TYPE_ACCESS_USER_NAME_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_AU_DROP_ENTRY_EXIST:
      enum_str = "ERROR_TYPE_AU_DROP_ENTRY_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_AU_FORWARD_ENTRY_EXIST:
      enum_str = "ERROR_TYPE_AU_FORWARD_ENTRY_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACL_BINDING_NAME_EXIST:
      enum_str = "ERROR_TYPE_ACL_BINDING_NAME_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACL_FLOW_NAME_EXIST:
      enum_str = "ERROR_TYPE_ACL_FLOW_NAME_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACL_RULE_NAME_EXIST:
      enum_str = "ERROR_TYPE_ACL_RULE_NAME_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACL_NAME_EXIST:
      enum_str = "ERROR_TYPE_ACL_NAME_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_FILTER_ID_EXIST:
      enum_str = "ERROR_TYPE_VLAN_FILTER_ID_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_GROUP_ID_EXIST:
      enum_str = "ERROR_TYPE_VLAN_GROUP_ID_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_SOURCE_VLAN_ID_EXIST:
      enum_str = "ERROR_TYPE_VLAN_SOURCE_VLAN_ID_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_FILES_SNMP_MANAGER_USER_EXIST:
      enum_str = "ERROR_TYPE_FILES_SNMP_MANAGER_USER_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MULTICAST_STATIC_ENTRY_EXIST:
      enum_str = "ERROR_TYPE_MULTICAST_STATIC_ENTRY_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACL_RULE_PRIORITY_EXIST:
      enum_str = "ERROR_TYPE_ACL_RULE_PRIORITY_EXIST";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_FEATURE_NOT_SUPPORT:
      enum_str = "ERROR_TYPE_FEATURE_NOT_SUPPORT";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_URL_SCHEME_NOT_SUPPORT:
      enum_str = "ERROR_TYPE_URL_SCHEME_NOT_SUPPORT";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DEVICE_BOARD_NOT_SUPPORT:
      enum_str = "ERROR_TYPE_DEVICE_BOARD_NOT_SUPPORT";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INTERFACE_PORT_NOT_SUPPORT:
      enum_str = "ERROR_TYPE_INTERFACE_PORT_NOT_SUPPORT";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INTERFACE_VLAN_NOT_SUPPORT:
      enum_str = "ERROR_TYPE_INTERFACE_VLAN_NOT_SUPPORT";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INTERFACE_TRUNK_NOT_SUPPORT:
      enum_str = "ERROR_TYPE_INTERFACE_TRUNK_NOT_SUPPORT";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_TIME_ZONE_NOT_SUPPORT:
      enum_str = "ERROR_TYPE_TIME_ZONE_NOT_SUPPORT";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_NAME_OCCUPIED:
      enum_str = "ERROR_TYPE_NAME_OCCUPIED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_GROUP_ID_OCCUPIED:
      enum_str = "ERROR_TYPE_GROUP_ID_OCCUPIED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_ID_OCCUPIED:
      enum_str = "ERROR_TYPE_VLAN_ID_OCCUPIED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_LACP_GROUP_MEMBER_OCCUPIED:
      enum_str = "ERROR_TYPE_LACP_GROUP_MEMBER_OCCUPIED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_RSPAN_OCCUPIED:
      enum_str = "ERROR_TYPE_RSPAN_OCCUPIED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_INTERFACE_OCCUPIED:
      enum_str = "ERROR_TYPE_INTERFACE_OCCUPIED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_DEFAULT_VLAN_CAN_NOT_BE_CHANGED:
      enum_str = "ERROR_TYPE_VLAN_DEFAULT_VLAN_CAN_NOT_BE_CHANGED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_TAGGED_LIST_INCLUDE_DEFAULT_VLAN:
      enum_str = "ERROR_TYPE_VLAN_TAGGED_LIST_INCLUDE_DEFAULT_VLAN";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_TAGGED_LIST_EXCLUDE_DEFAULT_VLAN:
      enum_str = "ERROR_TYPE_VLAN_TAGGED_LIST_EXCLUDE_DEFAULT_VLAN";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_UNTAGGED_LIST_INCLUDE_DEFAULT_VLAN:
      enum_str = "ERROR_TYPE_VLAN_UNTAGGED_LIST_INCLUDE_DEFAULT_VLAN";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_UNTAGGED_LIST_EXCLUDE_DEFAULT_VLAN:
      enum_str = "ERROR_TYPE_VLAN_UNTAGGED_LIST_EXCLUDE_DEFAULT_VLAN";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_GVRP_HOLD_TIMER_SHOULD_LESS_THAN_HALF_OF_JOIN_TIMER:
      enum_str = "ERROR_TYPE_VLAN_GVRP_HOLD_TIMER_SHOULD_LESS_THAN_HALF_OF_JOIN_TIMER";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_GVRP_JOIN_TIMER_SHOULD_LESS_THAN_HALF_OF_LEAVE_TIMER:
      enum_str = "ERROR_TYPE_VLAN_GVRP_JOIN_TIMER_SHOULD_LESS_THAN_HALF_OF_LEAVE_TIMER";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_VLAN_GVRP_LEAVE_TIMER_SHOULD_LESS_THAN_LEAVE_ALL_TIMER:
      enum_str = "ERROR_TYPE_VLAN_GVRP_LEAVE_TIMER_SHOULD_LESS_THAN_LEAVE_ALL_TIMER";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DHCP_CAN_NOT_ENABLE_SERVER:
      enum_str = "ERROR_TYPE_DHCP_CAN_NOT_ENABLE_SERVER";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DHCP_CAN_NOT_ENABLE_RELAY:
      enum_str = "ERROR_TYPE_DHCP_CAN_NOT_ENABLE_RELAY";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DHCP_SERVER_SERVER_DISABLED:
      enum_str = "ERROR_TYPE_DHCP_SERVER_SERVER_DISABLED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DHCP_SERVER_IP_RANGE_EQUAL:
      enum_str = "ERROR_TYPE_DHCP_SERVER_IP_RANGE_EQUAL";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_DHCP_SERVER_START_IP_SHOULD_BE_SMALLER_THAN_END_IP:
      enum_str = "ERROR_TYPE_DHCP_SERVER_START_IP_SHOULD_BE_SMALLER_THAN_END_IP";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MAINTENANCE_UPGRADING:
      enum_str = "ERROR_TYPE_MAINTENANCE_UPGRADING";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_NETWORK_MLD_ENABLED:
      enum_str = "ERROR_TYPE_NETWORK_MLD_ENABLED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_NETWORK_ICMP_NOT_ENABLED:
      enum_str = "ERROR_TYPE_NETWORK_ICMP_NOT_ENABLED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_NETWORK_AUTO_NOT_ENABLED:
      enum_str = "ERROR_TYPE_NETWORK_AUTO_NOT_ENABLED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_NETWORK_STATIC_IP_NOT_CONFIGURED:
      enum_str = "ERROR_TYPE_NETWORK_STATIC_IP_NOT_CONFIGURED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_NETWORK_DNS_SERVER_NOT_CONFIGURED:
      enum_str = "ERROR_TYPE_NETWORK_DNS_SERVER_NOT_CONFIGURED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_ACCESS_ENCRYPTED_PASSWORD_CREATED_FAILED:
      enum_str = "ERROR_TYPE_ACCESS_ENCRYPTED_PASSWORD_CREATED_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_FILE_UNEXPECTED_ERROR:
      enum_str = "ERROR_TYPE_FILE_UNEXPECTED_ERROR";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_NTP_NOT_ENABLE:
      enum_str = "ERROR_TYPE_NTP_NOT_ENABLE";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_COMMAND_EXECUTE_FAILED:
      enum_str = "ERROR_TYPE_COMMAND_EXECUTE_FAILED";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MSTP_IS_UPDATEING:
      enum_str = "ERROR_TYPE_MSTP_IS_UPDATEING";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_MIRRORING_ERROR:
      enum_str = "ERROR_TYPE_MIRRORING_ERROR";
      break;
    case errorpb_ErrorTypeOptions_ERROR_TYPE_PORT_SECURITY_ERROR:
      enum_str = "ERROR_TYPE_PORT_SECURITY_ERROR";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;
  return res;
}

status_t build_to_priv_error_Detail(
    val_value_t *parentval,
    struct errorpb_Detail *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "Code");
  if (childval != NULL && childval->res == NO_ERR) {
    /* uint64 */
    entry->Code = VAL_ULONG(childval);
  }
  return res;
}
status_t build_to_priv_error_PreparingDetail(
    val_value_t *parentval,
    struct errorpb_PreparingDetail *entry) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;
  childval = val_first_child_name(
      parentval,
      "ErrorOption");
  if (childval != NULL && childval->res == NO_ERR) {
    /* enum */
    entry->ErrorOption = VAL_ENUM(childval);
  }
  return res;
}
