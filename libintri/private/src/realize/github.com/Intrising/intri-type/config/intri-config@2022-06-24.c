// Code generated by protoc-gen-yang(*.c) DO NOT EDIT.

/*****************************************************************************************************
 * Copyright (C) 2017-2022 by Intrising
 *  - ian0113@intrising.com.tw
 * 
 * Generated by protoc-gen-yang@gen-yang
 * 
 *****************************************************************************************************/

#include <libxml/xmlstring.h>
#include "agt.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "procdefs.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"

#include "intri-config@2022-06-24.h"
#include "../../../../../../../.libintrishare/libintrishare.h"

#include "../../../../../genc-trans/github.com/Intrising/intri-type/common/intri-common-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/config/intri-config-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/access/intri-access-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/acl/intri-acl-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/cdp/intri-cdp-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/dhcp/intri-dhcp-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/dhcpserver/intri-dhcpserver-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/fdb/intri-fdb-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/files/intri-files-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/gvrp/intri-gvrp-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/isolation/intri-isolation-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/lacp/intri-lacp-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/lldp/intri-lldp-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/loop/intri-loop-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/mirroring/intri-mirroring-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/monitor/intri-monitor-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/multicast/intri-multicast-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/network/intri-network-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/poe/intri-poe-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/port/intri-port-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/portauthentication/intri-portauthentication-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/portsecurity/intri-portsecurity-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/ptp/intri-ptp-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/qos/intri-qos-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/sfp/intri-sfp-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/stormcontrol/intri-stormcontrol-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/stp/intri-stp-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/system/intri-system-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/time/intri-time-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/timerange/intri-timerange-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/timesync/intri-timesync-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/udld/intri-udld-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/userinterface/intri-userinterface-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/core/vlan/intri-vlan-trans.h"
#include "../../../../../genc-trans/github.com/Intrising/intri-type/log/intri-log-trans.h"
#include "../../../../../genc-trans/github.com/golang/protobuf/ptypes/empty/intri-empty-trans.h"

static ncx_module_t *intri_config_mod;

static status_t intri_config_Config_RunImportConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct commonpb_ImportPathRequest *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_common_ImportPathRequest(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_RunImportConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_RunExportConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct commonpb_ExportPathRequest *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_common_ExportPathRequest(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_RunExportConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetSaveModeStatus_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct configpb_SaveModeStatus *out = malloc(sizeof(*out));

  config_Config_GetSaveModeStatus(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_config_SaveModeStatus(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_RunSaveRunningConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_RunSaveRunningConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_RunRestoreDefaultConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct configpb_RestoreDefaultType *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_config_RestoreDefaultType(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_RunRestoreDefaultConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_RunCopyRunningConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct commonpb_Path *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_common_Path(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_RunCopyRunningConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_RunCopyDefaultConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct commonpb_Path *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_common_Path(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_RunCopyDefaultConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct configpb_AllServicesConfig *out = malloc(sizeof(*out));

  config_Config_GetRunningConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_config_AllServicesConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetDefaultConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct configpb_AllServicesConfig *out = malloc(sizeof(*out));

  config_Config_GetDefaultConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_config_AllServicesConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetSavedConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct configpb_AllServicesConfig *out = malloc(sizeof(*out));

  config_Config_GetSavedConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_config_AllServicesConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningAclConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct aclpb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningAclConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_acl_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningAclConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct aclpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningAclConfig(out, in);
  res = build_to_priv_acl_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningAclConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultAclConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct aclpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_acl_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultAclConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningVlanConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct vlanpb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningVlanConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_vlan_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningVlanConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningVlanConfig(out, in);
  res = build_to_priv_vlan_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningVlanConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultVlanConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct vlanpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_vlan_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultVlanConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningGvrpConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct gvrppb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningGvrpConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_gvrp_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningGvrpConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct gvrppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningGvrpConfig(out, in);
  res = build_to_priv_gvrp_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningGvrpConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultGvrpConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct gvrppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_gvrp_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultGvrpConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningAccessConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct accesspb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningAccessConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_access_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningAccessConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct accesspb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningAccessConfig(out, in);
  res = build_to_priv_access_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningAccessConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultAccessConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct accesspb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_access_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultAccessConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningUserInterfaceConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct userinterfacepb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningUserInterfaceConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_userinterface_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningUserInterfaceConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct userinterfacepb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningUserInterfaceConfig(out, in);
  res = build_to_priv_userinterface_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningUserInterfaceConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultUserInterfaceConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct userinterfacepb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_userinterface_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultUserInterfaceConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningSystemConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct systempb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningSystemConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_system_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningSystemConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct systempb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningSystemConfig(out, in);
  res = build_to_priv_system_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningSystemConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultSystemConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct systempb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_system_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultSystemConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningNetworkConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct networkpb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningNetworkConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_network_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningNetworkConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct networkpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningNetworkConfig(out, in);
  res = build_to_priv_network_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningNetworkConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultNetworkConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct networkpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_network_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultNetworkConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningTimeConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct timepb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningTimeConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_time_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningTimeConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct timepb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningTimeConfig(out, in);
  res = build_to_priv_time_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningTimeConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultTimeConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct timepb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_time_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultTimeConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningPortConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct portpb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningPortConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_port_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningPortConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct portpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningPortConfig(out, in);
  res = build_to_priv_port_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningPortConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultPortConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct portpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_port_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultPortConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningSFPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct sfppb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningSFPConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_sfp_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningSFPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct sfppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningSFPConfig(out, in);
  res = build_to_priv_sfp_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningSFPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultSFPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct sfppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_sfp_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultSFPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningMirroringConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct mirroringpb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningMirroringConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_mirroring_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningMirroringConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct mirroringpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningMirroringConfig(out, in);
  res = build_to_priv_mirroring_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningMirroringConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultMirroringConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct mirroringpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_mirroring_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultMirroringConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningIsolationConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct isolationpb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningIsolationConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_isolation_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningIsolationConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct isolationpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningIsolationConfig(out, in);
  res = build_to_priv_isolation_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningIsolationConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultIsolationConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct isolationpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_isolation_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultIsolationConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningFDBConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct fdbpb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningFDBConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_fdb_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningFDBConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct fdbpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningFDBConfig(out, in);
  res = build_to_priv_fdb_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningFDBConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultFDBConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct fdbpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_fdb_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultFDBConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningPortSecurityConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct portsecuritypb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningPortSecurityConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_portsecurity_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningPortSecurityConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct portsecuritypb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningPortSecurityConfig(out, in);
  res = build_to_priv_portsecurity_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningPortSecurityConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultPortSecurityConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct portsecuritypb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_portsecurity_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultPortSecurityConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningFilesConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct filespb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningFilesConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_files_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningFilesConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct filespb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningFilesConfig(out, in);
  res = build_to_priv_files_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningFilesConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultFilesConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct filespb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_files_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultFilesConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningLACPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct lacppb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningLACPConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_lacp_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningLACPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct lacppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningLACPConfig(out, in);
  res = build_to_priv_lacp_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningLACPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultLACPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct lacppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_lacp_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultLACPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningMulticastConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct multicastpb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningMulticastConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_multicast_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningMulticastConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct multicastpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningMulticastConfig(out, in);
  res = build_to_priv_multicast_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningMulticastConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultMulticastConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct multicastpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_multicast_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultMulticastConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningStormControlConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct stormcontrolpb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningStormControlConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stormcontrol_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningStormControlConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stormcontrolpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningStormControlConfig(out, in);
  res = build_to_priv_stormcontrol_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningStormControlConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultStormControlConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stormcontrolpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_stormcontrol_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultStormControlConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningDHCPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct dhcppb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningDHCPConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_dhcp_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningDHCPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct dhcppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningDHCPConfig(out, in);
  res = build_to_priv_dhcp_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningDHCPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultDHCPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct dhcppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_dhcp_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultDHCPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningQoSConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct qospb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningQoSConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_qos_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningQoSConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct qospb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningQoSConfig(out, in);
  res = build_to_priv_qos_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningQoSConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultQoSConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct qospb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_qos_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultQoSConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningLoopConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct looppb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningLoopConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_loop_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningLoopConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct looppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningLoopConfig(out, in);
  res = build_to_priv_loop_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningLoopConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultLoopConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct looppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_loop_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultLoopConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningLLDPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct lldppb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningLLDPConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_lldp_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningLLDPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct lldppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningLLDPConfig(out, in);
  res = build_to_priv_lldp_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningLLDPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultLLDPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct lldppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_lldp_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultLLDPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningPoeConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct poepb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningPoeConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_poe_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningPoeConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct poepb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningPoeConfig(out, in);
  res = build_to_priv_poe_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningPoeConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultPoeConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct poepb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_poe_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultPoeConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningCDPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cdppb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningCDPConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cdp_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultCDPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cdppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cdp_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultCDPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningCDPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cdppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningCDPConfig(out, in);
  res = build_to_priv_cdp_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningCDPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningDHCPServerConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct dhcpserverpb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningDHCPServerConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_dhcpserver_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningDHCPServerConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct dhcpserverpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningDHCPServerConfig(out, in);
  res = build_to_priv_dhcpserver_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningDHCPServerConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultDHCPServerConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct dhcpserverpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_dhcpserver_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultDHCPServerConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningSTPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct stppb_STPConfig *out = malloc(sizeof(*out));

  config_Config_GetRunningSTPConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_STPConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningSTPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_STPConfig *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningSTPConfig(out, in);
  res = build_to_priv_stp_STPConfig(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningSTPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultSTPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_STPConfig *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_stp_STPConfig(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultSTPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningMSTPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct stppb_MSTPConfig *out = malloc(sizeof(*out));

  config_Config_GetRunningMSTPConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_stp_MSTPConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningMSTPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_MSTPConfig *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningMSTPConfig(out, in);
  res = build_to_priv_stp_MSTPConfig(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningMSTPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultMSTPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct stppb_MSTPConfig *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_stp_MSTPConfig(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultMSTPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningTimeRangeConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct timerangepb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningTimeRangeConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_timerange_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultTimeRangeConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct timerangepb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_timerange_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultTimeRangeConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningTimeRangeConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct timerangepb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningTimeRangeConfig(out, in);
  res = build_to_priv_timerange_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningTimeRangeConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningArpInspectionConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct dhcppb_ARPInspectionConfig *out = malloc(sizeof(*out));

  config_Config_GetRunningArpInspectionConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_dhcp_ARPInspectionConfig(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultArpInspectionConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct dhcppb_ARPInspectionConfig *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_dhcp_ARPInspectionConfig(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultArpInspectionConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningArpInspectionConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct dhcppb_ARPInspectionConfig *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningArpInspectionConfig(out, in);
  res = build_to_priv_dhcp_ARPInspectionConfig(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningArpInspectionConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningPTPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct ptppb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningPTPConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_ptp_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultPTPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct ptppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_ptp_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultPTPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningPTPConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct ptppb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningPTPConfig(out, in);
  res = build_to_priv_ptp_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningPTPConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningMonitorConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct monitorpb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningMonitorConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_monitor_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultMonitorConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct monitorpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_monitor_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultMonitorConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningMonitorConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct monitorpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningMonitorConfig(out, in);
  res = build_to_priv_monitor_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningMonitorConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningTimeSyncConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct timesyncpb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningTimeSyncConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_timesync_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningTimeSyncConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct timesyncpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningTimeSyncConfig(out, in);
  res = build_to_priv_timesync_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningTimeSyncConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultTimeSyncConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct timesyncpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_timesync_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultTimeSyncConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningUdldConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct udldpb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningUdldConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_udld_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningUdldConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct udldpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningUdldConfig(out, in);
  res = build_to_priv_udld_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningUdldConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultUdldConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct udldpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_udld_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultUdldConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningPortAuthenticationConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct portauthenticationpb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningPortAuthenticationConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_portauthentication_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningPortAuthenticationConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct portauthenticationpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningPortAuthenticationConfig(out, in);
  res = build_to_priv_portauthentication_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningPortAuthenticationConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultPortAuthenticationConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct portauthenticationpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_portauthentication_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultPortAuthenticationConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_GetRunningLogConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct logpb_Config *out = malloc(sizeof(*out));

  config_Config_GetRunningLogConfig(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_config,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_log_Config(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetDefaultLogConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct logpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_log_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetDefaultLogConfig(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_config_Config_SetRunningLogConfig_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct logpb_Config *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  config_Config_GetRunningLogConfig(out, in);
  res = build_to_priv_log_Config(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  config_Config_SetRunningLogConfig(in, out);

  free(in);
  free(out);
  return res;
}

status_t y_intri_config_init(
    const xmlChar *modname,
    const xmlChar *revision) {
  status_t res = NO_ERR;
  agt_profile_t *agt_profile = agt_get_profile();

  if (xml_strcmp(modname, y_M_intri_config)) {
    return ERR_NCX_UNKNOWN_MODULE;
  }
  if (revision && xml_strcmp(revision, y_R_intri_config)) {
    return ERR_NCX_WRONG_VERSION;
  }

  res = ncxmod_load_module(
      y_M_intri_config,
      y_R_intri_config,
      &agt_profile->agt_savedevQ,
      &intri_config_mod);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-RunImportConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_RunImportConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-RunExportConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_RunExportConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetSaveModeStatus",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetSaveModeStatus_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-RunSaveRunningConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_RunSaveRunningConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-RunRestoreDefaultConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_RunRestoreDefaultConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-RunCopyRunningConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_RunCopyRunningConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-RunCopyDefaultConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_RunCopyDefaultConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetDefaultConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetDefaultConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetSavedConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetSavedConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningAclConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningAclConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningAclConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningAclConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultAclConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultAclConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningVlanConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningVlanConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningVlanConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningVlanConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultVlanConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultVlanConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningGvrpConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningGvrpConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningGvrpConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningGvrpConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultGvrpConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultGvrpConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningAccessConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningAccessConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningAccessConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningAccessConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultAccessConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultAccessConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningUserInterfaceConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningUserInterfaceConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningUserInterfaceConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningUserInterfaceConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultUserInterfaceConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultUserInterfaceConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningSystemConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningSystemConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningSystemConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningSystemConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultSystemConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultSystemConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningNetworkConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningNetworkConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningNetworkConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningNetworkConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultNetworkConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultNetworkConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningTimeConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningTimeConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningTimeConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningTimeConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultTimeConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultTimeConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningPortConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningPortConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningPortConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningPortConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultPortConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultPortConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningSFPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningSFPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningSFPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningSFPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultSFPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultSFPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningMirroringConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningMirroringConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningMirroringConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningMirroringConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultMirroringConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultMirroringConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningIsolationConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningIsolationConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningIsolationConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningIsolationConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultIsolationConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultIsolationConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningFDBConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningFDBConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningFDBConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningFDBConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultFDBConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultFDBConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningPortSecurityConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningPortSecurityConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningPortSecurityConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningPortSecurityConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultPortSecurityConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultPortSecurityConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningFilesConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningFilesConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningFilesConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningFilesConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultFilesConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultFilesConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningLACPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningLACPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningLACPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningLACPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultLACPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultLACPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningMulticastConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningMulticastConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningMulticastConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningMulticastConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultMulticastConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultMulticastConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningStormControlConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningStormControlConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningStormControlConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningStormControlConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultStormControlConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultStormControlConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningDHCPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningDHCPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningDHCPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningDHCPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultDHCPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultDHCPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningQoSConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningQoSConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningQoSConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningQoSConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultQoSConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultQoSConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningLoopConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningLoopConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningLoopConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningLoopConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultLoopConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultLoopConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningLLDPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningLLDPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningLLDPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningLLDPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultLLDPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultLLDPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningPoeConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningPoeConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningPoeConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningPoeConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultPoeConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultPoeConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningCDPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningCDPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultCDPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultCDPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningCDPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningCDPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningDHCPServerConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningDHCPServerConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningDHCPServerConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningDHCPServerConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultDHCPServerConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultDHCPServerConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningSTPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningSTPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningSTPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningSTPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultSTPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultSTPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningMSTPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningMSTPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningMSTPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningMSTPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultMSTPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultMSTPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningTimeRangeConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningTimeRangeConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultTimeRangeConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultTimeRangeConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningTimeRangeConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningTimeRangeConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningArpInspectionConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningArpInspectionConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultArpInspectionConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultArpInspectionConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningArpInspectionConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningArpInspectionConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningPTPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningPTPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultPTPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultPTPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningPTPConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningPTPConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningMonitorConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningMonitorConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultMonitorConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultMonitorConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningMonitorConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningMonitorConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningTimeSyncConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningTimeSyncConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningTimeSyncConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningTimeSyncConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultTimeSyncConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultTimeSyncConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningUdldConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningUdldConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningUdldConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningUdldConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultUdldConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultUdldConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningPortAuthenticationConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningPortAuthenticationConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningPortAuthenticationConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningPortAuthenticationConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultPortAuthenticationConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultPortAuthenticationConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningLogConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_GetRunningLogConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultLogConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetDefaultLogConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningLogConfig",
      AGT_RPC_PH_INVOKE,
      intri_config_Config_SetRunningLogConfig_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  return res;
}

status_t y_intri_config_init2(void) {
  status_t res = NO_ERR;
  return res;
}

void y_intri_config_cleanup(void) {
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-RunImportConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-RunExportConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetSaveModeStatus");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-RunSaveRunningConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-RunRestoreDefaultConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-RunCopyRunningConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-RunCopyDefaultConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetDefaultConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetSavedConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningAclConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningAclConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultAclConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningVlanConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningVlanConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultVlanConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningGvrpConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningGvrpConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultGvrpConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningAccessConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningAccessConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultAccessConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningUserInterfaceConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningUserInterfaceConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultUserInterfaceConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningSystemConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningSystemConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultSystemConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningNetworkConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningNetworkConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultNetworkConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningTimeConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningTimeConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultTimeConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningPortConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningPortConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultPortConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningSFPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningSFPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultSFPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningMirroringConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningMirroringConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultMirroringConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningIsolationConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningIsolationConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultIsolationConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningFDBConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningFDBConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultFDBConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningPortSecurityConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningPortSecurityConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultPortSecurityConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningFilesConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningFilesConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultFilesConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningLACPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningLACPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultLACPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningMulticastConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningMulticastConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultMulticastConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningStormControlConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningStormControlConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultStormControlConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningDHCPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningDHCPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultDHCPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningQoSConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningQoSConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultQoSConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningLoopConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningLoopConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultLoopConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningLLDPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningLLDPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultLLDPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningPoeConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningPoeConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultPoeConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningCDPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultCDPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningCDPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningDHCPServerConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningDHCPServerConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultDHCPServerConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningSTPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningSTPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultSTPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningMSTPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningMSTPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultMSTPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningTimeRangeConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultTimeRangeConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningTimeRangeConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningArpInspectionConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultArpInspectionConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningArpInspectionConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningPTPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultPTPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningPTPConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningMonitorConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultMonitorConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningMonitorConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningTimeSyncConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningTimeSyncConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultTimeSyncConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningUdldConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningUdldConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultUdldConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningPortAuthenticationConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningPortAuthenticationConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultPortAuthenticationConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-GetRunningLogConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetDefaultLogConfig");
  agt_rpc_unregister_method(
      y_M_intri_config,
      "intri-config-Config-SetRunningLogConfig");
}
