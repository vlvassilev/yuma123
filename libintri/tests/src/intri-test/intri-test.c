
/*
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.13-0

  Combined SIL module
  module intri-test
  revision 2022-05-24
  namespace http://intri.com.tw
  organization Intrising Inc.

 */

#include <libxml/xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "status.h"
#include "intri-test.h"

/* ian: add head files */
#include "../../../.libintrishare/libintrishare.h"

/* module static variables */
static ncx_module_t *intri_test_mod;
static obj_template_t *test_apis_obj;

/* put your static variables here */
static uint64 counter;

/********************************************************************
 * FUNCTION y_intri_test_init_static_vars
 *
 * initialize module static variables
 *
 ********************************************************************/
static void y_intri_test_init_static_vars(void)
{
  intri_test_mod = NULL;
  test_apis_obj = NULL;

  /* init your static variables here */
  counter = 0;
} /* y_intri_test_init_static_vars */

/********************************************************************
 * FUNCTION intri_test_test_apis_test_counter_counter_get
 *
 * Get database object callback
 * Path: /test-apis/test-counter/counter
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_test_test_apis_test_counter_counter_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
  status_t res = NO_ERR;

  if (LOGDEBUG)
  {
    log_debug("\nEnter intri_test_test_apis_test_counter_counter_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE)
  {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the counter var here, change zero */
  VAL_ULONG(dstval) = counter++;

  return res;

} /* intri_test_test_apis_test_counter_counter_get */

/********************************************************************
 * FUNCTION intri_test_test_apis_test_counter_mro
 *
 * Make read-only child nodes
 * Path: /test-apis/test-counter
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_test_test_apis_test_counter_mro(val_value_t *parentval)
{
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /test-apis/test-counter/counter */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_test_N_counter,
      intri_test_test_apis_test_counter_counter_get,
      &res);
  if (childval != NULL)
  {
    val_add_child(childval, parentval);
  }
  else
  {
    return res;
  }

  return res;

} /* intri_test_test_apis_test_counter_mro */

/********************************************************************
 * FUNCTION intri_test_test_apis_test_mac_addr_mac_addr_get
 *
 * Get database object callback
 * Path: /test-apis/test-mac-addr/mac-addr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_test_test_apis_test_mac_addr_mac_addr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
  status_t res = NO_ERR;
  const xmlChar *mac_addr;

  if (LOGDEBUG)
  {
    log_debug("\nEnter intri_test_test_apis_test_mac_addr_mac_addr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE)
  {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the mac_addr var here, change EMPTY_STRING */
  struct emptypb_Empty in = {};
  struct commonpb_MACAddress out = {};

  device_Device_GetMACAddress(&in, &out);

  mac_addr = out.MACAddr;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      mac_addr);

  return res;

} /* intri_test_test_apis_test_mac_addr_mac_addr_get */

/********************************************************************
 * FUNCTION intri_test_test_apis_test_mac_addr_mro
 *
 * Make read-only child nodes
 * Path: /test-apis/test-mac-addr
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_test_test_apis_test_mac_addr_mro(val_value_t *parentval)
{
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /test-apis/test-mac-addr/mac-addr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_test_N_mac_addr,
      intri_test_test_apis_test_mac_addr_mac_addr_get,
      &res);
  if (childval != NULL)
  {
    val_add_child(childval, parentval);
  }
  else
  {
    return res;
  }

  return res;

} /* intri_test_test_apis_test_mac_addr_mro */

/********************************************************************
 * FUNCTION intri_test_test_apis_mro
 *
 * Make read-only top-level node
 * Path: /test-apis
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_test_test_apis_mro(void)
{
  val_value_t *parentval = NULL, *childval = NULL;
  status_t res = NO_ERR;

  /* add /test-apis */
  res = agt_add_top_container(test_apis_obj, &parentval);
  if (res != NO_ERR)
  {
    return res;
  }
  res = agt_add_container(
      y_intri_test_M_intri_test,
      y_intri_test_N_test_counter,
      parentval,
      &childval);
  if (res != NO_ERR)
  {
    return res;
  }

  res = intri_test_test_apis_test_counter_mro(childval);
  if (res != NO_ERR)
  {
    return res;
  }

  res = agt_add_container(
      y_intri_test_M_intri_test,
      y_intri_test_N_test_mac_addr,
      parentval,
      &childval);
  if (res != NO_ERR)
  {
    return res;
  }

  res = intri_test_test_apis_test_mac_addr_mro(childval);
  if (res != NO_ERR)
  {
    return res;
  }

  return res;

} /* intri_test_test_apis_mro */

/********************************************************************
 * FUNCTION y_intri_test_init
 *
 * initialize the intri-test server instrumentation library
 *
 * INPUTS:
 *    modname == requested module name
 *    revision == requested version (NULL for any)
 *
 * RETURNS:
 *     error status
 ********************************************************************/
status_t y_intri_test_init(
    const xmlChar *modname,
    const xmlChar *revision)
{
  status_t res = NO_ERR;
  agt_profile_t *agt_profile = agt_get_profile();

  y_intri_test_init_static_vars();

  /* change if custom handling done */
  if (xml_strcmp(modname, y_intri_test_M_intri_test))
  {
    return ERR_NCX_UNKNOWN_MODULE;
  }

  if (revision && xml_strcmp(revision, y_intri_test_R_intri_test))
  {
    return ERR_NCX_WRONG_VERSION;
  }
  res = ncxmod_load_module(
      y_intri_test_M_intri_test,
      y_intri_test_R_intri_test,
      &agt_profile->agt_savedevQ,
      &intri_test_mod);
  if (res != NO_ERR)
  {
    return res;
  }

  test_apis_obj = ncx_find_object(
      intri_test_mod,
      y_intri_test_N_test_apis);
  if (intri_test_mod == NULL)
  {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  /* put your module initialization code here */

  return res;
} /* y_intri_test_init */

/********************************************************************
 * FUNCTION y_intri_test_init2
 *
 * SIL init phase 2: non-config data structures
 * Called after running config is loaded
 *
 * RETURNS:
 *     error status
 ********************************************************************/
status_t y_intri_test_init2(void)
{
  status_t res = NO_ERR;

  res = intri_test_test_apis_mro();
  if (res != NO_ERR)
  {
    return res;
  }

  /* put your init2 code here */

  return res;
} /* y_intri_test_init2 */

/********************************************************************
 * FUNCTION y_intri_test_cleanup
 *    cleanup the server instrumentation library
 *
 ********************************************************************/
void y_intri_test_cleanup(void)
{
  /* put your cleanup code here */

} /* y_intri_test_cleanup */

/* END intri_test.c */
