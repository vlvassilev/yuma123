
/*
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.13-0

  Combined SIL module
  module intri-device
  revision 2022-06-14
  namespace intri:intri-device
  organization Intrising Inc.

 */

#include <libxml/xmlstring.h>

#include "../../../.libintrishare/libintrishare.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "intri-device.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "procdefs.h"
#include "status.h"

/* module static variables */
static ncx_module_t *intri_device_mod;
static obj_template_t *intri_device_obj;
static val_value_t *intri_device_val;

/* put your static variables here */

/********************************************************************
 * FUNCTION y_intri_device_init_static_vars
 *
 * initialize module static variables
 *
 ********************************************************************/
static void y_intri_device_init_static_vars(void) {
  intri_device_mod = NULL;
  intri_device_obj = NULL;

  /* init your static variables here */

} /* y_intri_device_init_static_vars */

/********************************************************************
 * FUNCTION intri_device_intri_device_mac_addr_mac_addr_get
 *
 * Get database object callback
 * Path: /intri-device/mac-addr/mac-addr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_mac_addr_mac_addr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *mac_addr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_mac_addr_mac_addr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the mac_addr var here, change EMPTY_STRING */
  struct emptypb_Empty in;
  struct commonpb_MACAddress out;
  device_Device_GetMACAddress(&in, &out);
  mac_addr = out.MACAddr;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      mac_addr);

  return res;

} /* intri_device_intri_device_mac_addr_mac_addr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_mac_addr_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/mac-addr
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_mac_addr_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/mac-addr/mac-addr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_mac_addr,
      intri_device_intri_device_mac_addr_mac_addr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_mac_addr_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_Type_get
 *
 * Get database object callback
 * Path: /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_Type
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_Type_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *InterfaceIdentify_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_Type_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_Type var here, change enum */
  InterfaceIdentify_Type = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      InterfaceIdentify_Type);

  return res;

} /* intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_Type_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get
 *
 * Get database object callback
 * Path: /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_DeviceID
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 InterfaceIdentify_DeviceID;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_DeviceID var here, change zero */
  InterfaceIdentify_DeviceID = 0;
  VAL_INT(dstval) = InterfaceIdentify_DeviceID;

  return res;

} /* intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get
 *
 * Get database object callback
 * Path: /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_PortNo
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 InterfaceIdentify_PortNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_PortNo var here, change zero */
  InterfaceIdentify_PortNo = 0;
  VAL_INT(dstval) = InterfaceIdentify_PortNo;

  return res;

} /* intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get
 *
 * Get database object callback
 * Path: /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_LAGNo
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 InterfaceIdentify_LAGNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_LAGNo var here, change zero */
  InterfaceIdentify_LAGNo = 0;
  VAL_INT(dstval) = InterfaceIdentify_LAGNo;

  return res;

} /* intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get
 *
 * Get database object callback
 * Path: /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_VlanID
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 InterfaceIdentify_VlanID;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_VlanID var here, change zero */
  InterfaceIdentify_VlanID = 0;
  VAL_INT(dstval) = InterfaceIdentify_VlanID;

  return res;

} /* intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_port_list_List_IdentifyNo_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/port-list/List/IdentifyNo
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_port_list_List_IdentifyNo_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_Type */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_Type,
      intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_Type_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_DeviceID */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_DeviceID,
      intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_PortNo */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_PortNo,
      intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_LAGNo */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_LAGNo,
      intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/port-list/List/IdentifyNo/InterfaceIdentify_VlanID */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_VlanID,
      intri_device_intri_device_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_port_list_List_IdentifyNo_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_port_list_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/port-list
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_port_list_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* container port-list not handled!!! */

  return res;

} /* intri_device_intri_device_port_list_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_Type_get
 *
 * Get database object callback
 * Path: /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_Type
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_Type_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *InterfaceIdentify_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_Type_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_Type var here, change enum */
  InterfaceIdentify_Type = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      InterfaceIdentify_Type);

  return res;

} /* intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_Type_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get
 *
 * Get database object callback
 * Path: /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_DeviceID
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 InterfaceIdentify_DeviceID;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_DeviceID var here, change zero */
  InterfaceIdentify_DeviceID = 0;
  VAL_INT(dstval) = InterfaceIdentify_DeviceID;

  return res;

} /* intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get
 *
 * Get database object callback
 * Path: /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_PortNo
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 InterfaceIdentify_PortNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_PortNo var here, change zero */
  InterfaceIdentify_PortNo = 0;
  VAL_INT(dstval) = InterfaceIdentify_PortNo;

  return res;

} /* intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get
 *
 * Get database object callback
 * Path: /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_LAGNo
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 InterfaceIdentify_LAGNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_LAGNo var here, change zero */
  InterfaceIdentify_LAGNo = 0;
  VAL_INT(dstval) = InterfaceIdentify_LAGNo;

  return res;

} /* intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get
 *
 * Get database object callback
 * Path: /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_VlanID
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 InterfaceIdentify_VlanID;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_VlanID var here, change zero */
  InterfaceIdentify_VlanID = 0;
  VAL_INT(dstval) = InterfaceIdentify_VlanID;

  return res;

} /* intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_lag_port_list_List_IdentifyNo_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/lag-port-list/List/IdentifyNo
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_lag_port_list_List_IdentifyNo_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_Type */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_Type,
      intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_Type_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_DeviceID */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_DeviceID,
      intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_PortNo */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_PortNo,
      intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_LAGNo */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_LAGNo,
      intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/lag-port-list/List/IdentifyNo/InterfaceIdentify_VlanID */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_VlanID,
      intri_device_intri_device_lag_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_lag_port_list_List_IdentifyNo_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_lag_port_list_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/lag-port-list
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_lag_port_list_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* container lag-port-list not handled!!! */

  return res;

} /* intri_device_intri_device_lag_port_list_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_Type_get
 *
 * Get database object callback
 * Path: /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_Type
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_Type_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *InterfaceIdentify_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_Type_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_Type var here, change enum */
  InterfaceIdentify_Type = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      InterfaceIdentify_Type);

  return res;

} /* intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_Type_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get
 *
 * Get database object callback
 * Path: /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_DeviceID
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 InterfaceIdentify_DeviceID;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_DeviceID var here, change zero */
  InterfaceIdentify_DeviceID = 0;
  VAL_INT(dstval) = InterfaceIdentify_DeviceID;

  return res;

} /* intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get
 *
 * Get database object callback
 * Path: /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_PortNo
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 InterfaceIdentify_PortNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_PortNo var here, change zero */
  InterfaceIdentify_PortNo = 0;
  VAL_INT(dstval) = InterfaceIdentify_PortNo;

  return res;

} /* intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get
 *
 * Get database object callback
 * Path: /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_LAGNo
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 InterfaceIdentify_LAGNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_LAGNo var here, change zero */
  InterfaceIdentify_LAGNo = 0;
  VAL_INT(dstval) = InterfaceIdentify_LAGNo;

  return res;

} /* intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get
 *
 * Get database object callback
 * Path: /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_VlanID
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 InterfaceIdentify_VlanID;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the InterfaceIdentify_VlanID var here, change zero */
  InterfaceIdentify_VlanID = 0;
  VAL_INT(dstval) = InterfaceIdentify_VlanID;

  return res;

} /* intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_poe_port_list_List_IdentifyNo_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/poe-port-list/List/IdentifyNo
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_poe_port_list_List_IdentifyNo_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_Type */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_Type,
      intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_Type_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_DeviceID */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_DeviceID,
      intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_DeviceID_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_PortNo */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_PortNo,
      intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_PortNo_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_LAGNo */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_LAGNo,
      intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_LAGNo_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/poe-port-list/List/IdentifyNo/InterfaceIdentify_VlanID */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_VlanID,
      intri_device_intri_device_poe_port_list_List_IdentifyNo_InterfaceIdentify_VlanID_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_poe_port_list_List_IdentifyNo_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_poe_port_list_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/poe-port-list
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_poe_port_list_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* container poe-port-list not handled!!! */

  return res;

} /* intri_device_intri_device_poe_port_list_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_device_info_get
 *
 * Get database object callback
 * Path: /intri-system/status/Status_Uptime
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_device_info_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_device_info_get");
  }

  /* calls the private api */
  struct emptypb_Empty in;
  struct devicepb_Info out;
  device_Device_GetDeviceInfo(&in, &out);

  val_value_t *child_val;

  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_AltBuildDateTime,
      out.AltBuildDateTime,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_AltSwVersion,
      out.AltSwVersion,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_Board,
      out.Board,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_CurrentBuildDateTime,
      out.CurrentBuildDateTime,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_CurrentImage,
      out.CurrentImage,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_CurrentSwVersion,
      out.CurrentSwVersion,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_HwVersion,
      out.HwVersion,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_MACAddr,
      out.MACAddr,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_MACAddrFactory,
      out.MACAddrFactory,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_Model,
      out.Model,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_SerialNo,
      out.SerialNo,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_Vendor,
      out.Vendor,
      &res);
  if (res == NO_ERR) {
    val_add_child(child_val, dstval);
  }

  // const xmlChar *layer_str = EMPTY_STRING;
  // switch (out.Layer) {
  //   case devicepb_LayerTypeOptions_LAYER_TYPE_L2:
  //     layer_str = "L2";
  //   case devicepb_LayerTypeOptions_LAYER_TYPE_L3:
  //     layer_str = "L3";
  // }
  // child_val = agt_make_leaf(
  //     dstval->obj,
  //     y_intri_device_N_Info_Layer,
  //     layer_str,
  //     &res);
  // if (res == NO_ERR) {
  //   val_add_child(child_val, dstval);
  // }

  return res;
} /* intri_device_intri_device_device_info_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_device_info_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/device-info
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_device_info_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* init /intri-device/device-info */
  val_init_virtual(
      parentval,
      intri_device_intri_device_device_info_get,
      parentval->obj);

  return res;

} /* intri_device_intri_device_device_info_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_SystemDescription_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_SystemDescription
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_SystemDescription_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *BoardInfo_SystemDescription;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_SystemDescription_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the BoardInfo_SystemDescription var here, change EMPTY_STRING */
  BoardInfo_SystemDescription = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      BoardInfo_SystemDescription);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_SystemDescription_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PortNo_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_PortNo
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PortNo_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 PortInfo_PortNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PortNo_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PortInfo_PortNo var here, change zero */
  PortInfo_PortNo = 0;
  VAL_INT(dstval) = PortInfo_PortNo;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PortNo_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_MACChip_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_MACChip
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_MACChip_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 PortInfo_MACChip;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_MACChip_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PortInfo_MACChip var here, change zero */
  PortInfo_MACChip = 0;
  VAL_INT(dstval) = PortInfo_MACChip;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_MACChip_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_MACNo_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_MACNo
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_MACNo_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 PortInfo_MACNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_MACNo_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PortInfo_MACNo var here, change zero */
  PortInfo_MACNo = 0;
  VAL_INT(dstval) = PortInfo_MACNo;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_MACNo_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PortGroup_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_PortGroup
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PortGroup_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 PortInfo_PortGroup;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PortGroup_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PortInfo_PortGroup var here, change zero */
  PortInfo_PortGroup = 0;
  VAL_INT(dstval) = PortInfo_PortGroup;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PortGroup_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyID1_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_PhyID1
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyID1_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 PortInfo_PhyID1;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyID1_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PortInfo_PhyID1 var here, change zero */
  PortInfo_PhyID1 = 0;
  VAL_INT(dstval) = PortInfo_PhyID1;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyID1_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyID2_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_PhyID2
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyID2_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 PortInfo_PhyID2;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyID2_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PortInfo_PhyID2 var here, change zero */
  PortInfo_PhyID2 = 0;
  VAL_INT(dstval) = PortInfo_PhyID2;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyID2_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyInterface_PhyInterface_Interface_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_PhyInterface/PhyInterface_Interface
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyInterface_PhyInterface_Interface_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 PhyInterface_Interface;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyInterface_PhyInterface_Interface_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PhyInterface_Interface var here, change zero */
  PhyInterface_Interface = 0;
  VAL_INT(dstval) = PhyInterface_Interface;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyInterface_PhyInterface_Interface_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyInterface_PhyInterface_Type_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_PhyInterface/PhyInterface_Type
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyInterface_PhyInterface_Type_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PhyInterface_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyInterface_PhyInterface_Type_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PhyInterface_Type var here, change enum */
  PhyInterface_Type = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PhyInterface_Type);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyInterface_PhyInterface_Type_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyInterface_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_PhyInterface
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyInterface_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_PhyInterface/PhyInterface_Interface */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PhyInterface_Interface,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyInterface_PhyInterface_Interface_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_PhyInterface/PhyInterface_Type */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PhyInterface_Type,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyInterface_PhyInterface_Type_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyInterface_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PoENo_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_PoENo
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PoENo_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 PortInfo_PoENo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PoENo_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PortInfo_PoENo var here, change zero */
  PortInfo_PoENo = 0;
  VAL_INT(dstval) = PortInfo_PoENo;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PoENo_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PoEChannel_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_PoEChannel
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PoEChannel_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 PortInfo_PoEChannel;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PoEChannel_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PortInfo_PoEChannel var here, change zero */
  PortInfo_PoEChannel = 0;
  VAL_INT(dstval) = PortInfo_PoEChannel;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PoEChannel_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PoEChipNo_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_PoEChipNo
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PoEChipNo_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 PortInfo_PoEChipNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PoEChipNo_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PortInfo_PoEChipNo var here, change zero */
  PortInfo_PoEChipNo = 0;
  VAL_INT(dstval) = PortInfo_PoEChipNo;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PoEChipNo_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_MacsecEncLen_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_MacsecEncLen
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_MacsecEncLen_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 PortInfo_MacsecEncLen;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_MacsecEncLen_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PortInfo_MacsecEncLen var here, change zero */
  PortInfo_MacsecEncLen = 0;
  VAL_INT(dstval) = PortInfo_MacsecEncLen;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_MacsecEncLen_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_InterfaceType_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_InterfaceType
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_InterfaceType_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PortInfo_InterfaceType;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_InterfaceType_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PortInfo_InterfaceType var here, change enum */
  PortInfo_InterfaceType = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PortInfo_InterfaceType);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_InterfaceType_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_Properties_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_Properties
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_Properties_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PortInfo_Properties;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_Properties_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PortInfo_Properties var here, change enum */
  PortInfo_Properties = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PortInfo_Properties);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_Properties_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_DeviceID_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_DeviceID
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_DeviceID_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 PortInfo_DeviceID;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_DeviceID_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PortInfo_DeviceID var here, change zero */
  PortInfo_DeviceID = 0;
  VAL_INT(dstval) = PortInfo_DeviceID;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_DeviceID_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_SpeedProperties_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_PortLists/PortInfo_SpeedProperties
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_SpeedProperties_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PortInfo_SpeedProperties;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_SpeedProperties_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PortInfo_SpeedProperties var here, change enum */
  PortInfo_SpeedProperties = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PortInfo_SpeedProperties);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_SpeedProperties_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_PortLists_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_PortLists
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_PortLists_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_PortNo */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_PortNo,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PortNo_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_MACChip */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_MACChip,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_MACChip_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_MACNo */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_MACNo,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_MACNo_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_PortGroup */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_PortGroup,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PortGroup_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_PhyID1 */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_PhyID1,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyID1_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_PhyID2 */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_PhyID2,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyID2_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_PortInfo_PhyInterface,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PhyInterface_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_PoENo */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_PoENo,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PoENo_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_PoEChannel */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_PoEChannel,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PoEChannel_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_PoEChipNo */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_PoEChipNo,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_PoEChipNo_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_MacsecEncLen */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_MacsecEncLen,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_MacsecEncLen_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_InterfaceType */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_InterfaceType,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_InterfaceType_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_Properties */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_Properties,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_Properties_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_DeviceID */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_DeviceID,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_DeviceID_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_PortLists/PortInfo_SpeedProperties */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_SpeedProperties,
      intri_device_intri_device_board_info_BoardInfo_PortLists_PortInfo_SpeedProperties_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_PortLists_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwFeatures_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_HwFeatures
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_HwFeatures_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *BoardInfo_HwFeatures;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_HwFeatures_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the BoardInfo_HwFeatures var here, change enum */
  BoardInfo_HwFeatures = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      BoardInfo_HwFeatures);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwFeatures_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_TcamSize_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_TcamSize
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_TcamSize_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 HardwareTableSize_TcamSize;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_TcamSize_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the HardwareTableSize_TcamSize var here, change zero */
  HardwareTableSize_TcamSize = 0;
  VAL_INT(dstval) = HardwareTableSize_TcamSize;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_TcamSize_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_BridgeFDBEntries_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_BridgeFDBEntries
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_BridgeFDBEntries_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 HardwareTableSize_BridgeFDBEntries;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_BridgeFDBEntries_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the HardwareTableSize_BridgeFDBEntries var here, change zero */
  HardwareTableSize_BridgeFDBEntries = 0;
  VAL_INT(dstval) = HardwareTableSize_BridgeFDBEntries;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_BridgeFDBEntries_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_VirtualPorts_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_VirtualPorts
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_VirtualPorts_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 HardwareTableSize_VirtualPorts;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_VirtualPorts_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the HardwareTableSize_VirtualPorts var here, change zero */
  HardwareTableSize_VirtualPorts = 0;
  VAL_INT(dstval) = HardwareTableSize_VirtualPorts;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_VirtualPorts_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_VirtualBridgeDomains_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_VirtualBridgeDomains
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_VirtualBridgeDomains_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 HardwareTableSize_VirtualBridgeDomains;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_VirtualBridgeDomains_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the HardwareTableSize_VirtualBridgeDomains var here, change zero */
  HardwareTableSize_VirtualBridgeDomains = 0;
  VAL_INT(dstval) = HardwareTableSize_VirtualBridgeDomains;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_VirtualBridgeDomains_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_ARPTableEntries_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_ARPTableEntries
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_ARPTableEntries_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 HardwareTableSize_ARPTableEntries;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_ARPTableEntries_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the HardwareTableSize_ARPTableEntries var here, change zero */
  HardwareTableSize_ARPTableEntries = 0;
  VAL_INT(dstval) = HardwareTableSize_ARPTableEntries;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_ARPTableEntries_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_RouterIPv4HostEntries_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_RouterIPv4HostEntries
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_RouterIPv4HostEntries_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 HardwareTableSize_RouterIPv4HostEntries;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_RouterIPv4HostEntries_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the HardwareTableSize_RouterIPv4HostEntries var here, change zero */
  HardwareTableSize_RouterIPv4HostEntries = 0;
  VAL_INT(dstval) = HardwareTableSize_RouterIPv4HostEntries;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_RouterIPv4HostEntries_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_RouterIPv6HostEntries_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_RouterIPv6HostEntries
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_RouterIPv6HostEntries_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 HardwareTableSize_RouterIPv6HostEntries;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_RouterIPv6HostEntries_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the HardwareTableSize_RouterIPv6HostEntries var here, change zero */
  HardwareTableSize_RouterIPv6HostEntries = 0;
  VAL_INT(dstval) = HardwareTableSize_RouterIPv6HostEntries;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_RouterIPv6HostEntries_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_RouterNextHopEntries_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_RouterNextHopEntries
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_RouterNextHopEntries_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 HardwareTableSize_RouterNextHopEntries;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_RouterNextHopEntries_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the HardwareTableSize_RouterNextHopEntries var here, change zero */
  HardwareTableSize_RouterNextHopEntries = 0;
  VAL_INT(dstval) = HardwareTableSize_RouterNextHopEntries;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_RouterNextHopEntries_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_MulticastPhysicalPortGroups_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_MulticastPhysicalPortGroups
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_MulticastPhysicalPortGroups_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 HardwareTableSize_MulticastPhysicalPortGroups;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_MulticastPhysicalPortGroups_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the HardwareTableSize_MulticastPhysicalPortGroups var here, change zero */
  HardwareTableSize_MulticastPhysicalPortGroups = 0;
  VAL_INT(dstval) = HardwareTableSize_MulticastPhysicalPortGroups;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_MulticastPhysicalPortGroups_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_MulticastLinkedListEntries_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_MulticastLinkedListEntries
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_MulticastLinkedListEntries_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 HardwareTableSize_MulticastLinkedListEntries;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_MulticastLinkedListEntries_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the HardwareTableSize_MulticastLinkedListEntries var here, change zero */
  HardwareTableSize_MulticastLinkedListEntries = 0;
  VAL_INT(dstval) = HardwareTableSize_MulticastLinkedListEntries;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_MulticastLinkedListEntries_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_CentralizedCounters_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_CentralizedCounters
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_CentralizedCounters_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 HardwareTableSize_CentralizedCounters;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_CentralizedCounters_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the HardwareTableSize_CentralizedCounters var here, change zero */
  HardwareTableSize_CentralizedCounters = 0;
  VAL_INT(dstval) = HardwareTableSize_CentralizedCounters;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_CentralizedCounters_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_SpanningTreeGroups_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_SpanningTreeGroups
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_SpanningTreeGroups_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 HardwareTableSize_SpanningTreeGroups;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_SpanningTreeGroups_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the HardwareTableSize_SpanningTreeGroups var here, change zero */
  HardwareTableSize_SpanningTreeGroups = 0;
  VAL_INT(dstval) = HardwareTableSize_SpanningTreeGroups;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_SpanningTreeGroups_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_QoSProfiles_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_QoSProfiles
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_QoSProfiles_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 HardwareTableSize_QoSProfiles;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_QoSProfiles_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the HardwareTableSize_QoSProfiles var here, change zero */
  HardwareTableSize_QoSProfiles = 0;
  VAL_INT(dstval) = HardwareTableSize_QoSProfiles;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_QoSProfiles_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_L2L3PortIsolation_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_L2L3PortIsolation
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_L2L3PortIsolation_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 HardwareTableSize_L2L3PortIsolation;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_L2L3PortIsolation_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the HardwareTableSize_L2L3PortIsolation var here, change zero */
  HardwareTableSize_L2L3PortIsolation = 0;
  VAL_INT(dstval) = HardwareTableSize_L2L3PortIsolation;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_L2L3PortIsolation_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_HwSize_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_HwSize
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_HwSize_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_TcamSize */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_TcamSize,
      intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_TcamSize_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_BridgeFDBEntries */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_BridgeFDBEntries,
      intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_BridgeFDBEntries_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_VirtualPorts */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_VirtualPorts,
      intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_VirtualPorts_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_VirtualBridgeDomains */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_VirtualBridgeDomains,
      intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_VirtualBridgeDomains_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_ARPTableEntries */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_ARPTableEntries,
      intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_ARPTableEntries_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_RouterIPv4HostEntries */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_RouterIPv4HostEntries,
      intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_RouterIPv4HostEntries_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_RouterIPv6HostEntries */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_RouterIPv6HostEntries,
      intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_RouterIPv6HostEntries_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_RouterNextHopEntries */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_RouterNextHopEntries,
      intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_RouterNextHopEntries_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_MulticastPhysicalPortGroups */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_MulticastPhysicalPortGroups,
      intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_MulticastPhysicalPortGroups_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_MulticastLinkedListEntries */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_MulticastLinkedListEntries,
      intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_MulticastLinkedListEntries_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_CentralizedCounters */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_CentralizedCounters,
      intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_CentralizedCounters_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_SpanningTreeGroups */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_SpanningTreeGroups,
      intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_SpanningTreeGroups_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_QoSProfiles */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_QoSProfiles,
      intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_QoSProfiles_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_HwSize/HardwareTableSize_L2L3PortIsolation */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_L2L3PortIsolation,
      intri_device_intri_device_board_info_BoardInfo_HwSize_HardwareTableSize_L2L3PortIsolation_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_HwSize_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_CPUPort_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_CPUPort
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_CPUPort_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 BoardInfo_CPUPort;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_CPUPort_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the BoardInfo_CPUPort var here, change zero */
  BoardInfo_CPUPort = 0;
  VAL_INT(dstval) = BoardInfo_CPUPort;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_CPUPort_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *LedInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LedInfo_Name var here, change EMPTY_STRING */
  LedInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      LedInfo_Name);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_PortNo_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_PortNo
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_PortNo_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 LedInfo_PortNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_PortNo_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LedInfo_PortNo var here, change zero */
  LedInfo_PortNo = 0;
  VAL_INT(dstval) = LedInfo_PortNo;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_PortNo_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_Type_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_Type
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_Type_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *LedInfo_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_Type_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LedInfo_Type var here, change enum */
  LedInfo_Type = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      LedInfo_Type);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_Type_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *LedInfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LedInfo_Direction var here, change EMPTY_STRING */
  LedInfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      LedInfo_Direction);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCULedDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCULedDevice_I2cAddr var here, change zero */
  MCULedDevice_I2cAddr = 0;
  VAL_INT(dstval) = MCULedDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCULedDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCULedDevice_AddrRegister var here, change zero */
  MCULedDevice_AddrRegister = 0;
  VAL_INT(dstval) = MCULedDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_LedAction_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_LedAction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_LedAction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *MCULedDevice_LedAction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_LedAction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCULedDevice_LedAction var here, change enum */
  MCULedDevice_LedAction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      MCULedDevice_LedAction);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_LedAction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCULedDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCULedDevice_ActiveBit var here, change zero */
  MCULedDevice_ActiveBit = 0;
  VAL_INT(dstval) = MCULedDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_LEDDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCULedDevice_I2cAddr,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCULedDevice_AddrRegister,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_LedAction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCULedDevice_LedAction,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_LedAction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCULedDevice_ActiveBit,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_I2cAddr var here, change zero */
  I2CDevice_I2cAddr = 0;
  VAL_INT(dstval) = I2CDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_AddrRegister var here, change zero */
  I2CDevice_AddrRegister = 0;
  VAL_INT(dstval) = I2CDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_Action var here, change zero */
  I2CDevice_Action = 0;
  VAL_INT(dstval) = I2CDevice_Action;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_ActiveBit var here, change zero */
  I2CDevice_ActiveBit = 0;
  VAL_INT(dstval) = I2CDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_I2CDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_I2cAddr,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_AddrRegister,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_Action,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_ActiveBit,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Register_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Register
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Register_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Register;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Register_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Register var here, change zero */
  GPIODevice_Register = 0;
  VAL_INT(dstval) = GPIODevice_Register;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Register_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Pin_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Pin
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Pin_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Pin;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Pin_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Pin var here, change zero */
  GPIODevice_Pin = 0;
  VAL_INT(dstval) = GPIODevice_Pin;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Pin_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Action var here, change TRUE if needed */
  GPIODevice_Action = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Action;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Enable_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Enable
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Enable_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Enable;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Enable_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Enable var here, change TRUE if needed */
  GPIODevice_Enable = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Enable;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Enable_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_GPIODevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Register */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Register,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Register_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Pin */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Pin,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Pin_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Action,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Enable */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Enable,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Enable_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_LedInfo_Name,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_PortNo */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_LedInfo_PortNo,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_PortNo_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_Type */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_LedInfo_Type,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_Type_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceLed/LedInfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_LedInfo_Direction,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_LedInfo_LEDDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_LEDDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_LedInfo_I2CDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_I2CDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_LedInfo_GPIODevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_LedInfo_GPIODevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *MonitorInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MonitorInfo_Name var here, change EMPTY_STRING */
  MonitorInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      MonitorInfo_Name);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_Type_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_Type
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_Type_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *MonitorInfo_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_Type_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MonitorInfo_Type var here, change enum */
  MonitorInfo_Type = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      MonitorInfo_Type);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_Type_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *MonitorInfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MonitorInfo_Direction var here, change EMPTY_STRING */
  MonitorInfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      MonitorInfo_Direction);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUMonitorDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUMonitorDevice_I2cAddr var here, change zero */
  MCUMonitorDevice_I2cAddr = 0;
  VAL_INT(dstval) = MCUMonitorDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUMonitorDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUMonitorDevice_AddrRegister var here, change zero */
  MCUMonitorDevice_AddrRegister = 0;
  VAL_INT(dstval) = MCUMonitorDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_MonitorAction_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_MonitorAction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_MonitorAction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *MCUMonitorDevice_MonitorAction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_MonitorAction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUMonitorDevice_MonitorAction var here, change enum */
  MCUMonitorDevice_MonitorAction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      MCUMonitorDevice_MonitorAction);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_MonitorAction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUMonitorDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUMonitorDevice_ActiveBit var here, change zero */
  MCUMonitorDevice_ActiveBit = 0;
  VAL_INT(dstval) = MCUMonitorDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUMonitorDevice_I2cAddr,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUMonitorDevice_AddrRegister,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_MonitorAction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUMonitorDevice_MonitorAction,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_MonitorAction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUMonitorDevice_ActiveBit,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_I2cAddr var here, change zero */
  I2CDevice_I2cAddr = 0;
  VAL_INT(dstval) = I2CDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_AddrRegister var here, change zero */
  I2CDevice_AddrRegister = 0;
  VAL_INT(dstval) = I2CDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_Action var here, change zero */
  I2CDevice_Action = 0;
  VAL_INT(dstval) = I2CDevice_Action;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_ActiveBit var here, change zero */
  I2CDevice_ActiveBit = 0;
  VAL_INT(dstval) = I2CDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_I2cAddr,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_AddrRegister,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_Action,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_ActiveBit,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Register_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Register
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Register_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Register;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Register_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Register var here, change zero */
  GPIODevice_Register = 0;
  VAL_INT(dstval) = GPIODevice_Register;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Register_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Pin_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Pin
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Pin_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Pin;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Pin_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Pin var here, change zero */
  GPIODevice_Pin = 0;
  VAL_INT(dstval) = GPIODevice_Pin;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Pin_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Action var here, change TRUE if needed */
  GPIODevice_Action = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Action;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Enable_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Enable
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Enable_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Enable;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Enable_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Enable var here, change TRUE if needed */
  GPIODevice_Enable = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Enable;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Enable_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Register */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Register,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Register_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Pin */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Pin,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Pin_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Action,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Enable */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Enable,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Enable_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MonitorInfo_Name,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_Type */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MonitorInfo_Type,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_Type_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHWMonitor/MonitorInfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MonitorInfo_Direction,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_MonitorInfo_MonitorDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_MonitorInfo_I2CDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_MonitorInfo_GPIODevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PSUInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PSUInfo_Name var here, change EMPTY_STRING */
  PSUInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PSUInfo_Name);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_Type_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_Type
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_Type_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PSUInfo_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_Type_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PSUInfo_Type var here, change enum */
  PSUInfo_Type = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PSUInfo_Type);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_Type_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PSUInfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PSUInfo_Direction var here, change EMPTY_STRING */
  PSUInfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PSUInfo_Direction);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUPSUDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUPSUDevice_I2cAddr var here, change zero */
  MCUPSUDevice_I2cAddr = 0;
  VAL_INT(dstval) = MCUPSUDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUPSUDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUPSUDevice_AddrRegister var here, change zero */
  MCUPSUDevice_AddrRegister = 0;
  VAL_INT(dstval) = MCUPSUDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_PSUAction_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_PSUAction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_PSUAction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *MCUPSUDevice_PSUAction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_PSUAction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUPSUDevice_PSUAction var here, change enum */
  MCUPSUDevice_PSUAction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      MCUPSUDevice_PSUAction);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_PSUAction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUPSUDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUPSUDevice_ActiveBit var here, change zero */
  MCUPSUDevice_ActiveBit = 0;
  VAL_INT(dstval) = MCUPSUDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_PSUDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUPSUDevice_I2cAddr,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUPSUDevice_AddrRegister,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_PSUAction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUPSUDevice_PSUAction,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_PSUAction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUPSUDevice_ActiveBit,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_I2cAddr var here, change zero */
  I2CDevice_I2cAddr = 0;
  VAL_INT(dstval) = I2CDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_AddrRegister var here, change zero */
  I2CDevice_AddrRegister = 0;
  VAL_INT(dstval) = I2CDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_Action var here, change zero */
  I2CDevice_Action = 0;
  VAL_INT(dstval) = I2CDevice_Action;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_ActiveBit var here, change zero */
  I2CDevice_ActiveBit = 0;
  VAL_INT(dstval) = I2CDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_I2CDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_I2cAddr,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_AddrRegister,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_Action,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_ActiveBit,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Register_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Register
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Register_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Register;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Register_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Register var here, change zero */
  GPIODevice_Register = 0;
  VAL_INT(dstval) = GPIODevice_Register;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Register_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Pin_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Pin
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Pin_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Pin;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Pin_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Pin var here, change zero */
  GPIODevice_Pin = 0;
  VAL_INT(dstval) = GPIODevice_Pin;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Pin_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Action var here, change TRUE if needed */
  GPIODevice_Action = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Action;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Enable_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Enable
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Enable_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Enable;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Enable_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Enable var here, change TRUE if needed */
  GPIODevice_Enable = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Enable;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Enable_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_GPIODevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Register */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Register,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Register_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Pin */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Pin,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Pin_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Action,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Enable */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Enable,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Enable_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PSUInfo_Name,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_Type */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PSUInfo_Type,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_Type_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePSU/PSUInfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PSUInfo_Direction,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_PSUInfo_PSUDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_PSUInfo_I2CDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_PSUInfo_GPIODevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceI2C/I2Cinfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *I2Cinfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2Cinfo_Name var here, change EMPTY_STRING */
  I2Cinfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      I2Cinfo_Name);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceI2C/I2Cinfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *I2Cinfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2Cinfo_Direction var here, change EMPTY_STRING */
  I2Cinfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      I2Cinfo_Direction);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_I2cAddr var here, change zero */
  I2CDevice_I2cAddr = 0;
  VAL_INT(dstval) = I2CDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_AddrRegister var here, change zero */
  I2CDevice_AddrRegister = 0;
  VAL_INT(dstval) = I2CDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_Action var here, change zero */
  I2CDevice_Action = 0;
  VAL_INT(dstval) = I2CDevice_Action;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_ActiveBit var here, change zero */
  I2CDevice_ActiveBit = 0;
  VAL_INT(dstval) = I2CDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceI2C/I2Cinfo_Device
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_I2cAddr,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_AddrRegister,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_Action,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_ActiveBit,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceI2C
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceI2C/I2Cinfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2Cinfo_Name,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceI2C/I2Cinfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2Cinfo_Direction,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_I2Cinfo_Device,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_I2Cinfo_Device_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHW/GPIOInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *GPIOInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIOInfo_Name var here, change EMPTY_STRING */
  GPIOInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      GPIOInfo_Name);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHW/GPIOInfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *GPIOInfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIOInfo_Direction var here, change EMPTY_STRING */
  GPIOInfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      GPIOInfo_Direction);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Register_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Register
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Register_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Register;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Register_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Register var here, change zero */
  GPIODevice_Register = 0;
  VAL_INT(dstval) = GPIODevice_Register;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Register_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Pin_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Pin
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Pin_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Pin;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Pin_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Pin var here, change zero */
  GPIODevice_Pin = 0;
  VAL_INT(dstval) = GPIODevice_Pin;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Pin_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Action var here, change TRUE if needed */
  GPIODevice_Action = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Action;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Enable_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Enable
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Enable_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Enable;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Enable_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Enable var here, change TRUE if needed */
  GPIODevice_Enable = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Enable;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Enable_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHW/GPIOInfo_Device
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Register */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Register,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Register_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Pin */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Pin,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Pin_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Action,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Enable */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Enable,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Enable_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHW
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHW/GPIOInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIOInfo_Name,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceHW/GPIOInfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIOInfo_Direction,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_GPIOInfo_Device,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_GPIOInfo_Device_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PTPClockSynchronizerInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PTPClockSynchronizerInfo_Name var here, change EMPTY_STRING */
  PTPClockSynchronizerInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PTPClockSynchronizerInfo_Name);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PTPClockSynchronizerInfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PTPClockSynchronizerInfo_Direction var here, change EMPTY_STRING */
  PTPClockSynchronizerInfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PTPClockSynchronizerInfo_Direction);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_I2cAddr var here, change zero */
  I2CDevice_I2cAddr = 0;
  VAL_INT(dstval) = I2CDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_AddrRegister var here, change zero */
  I2CDevice_AddrRegister = 0;
  VAL_INT(dstval) = I2CDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_Action var here, change zero */
  I2CDevice_Action = 0;
  VAL_INT(dstval) = I2CDevice_Action;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_ActiveBit var here, change zero */
  I2CDevice_ActiveBit = 0;
  VAL_INT(dstval) = I2CDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_I2cAddr,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_AddrRegister,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_Action,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_ActiveBit,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePTP
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PTPClockSynchronizerInfo_Name,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PTPClockSynchronizerInfo_Direction,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_PTPClockSynchronizerInfo_Device,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_GPSInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceGPS/GPSInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_GPSInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *GPSInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_GPSInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPSInfo_Name var here, change EMPTY_STRING */
  GPSInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      GPSInfo_Name);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_GPSInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_GPSInfo_Path_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceGPS/GPSInfo_Path
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_GPSInfo_Path_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *GPSInfo_Path;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_GPSInfo_Path_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPSInfo_Path var here, change EMPTY_STRING */
  GPSInfo_Path = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      GPSInfo_Path);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_GPSInfo_Path_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_GPSInfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceGPS/GPSInfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_GPSInfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *GPSInfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_GPSInfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPSInfo_Direction var here, change EMPTY_STRING */
  GPSInfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      GPSInfo_Direction);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_GPSInfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceGPS
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceGPS/GPSInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPSInfo_Name,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_GPSInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceGPS/GPSInfo_Path */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPSInfo_Path,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_GPSInfo_Path_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceGPS/GPSInfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPSInfo_Direction,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_GPSInfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_ToDInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceToD/ToDInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_ToDInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *ToDInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_ToDInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the ToDInfo_Name var here, change EMPTY_STRING */
  ToDInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      ToDInfo_Name);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_ToDInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_ToDInfo_Path_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceToD/ToDInfo_Path
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_ToDInfo_Path_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *ToDInfo_Path;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_ToDInfo_Path_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the ToDInfo_Path var here, change EMPTY_STRING */
  ToDInfo_Path = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      ToDInfo_Path);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_ToDInfo_Path_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_ToDInfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceToD/ToDInfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_ToDInfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *ToDInfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_ToDInfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the ToDInfo_Direction var here, change EMPTY_STRING */
  ToDInfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      ToDInfo_Direction);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_ToDInfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceToD
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceToD/ToDInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_ToDInfo_Name,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_ToDInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceToD/ToDInfo_Path */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_ToDInfo_Path,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_ToDInfo_Path_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceToD/ToDInfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_ToDInfo_Direction,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_ToDInfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *FanInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the FanInfo_Name var here, change EMPTY_STRING */
  FanInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      FanInfo_Name);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_Type_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_Type
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_Type_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *FanInfo_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_Type_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the FanInfo_Type var here, change enum */
  FanInfo_Type = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      FanInfo_Type);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_Type_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FanNumber_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_FanNumber
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FanNumber_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 FanInfo_FanNumber;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FanNumber_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the FanInfo_FanNumber var here, change zero */
  FanInfo_FanNumber = 0;
  VAL_INT(dstval) = FanInfo_FanNumber;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FanNumber_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUFanDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUFanDevice_I2cAddr var here, change zero */
  MCUFanDevice_I2cAddr = 0;
  VAL_INT(dstval) = MCUFanDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUFanDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUFanDevice_AddrRegister var here, change zero */
  MCUFanDevice_AddrRegister = 0;
  VAL_INT(dstval) = MCUFanDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_FANAction_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_FANAction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_FANAction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *MCUFanDevice_FANAction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_FANAction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUFanDevice_FANAction var here, change enum */
  MCUFanDevice_FANAction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      MCUFanDevice_FANAction);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_FANAction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUFanDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUFanDevice_ActiveBit var here, change zero */
  MCUFanDevice_ActiveBit = 0;
  VAL_INT(dstval) = MCUFanDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_FANDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUFanDevice_I2cAddr,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUFanDevice_AddrRegister,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_FANAction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUFanDevice_FANAction,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_FANAction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUFanDevice_ActiveBit,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_I2cAddr var here, change zero */
  I2CDevice_I2cAddr = 0;
  VAL_INT(dstval) = I2CDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_AddrRegister var here, change zero */
  I2CDevice_AddrRegister = 0;
  VAL_INT(dstval) = I2CDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_Action var here, change zero */
  I2CDevice_Action = 0;
  VAL_INT(dstval) = I2CDevice_Action;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_ActiveBit var here, change zero */
  I2CDevice_ActiveBit = 0;
  VAL_INT(dstval) = I2CDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_I2CDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_I2cAddr,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_AddrRegister,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_Action,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_ActiveBit,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Register_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Register
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Register_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Register;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Register_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Register var here, change zero */
  GPIODevice_Register = 0;
  VAL_INT(dstval) = GPIODevice_Register;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Register_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Pin_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Pin
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Pin_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Pin;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Pin_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Pin var here, change zero */
  GPIODevice_Pin = 0;
  VAL_INT(dstval) = GPIODevice_Pin;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Pin_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Action var here, change TRUE if needed */
  GPIODevice_Action = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Action;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Enable_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Enable
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Enable_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Enable;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Enable_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Enable var here, change TRUE if needed */
  GPIODevice_Enable = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Enable;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Enable_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_GPIODevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Register */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Register,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Register_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Pin */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Pin,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Pin_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Action,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Enable */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Enable,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Enable_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_FanInfo_Name,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_Type */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_FanInfo_Type,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_Type_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DeviceFan/FanInfo_FanNumber */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_FanInfo_FanNumber,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FanNumber_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_FanInfo_FANDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_FANDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_FanInfo_I2CDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_I2CDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_FanInfo_GPIODevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_FanInfo_GPIODevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PoEInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PoEInfo_Name var here, change EMPTY_STRING */
  PoEInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PoEInfo_Name);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_Type_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_Type
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_Type_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PoEInfo_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_Type_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PoEInfo_Type var here, change enum */
  PoEInfo_Type = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PoEInfo_Type);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_Type_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_I2cAddr var here, change zero */
  I2CDevice_I2cAddr = 0;
  VAL_INT(dstval) = I2CDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_AddrRegister var here, change zero */
  I2CDevice_AddrRegister = 0;
  VAL_INT(dstval) = I2CDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_Action var here, change zero */
  I2CDevice_Action = 0;
  VAL_INT(dstval) = I2CDevice_Action;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_ActiveBit var here, change zero */
  I2CDevice_ActiveBit = 0;
  VAL_INT(dstval) = I2CDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_I2CDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_I2cAddr,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_AddrRegister,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_Action,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_ActiveBit,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Name_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *UARTDevice_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the UARTDevice_Name var here, change EMPTY_STRING */
  UARTDevice_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      UARTDevice_Name);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Path_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Path
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Path_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *UARTDevice_Path;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Path_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the UARTDevice_Path var here, change EMPTY_STRING */
  UARTDevice_Path = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      UARTDevice_Path);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Path_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *UARTDevice_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the UARTDevice_Direction var here, change EMPTY_STRING */
  UARTDevice_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      UARTDevice_Direction);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Bandwidth_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Bandwidth
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Bandwidth_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 UARTDevice_Bandwidth;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Bandwidth_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the UARTDevice_Bandwidth var here, change zero */
  UARTDevice_Bandwidth = 0;
  VAL_INT(dstval) = UARTDevice_Bandwidth;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Bandwidth_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_UartDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_UARTDevice_Name,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Path */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_UARTDevice_Path,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Path_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_UARTDevice_Direction,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Bandwidth */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_UARTDevice_Bandwidth,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Bandwidth_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PoEInfo_Name,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice/HardwareInfo_DevicePoE/PoEInfo_Type */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PoEInfo_Type,
      intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_Type_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_PoEInfo_I2CDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_PoEInfo_UartDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_PoEInfo_UartDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_BoardDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_BoardDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_BoardDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DeviceLed,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceLed_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DeviceHWMonitor,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHWMonitor_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DevicePSU,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePSU_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DeviceI2C,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceI2C_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DeviceHW,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceHW_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DevicePTP,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePTP_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DeviceGPS,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceGPS_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DeviceToD,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceToD_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DeviceFan,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DeviceFan_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DevicePoE,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_HardwareInfo_DevicePoE_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_BoardDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_InputClockMapping_name_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_InputClockMapping/name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_InputClockMapping_name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_InputClockMapping_name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the name var here, change EMPTY_STRING */
  name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      name);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_InputClockMapping_name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_InputClockMapping_value_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_InputClockMapping/value
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_InputClockMapping_value_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *value;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_InputClockMapping_value_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the value var here, change enum */
  value = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      value);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_InputClockMapping_value_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_PortNo_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_PortInfoList/TimeControlPortInfoEntry_PortNo
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_PortNo_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 TimeControlPortInfoEntry_PortNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_PortNo_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the TimeControlPortInfoEntry_PortNo var here, change zero */
  TimeControlPortInfoEntry_PortNo = 0;
  VAL_INT(dstval) = TimeControlPortInfoEntry_PortNo;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_PortNo_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_RCLKPin_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_PortInfoList/TimeControlPortInfoEntry_RCLKPin
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_RCLKPin_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *TimeControlPortInfoEntry_RCLKPin;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_RCLKPin_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the TimeControlPortInfoEntry_RCLKPin var here, change enum */
  TimeControlPortInfoEntry_RCLKPin = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      TimeControlPortInfoEntry_RCLKPin);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_RCLKPin_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_Frequency_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_PortInfoList/TimeControlPortInfoEntry_Frequency
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_Frequency_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int64 TimeControlPortInfoEntry_Frequency;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_Frequency_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the TimeControlPortInfoEntry_Frequency var here, change zero */
  TimeControlPortInfoEntry_Frequency = 0;
  VAL_LONG(dstval) = TimeControlPortInfoEntry_Frequency;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_Frequency_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_InputClock_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_PortInfoList/TimeControlPortInfoEntry_InputClock
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_InputClock_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *TimeControlPortInfoEntry_InputClock;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_InputClock_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the TimeControlPortInfoEntry_InputClock var here, change enum */
  TimeControlPortInfoEntry_InputClock = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      TimeControlPortInfoEntry_InputClock);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_InputClock_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_PortInfoList
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_PortInfoList/TimeControlPortInfoEntry_PortNo */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_TimeControlPortInfoEntry_PortNo,
      intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_PortNo_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_PortInfoList/TimeControlPortInfoEntry_RCLKPin */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_TimeControlPortInfoEntry_RCLKPin,
      intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_RCLKPin_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_PortInfoList/TimeControlPortInfoEntry_Frequency */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_TimeControlPortInfoEntry_Frequency,
      intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_Frequency_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_PortInfoList/TimeControlPortInfoEntry_InputClock */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_TimeControlPortInfoEntry_InputClock,
      intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_TimeControlPortInfoEntry_InputClock_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_Speed_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_SpeedFrequencyList/TimeControlSpeedFrequencyEntry_Speed
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_Speed_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *TimeControlSpeedFrequencyEntry_Speed;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_Speed_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the TimeControlSpeedFrequencyEntry_Speed var here, change enum */
  TimeControlSpeedFrequencyEntry_Speed = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      TimeControlSpeedFrequencyEntry_Speed);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_Speed_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_Frequency_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_SpeedFrequencyList/TimeControlSpeedFrequencyEntry_Frequency
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_Frequency_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int64 TimeControlSpeedFrequencyEntry_Frequency;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_Frequency_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the TimeControlSpeedFrequencyEntry_Frequency var here, change zero */
  TimeControlSpeedFrequencyEntry_Frequency = 0;
  VAL_LONG(dstval) = TimeControlSpeedFrequencyEntry_Frequency;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_Frequency_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_M_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_SpeedFrequencyList/TimeControlSpeedFrequencyEntry_M
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_M_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int64 TimeControlSpeedFrequencyEntry_M;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_M_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the TimeControlSpeedFrequencyEntry_M var here, change zero */
  TimeControlSpeedFrequencyEntry_M = 0;
  VAL_LONG(dstval) = TimeControlSpeedFrequencyEntry_M;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_M_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_N_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_SpeedFrequencyList/TimeControlSpeedFrequencyEntry_N
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_N_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int64 TimeControlSpeedFrequencyEntry_N;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_N_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the TimeControlSpeedFrequencyEntry_N var here, change zero */
  TimeControlSpeedFrequencyEntry_N = 0;
  VAL_LONG(dstval) = TimeControlSpeedFrequencyEntry_N;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_N_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_Div_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_SpeedFrequencyList/TimeControlSpeedFrequencyEntry_Div
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_Div_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int64 TimeControlSpeedFrequencyEntry_Div;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_Div_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the TimeControlSpeedFrequencyEntry_Div var here, change zero */
  TimeControlSpeedFrequencyEntry_Div = 0;
  VAL_LONG(dstval) = TimeControlSpeedFrequencyEntry_Div;

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_Div_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_SpeedFrequencyList
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_SpeedFrequencyList/TimeControlSpeedFrequencyEntry_Speed */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_TimeControlSpeedFrequencyEntry_Speed,
      intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_Speed_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_SpeedFrequencyList/TimeControlSpeedFrequencyEntry_Frequency */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_TimeControlSpeedFrequencyEntry_Frequency,
      intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_Frequency_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_SpeedFrequencyList/TimeControlSpeedFrequencyEntry_M */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_TimeControlSpeedFrequencyEntry_M,
      intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_M_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_SpeedFrequencyList/TimeControlSpeedFrequencyEntry_N */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_TimeControlSpeedFrequencyEntry_N,
      intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_N_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_TimeControl/TimeControlInfo_SpeedFrequencyList/TimeControlSpeedFrequencyEntry_Div */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_TimeControlSpeedFrequencyEntry_Div,
      intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_TimeControlSpeedFrequencyEntry_Div_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_TimeControl_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info/BoardInfo_TimeControl
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_BoardInfo_TimeControl_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* container BoardInfo_TimeControl not handled!!! */
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_TimeControlInfo_PortInfoList,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_PortInfoList_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_TimeControlInfo_SpeedFrequencyList,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_TimeControl_TimeControlInfo_SpeedFrequencyList_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_TimeControl_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_BoardInfo_EnterpriseOID_get
 *
 * Get database object callback
 * Path: /intri-device/board-info/BoardInfo_EnterpriseOID
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_board_info_BoardInfo_EnterpriseOID_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *BoardInfo_EnterpriseOID;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_BoardInfo_EnterpriseOID_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the BoardInfo_EnterpriseOID var here, change EMPTY_STRING */
  BoardInfo_EnterpriseOID = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      BoardInfo_EnterpriseOID);

  return res;

} /* intri_device_intri_device_board_info_BoardInfo_EnterpriseOID_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/board-info/BoardInfo_SystemDescription */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_BoardInfo_SystemDescription,
      intri_device_intri_device_board_info_BoardInfo_SystemDescription_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_BoardInfo_PortLists,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_PortLists_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_HwFeatures */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_BoardInfo_HwFeatures,
      intri_device_intri_device_board_info_BoardInfo_HwFeatures_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_BoardInfo_HwSize,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_HwSize_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_CPUPort */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_BoardInfo_CPUPort,
      intri_device_intri_device_board_info_BoardInfo_CPUPort_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_BoardInfo_BoardDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_BoardDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_BoardInfo_TimeControl,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_board_info_BoardInfo_TimeControl_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/board-info/BoardInfo_EnterpriseOID */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_BoardInfo_EnterpriseOID,
      intri_device_intri_device_board_info_BoardInfo_EnterpriseOID_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_board_info_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *LedInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LedInfo_Name var here, change EMPTY_STRING */
  LedInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      LedInfo_Name);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_PortNo_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_PortNo
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_PortNo_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 LedInfo_PortNo;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_PortNo_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LedInfo_PortNo var here, change zero */
  LedInfo_PortNo = 0;
  VAL_INT(dstval) = LedInfo_PortNo;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_PortNo_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_Type_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_Type
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_Type_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *LedInfo_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_Type_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LedInfo_Type var here, change enum */
  LedInfo_Type = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      LedInfo_Type);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_Type_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *LedInfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the LedInfo_Direction var here, change EMPTY_STRING */
  LedInfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      LedInfo_Direction);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCULedDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCULedDevice_I2cAddr var here, change zero */
  MCULedDevice_I2cAddr = 0;
  VAL_INT(dstval) = MCULedDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCULedDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCULedDevice_AddrRegister var here, change zero */
  MCULedDevice_AddrRegister = 0;
  VAL_INT(dstval) = MCULedDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_LedAction_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_LedAction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_LedAction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *MCULedDevice_LedAction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_LedAction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCULedDevice_LedAction var here, change enum */
  MCULedDevice_LedAction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      MCULedDevice_LedAction);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_LedAction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCULedDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCULedDevice_ActiveBit var here, change zero */
  MCULedDevice_ActiveBit = 0;
  VAL_INT(dstval) = MCULedDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_LEDDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCULedDevice_I2cAddr,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCULedDevice_AddrRegister,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_LedAction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCULedDevice_LedAction,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_LedAction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_LEDDevice/MCULedDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCULedDevice_ActiveBit,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_MCULedDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_I2cAddr var here, change zero */
  I2CDevice_I2cAddr = 0;
  VAL_INT(dstval) = I2CDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_AddrRegister var here, change zero */
  I2CDevice_AddrRegister = 0;
  VAL_INT(dstval) = I2CDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_Action var here, change zero */
  I2CDevice_Action = 0;
  VAL_INT(dstval) = I2CDevice_Action;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_ActiveBit var here, change zero */
  I2CDevice_ActiveBit = 0;
  VAL_INT(dstval) = I2CDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_I2CDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_I2cAddr,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_AddrRegister,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_Action,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_I2CDevice/I2CDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_ActiveBit,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_I2CDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Register_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Register
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Register_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Register;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Register_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Register var here, change zero */
  GPIODevice_Register = 0;
  VAL_INT(dstval) = GPIODevice_Register;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Register_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Pin_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Pin
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Pin_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Pin;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Pin_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Pin var here, change zero */
  GPIODevice_Pin = 0;
  VAL_INT(dstval) = GPIODevice_Pin;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Pin_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Action var here, change TRUE if needed */
  GPIODevice_Action = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Action;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Enable_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Enable
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Enable_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Enable;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Enable_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Enable var here, change TRUE if needed */
  GPIODevice_Enable = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Enable;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Enable_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_GPIODevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Register */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Register,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Register_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Pin */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Pin,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Pin_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Action,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_GPIODevice/GPIODevice_Enable */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Enable,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_GPIODevice_Enable_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceLed
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_LedInfo_Name,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_PortNo */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_LedInfo_PortNo,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_PortNo_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_Type */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_LedInfo_Type,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_Type_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceLed/LedInfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_LedInfo_Direction,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_LedInfo_LEDDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_LEDDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_LedInfo_I2CDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_I2CDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_LedInfo_GPIODevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_LedInfo_GPIODevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *MonitorInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MonitorInfo_Name var here, change EMPTY_STRING */
  MonitorInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      MonitorInfo_Name);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_Type_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_Type
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_Type_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *MonitorInfo_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_Type_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MonitorInfo_Type var here, change enum */
  MonitorInfo_Type = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      MonitorInfo_Type);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_Type_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *MonitorInfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MonitorInfo_Direction var here, change EMPTY_STRING */
  MonitorInfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      MonitorInfo_Direction);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUMonitorDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUMonitorDevice_I2cAddr var here, change zero */
  MCUMonitorDevice_I2cAddr = 0;
  VAL_INT(dstval) = MCUMonitorDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUMonitorDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUMonitorDevice_AddrRegister var here, change zero */
  MCUMonitorDevice_AddrRegister = 0;
  VAL_INT(dstval) = MCUMonitorDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_MonitorAction_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_MonitorAction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_MonitorAction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *MCUMonitorDevice_MonitorAction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_MonitorAction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUMonitorDevice_MonitorAction var here, change enum */
  MCUMonitorDevice_MonitorAction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      MCUMonitorDevice_MonitorAction);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_MonitorAction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUMonitorDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUMonitorDevice_ActiveBit var here, change zero */
  MCUMonitorDevice_ActiveBit = 0;
  VAL_INT(dstval) = MCUMonitorDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUMonitorDevice_I2cAddr,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUMonitorDevice_AddrRegister,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_MonitorAction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUMonitorDevice_MonitorAction,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_MonitorAction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_MonitorDevice/MCUMonitorDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUMonitorDevice_ActiveBit,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_MCUMonitorDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_I2cAddr var here, change zero */
  I2CDevice_I2cAddr = 0;
  VAL_INT(dstval) = I2CDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_AddrRegister var here, change zero */
  I2CDevice_AddrRegister = 0;
  VAL_INT(dstval) = I2CDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_Action var here, change zero */
  I2CDevice_Action = 0;
  VAL_INT(dstval) = I2CDevice_Action;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_ActiveBit var here, change zero */
  I2CDevice_ActiveBit = 0;
  VAL_INT(dstval) = I2CDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_I2cAddr,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_AddrRegister,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_Action,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_I2CDevice/I2CDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_ActiveBit,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_I2CDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Register_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Register
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Register_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Register;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Register_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Register var here, change zero */
  GPIODevice_Register = 0;
  VAL_INT(dstval) = GPIODevice_Register;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Register_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Pin_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Pin
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Pin_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Pin;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Pin_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Pin var here, change zero */
  GPIODevice_Pin = 0;
  VAL_INT(dstval) = GPIODevice_Pin;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Pin_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Action var here, change TRUE if needed */
  GPIODevice_Action = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Action;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Enable_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Enable
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Enable_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Enable;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Enable_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Enable var here, change TRUE if needed */
  GPIODevice_Enable = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Enable;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Enable_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Register */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Register,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Register_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Pin */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Pin,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Pin_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Action,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_GPIODevice/GPIODevice_Enable */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Enable,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_GPIODevice_Enable_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MonitorInfo_Name,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_Type */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MonitorInfo_Type,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_Type_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHWMonitor/MonitorInfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MonitorInfo_Direction,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_MonitorInfo_MonitorDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_MonitorDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_MonitorInfo_I2CDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_I2CDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_MonitorInfo_GPIODevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_MonitorInfo_GPIODevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PSUInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PSUInfo_Name var here, change EMPTY_STRING */
  PSUInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PSUInfo_Name);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_Type_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_Type
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_Type_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PSUInfo_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_Type_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PSUInfo_Type var here, change enum */
  PSUInfo_Type = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PSUInfo_Type);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_Type_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PSUInfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PSUInfo_Direction var here, change EMPTY_STRING */
  PSUInfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PSUInfo_Direction);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUPSUDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUPSUDevice_I2cAddr var here, change zero */
  MCUPSUDevice_I2cAddr = 0;
  VAL_INT(dstval) = MCUPSUDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUPSUDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUPSUDevice_AddrRegister var here, change zero */
  MCUPSUDevice_AddrRegister = 0;
  VAL_INT(dstval) = MCUPSUDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_PSUAction_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_PSUAction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_PSUAction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *MCUPSUDevice_PSUAction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_PSUAction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUPSUDevice_PSUAction var here, change enum */
  MCUPSUDevice_PSUAction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      MCUPSUDevice_PSUAction);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_PSUAction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUPSUDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUPSUDevice_ActiveBit var here, change zero */
  MCUPSUDevice_ActiveBit = 0;
  VAL_INT(dstval) = MCUPSUDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_PSUDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUPSUDevice_I2cAddr,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUPSUDevice_AddrRegister,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_PSUAction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUPSUDevice_PSUAction,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_PSUAction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_PSUDevice/MCUPSUDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUPSUDevice_ActiveBit,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_MCUPSUDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_I2cAddr var here, change zero */
  I2CDevice_I2cAddr = 0;
  VAL_INT(dstval) = I2CDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_AddrRegister var here, change zero */
  I2CDevice_AddrRegister = 0;
  VAL_INT(dstval) = I2CDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_Action var here, change zero */
  I2CDevice_Action = 0;
  VAL_INT(dstval) = I2CDevice_Action;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_ActiveBit var here, change zero */
  I2CDevice_ActiveBit = 0;
  VAL_INT(dstval) = I2CDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_I2CDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_I2cAddr,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_AddrRegister,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_Action,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_I2CDevice/I2CDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_ActiveBit,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_I2CDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Register_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Register
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Register_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Register;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Register_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Register var here, change zero */
  GPIODevice_Register = 0;
  VAL_INT(dstval) = GPIODevice_Register;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Register_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Pin_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Pin
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Pin_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Pin;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Pin_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Pin var here, change zero */
  GPIODevice_Pin = 0;
  VAL_INT(dstval) = GPIODevice_Pin;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Pin_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Action var here, change TRUE if needed */
  GPIODevice_Action = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Action;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Enable_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Enable
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Enable_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Enable;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Enable_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Enable var here, change TRUE if needed */
  GPIODevice_Enable = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Enable;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Enable_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_GPIODevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Register */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Register,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Register_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Pin */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Pin,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Pin_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Action,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_GPIODevice/GPIODevice_Enable */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Enable,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_GPIODevice_Enable_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePSU
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PSUInfo_Name,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_Type */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PSUInfo_Type,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_Type_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePSU/PSUInfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PSUInfo_Direction,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_PSUInfo_PSUDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_PSUDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_PSUInfo_I2CDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_I2CDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_PSUInfo_GPIODevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_PSUInfo_GPIODevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceI2C/I2Cinfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *I2Cinfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2Cinfo_Name var here, change EMPTY_STRING */
  I2Cinfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      I2Cinfo_Name);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceI2C/I2Cinfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *I2Cinfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2Cinfo_Direction var here, change EMPTY_STRING */
  I2Cinfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      I2Cinfo_Direction);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_I2cAddr var here, change zero */
  I2CDevice_I2cAddr = 0;
  VAL_INT(dstval) = I2CDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_AddrRegister var here, change zero */
  I2CDevice_AddrRegister = 0;
  VAL_INT(dstval) = I2CDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_Action var here, change zero */
  I2CDevice_Action = 0;
  VAL_INT(dstval) = I2CDevice_Action;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_ActiveBit var here, change zero */
  I2CDevice_ActiveBit = 0;
  VAL_INT(dstval) = I2CDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceI2C/I2Cinfo_Device
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_I2cAddr,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_AddrRegister,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_Action,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceI2C/I2Cinfo_Device/I2CDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_ActiveBit,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_I2CDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceI2C
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceI2C/I2Cinfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2Cinfo_Name,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceI2C/I2Cinfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2Cinfo_Direction,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_I2Cinfo_Device,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_I2Cinfo_Device_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHW/GPIOInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *GPIOInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIOInfo_Name var here, change EMPTY_STRING */
  GPIOInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      GPIOInfo_Name);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHW/GPIOInfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *GPIOInfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIOInfo_Direction var here, change EMPTY_STRING */
  GPIOInfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      GPIOInfo_Direction);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Register_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Register
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Register_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Register;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Register_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Register var here, change zero */
  GPIODevice_Register = 0;
  VAL_INT(dstval) = GPIODevice_Register;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Register_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Pin_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Pin
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Pin_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Pin;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Pin_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Pin var here, change zero */
  GPIODevice_Pin = 0;
  VAL_INT(dstval) = GPIODevice_Pin;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Pin_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Action var here, change TRUE if needed */
  GPIODevice_Action = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Action;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Enable_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Enable
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Enable_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Enable;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Enable_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Enable var here, change TRUE if needed */
  GPIODevice_Enable = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Enable;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Enable_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHW/GPIOInfo_Device
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Register */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Register,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Register_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Pin */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Pin,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Pin_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Action,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHW/GPIOInfo_Device/GPIODevice_Enable */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Enable,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_GPIODevice_Enable_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceHW
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHW/GPIOInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIOInfo_Name,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceHW/GPIOInfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIOInfo_Direction,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_GPIOInfo_Device,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_GPIOInfo_Device_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PTPClockSynchronizerInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PTPClockSynchronizerInfo_Name var here, change EMPTY_STRING */
  PTPClockSynchronizerInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PTPClockSynchronizerInfo_Name);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PTPClockSynchronizerInfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PTPClockSynchronizerInfo_Direction var here, change EMPTY_STRING */
  PTPClockSynchronizerInfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PTPClockSynchronizerInfo_Direction);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_I2cAddr var here, change zero */
  I2CDevice_I2cAddr = 0;
  VAL_INT(dstval) = I2CDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_AddrRegister var here, change zero */
  I2CDevice_AddrRegister = 0;
  VAL_INT(dstval) = I2CDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_Action var here, change zero */
  I2CDevice_Action = 0;
  VAL_INT(dstval) = I2CDevice_Action;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_ActiveBit var here, change zero */
  I2CDevice_ActiveBit = 0;
  VAL_INT(dstval) = I2CDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_I2cAddr,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_AddrRegister,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_Action,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Device/I2CDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_ActiveBit,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_I2CDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePTP
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PTPClockSynchronizerInfo_Name,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePTP/PTPClockSynchronizerInfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PTPClockSynchronizerInfo_Direction,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_PTPClockSynchronizerInfo_Device,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_PTPClockSynchronizerInfo_Device_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_GPSInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceGPS/GPSInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_GPSInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *GPSInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_GPSInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPSInfo_Name var here, change EMPTY_STRING */
  GPSInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      GPSInfo_Name);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_GPSInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_GPSInfo_Path_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceGPS/GPSInfo_Path
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_GPSInfo_Path_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *GPSInfo_Path;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_GPSInfo_Path_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPSInfo_Path var here, change EMPTY_STRING */
  GPSInfo_Path = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      GPSInfo_Path);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_GPSInfo_Path_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_GPSInfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceGPS/GPSInfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_GPSInfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *GPSInfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_GPSInfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPSInfo_Direction var here, change EMPTY_STRING */
  GPSInfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      GPSInfo_Direction);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_GPSInfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceGPS
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceGPS/GPSInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPSInfo_Name,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_GPSInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceGPS/GPSInfo_Path */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPSInfo_Path,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_GPSInfo_Path_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceGPS/GPSInfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPSInfo_Direction,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_GPSInfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_ToDInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceToD/ToDInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_ToDInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *ToDInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_ToDInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the ToDInfo_Name var here, change EMPTY_STRING */
  ToDInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      ToDInfo_Name);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_ToDInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_ToDInfo_Path_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceToD/ToDInfo_Path
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_ToDInfo_Path_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *ToDInfo_Path;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_ToDInfo_Path_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the ToDInfo_Path var here, change EMPTY_STRING */
  ToDInfo_Path = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      ToDInfo_Path);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_ToDInfo_Path_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_ToDInfo_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceToD/ToDInfo_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_ToDInfo_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *ToDInfo_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_ToDInfo_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the ToDInfo_Direction var here, change EMPTY_STRING */
  ToDInfo_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      ToDInfo_Direction);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_ToDInfo_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceToD
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceToD/ToDInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_ToDInfo_Name,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_ToDInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceToD/ToDInfo_Path */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_ToDInfo_Path,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_ToDInfo_Path_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceToD/ToDInfo_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_ToDInfo_Direction,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_ToDInfo_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *FanInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the FanInfo_Name var here, change EMPTY_STRING */
  FanInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      FanInfo_Name);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_Type_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_Type
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_Type_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *FanInfo_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_Type_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the FanInfo_Type var here, change enum */
  FanInfo_Type = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      FanInfo_Type);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_Type_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FanNumber_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_FanNumber
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FanNumber_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 FanInfo_FanNumber;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FanNumber_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the FanInfo_FanNumber var here, change zero */
  FanInfo_FanNumber = 0;
  VAL_INT(dstval) = FanInfo_FanNumber;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FanNumber_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUFanDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUFanDevice_I2cAddr var here, change zero */
  MCUFanDevice_I2cAddr = 0;
  VAL_INT(dstval) = MCUFanDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUFanDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUFanDevice_AddrRegister var here, change zero */
  MCUFanDevice_AddrRegister = 0;
  VAL_INT(dstval) = MCUFanDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_FANAction_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_FANAction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_FANAction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *MCUFanDevice_FANAction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_FANAction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUFanDevice_FANAction var here, change enum */
  MCUFanDevice_FANAction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      MCUFanDevice_FANAction);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_FANAction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 MCUFanDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the MCUFanDevice_ActiveBit var here, change zero */
  MCUFanDevice_ActiveBit = 0;
  VAL_INT(dstval) = MCUFanDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_FANDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUFanDevice_I2cAddr,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUFanDevice_AddrRegister,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_FANAction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUFanDevice_FANAction,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_FANAction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_FANDevice/MCUFanDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_MCUFanDevice_ActiveBit,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_MCUFanDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_I2cAddr var here, change zero */
  I2CDevice_I2cAddr = 0;
  VAL_INT(dstval) = I2CDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_AddrRegister var here, change zero */
  I2CDevice_AddrRegister = 0;
  VAL_INT(dstval) = I2CDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_Action var here, change zero */
  I2CDevice_Action = 0;
  VAL_INT(dstval) = I2CDevice_Action;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_ActiveBit var here, change zero */
  I2CDevice_ActiveBit = 0;
  VAL_INT(dstval) = I2CDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_I2CDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_I2cAddr,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_AddrRegister,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_Action,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_I2CDevice/I2CDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_ActiveBit,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_I2CDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Register_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Register
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Register_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Register;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Register_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Register var here, change zero */
  GPIODevice_Register = 0;
  VAL_INT(dstval) = GPIODevice_Register;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Register_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Pin_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Pin
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Pin_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 GPIODevice_Pin;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Pin_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Pin var here, change zero */
  GPIODevice_Pin = 0;
  VAL_INT(dstval) = GPIODevice_Pin;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Pin_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Action var here, change TRUE if needed */
  GPIODevice_Action = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Action;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Enable_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Enable
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Enable_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  boolean GPIODevice_Enable;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Enable_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the GPIODevice_Enable var here, change TRUE if needed */
  GPIODevice_Enable = TRUE;
  VAL_BOOL(dstval) = GPIODevice_Enable;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Enable_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_GPIODevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Register */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Register,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Register_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Pin */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Pin,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Pin_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Action,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_GPIODevice/GPIODevice_Enable */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_GPIODevice_Enable,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_GPIODevice_Enable_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DeviceFan
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_FanInfo_Name,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_Type */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_FanInfo_Type,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_Type_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DeviceFan/FanInfo_FanNumber */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_FanInfo_FanNumber,
      intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FanNumber_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_FanInfo_FANDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_FANDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_FanInfo_I2CDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_I2CDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_FanInfo_GPIODevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_FanInfo_GPIODevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_Name_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PoEInfo_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PoEInfo_Name var here, change EMPTY_STRING */
  PoEInfo_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PoEInfo_Name);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_Type_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_Type
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_Type_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *PoEInfo_Type;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_Type_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the PoEInfo_Type var here, change enum */
  PoEInfo_Type = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      PoEInfo_Type);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_Type_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_I2cAddr_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_I2cAddr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_I2cAddr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_I2cAddr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_I2cAddr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_I2cAddr var here, change zero */
  I2CDevice_I2cAddr = 0;
  VAL_INT(dstval) = I2CDevice_I2cAddr;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_I2cAddr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_AddrRegister_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_AddrRegister
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_AddrRegister_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_AddrRegister;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_AddrRegister_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_AddrRegister var here, change zero */
  I2CDevice_AddrRegister = 0;
  VAL_INT(dstval) = I2CDevice_AddrRegister;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_AddrRegister_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_Action_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_Action
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_Action_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_Action;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_Action_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_Action var here, change zero */
  I2CDevice_Action = 0;
  VAL_INT(dstval) = I2CDevice_Action;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_Action_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_ActiveBit_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_ActiveBit
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_ActiveBit_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 I2CDevice_ActiveBit;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_ActiveBit_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the I2CDevice_ActiveBit var here, change zero */
  I2CDevice_ActiveBit = 0;
  VAL_INT(dstval) = I2CDevice_ActiveBit;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_ActiveBit_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_I2CDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_I2cAddr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_I2cAddr,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_I2cAddr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_AddrRegister */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_AddrRegister,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_AddrRegister_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_Action */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_Action,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_Action_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_I2CDevice/I2CDevice_ActiveBit */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_I2CDevice_ActiveBit,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_I2CDevice_ActiveBit_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Name_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Name
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Name_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *UARTDevice_Name;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Name_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the UARTDevice_Name var here, change EMPTY_STRING */
  UARTDevice_Name = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      UARTDevice_Name);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Name_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Path_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Path
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Path_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *UARTDevice_Path;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Path_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the UARTDevice_Path var here, change EMPTY_STRING */
  UARTDevice_Path = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      UARTDevice_Path);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Path_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Direction_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Direction
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Direction_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *UARTDevice_Direction;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Direction_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the UARTDevice_Direction var here, change EMPTY_STRING */
  UARTDevice_Direction = EMPTY_STRING;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      UARTDevice_Direction);

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Direction_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Bandwidth_get
 *
 * Get database object callback
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Bandwidth
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Bandwidth_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  int32 UARTDevice_Bandwidth;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Bandwidth_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the UARTDevice_Bandwidth var here, change zero */
  UARTDevice_Bandwidth = 0;
  VAL_INT(dstval) = UARTDevice_Bandwidth;

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Bandwidth_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_UartDevice
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_UARTDevice_Name,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Path */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_UARTDevice_Path,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Path_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Direction */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_UARTDevice_Direction,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Direction_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_UartDevice/UARTDevice_Bandwidth */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_UARTDevice_Bandwidth,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_UARTDevice_Bandwidth_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info/HardwareInfo_DevicePoE
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_Name */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PoEInfo_Name,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_Name_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }

  /* add /intri-device/hardware-info/HardwareInfo_DevicePoE/PoEInfo_Type */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_PoEInfo_Type,
      intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_Type_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else {
    return res;
  }
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_PoEInfo_I2CDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_I2CDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_PoEInfo_UartDevice,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_PoEInfo_UartDevice_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DeviceLed,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceLed_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DeviceHWMonitor,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceHWMonitor_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DevicePSU,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DevicePSU_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DeviceI2C,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceI2C_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DeviceHW,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceHW_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DevicePTP,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DevicePTP_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DeviceGPS,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceGPS_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DeviceToD,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceToD_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DeviceFan,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DeviceFan_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_HardwareInfo_DevicePoE,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }

  res = intri_device_intri_device_hardware_info_HardwareInfo_DevicePoE_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_hardware_info_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_mro
 *
 * Make read-only top-level node
 * Path: /intri-device
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/mac-addr */
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_mac_addr,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_device_intri_device_mac_addr_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/port-list */
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_port_list,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_device_intri_device_port_list_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/lag-port-list */
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_lag_port_list,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_device_intri_device_lag_port_list_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/poe-port-list */
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_poe_port_list,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_device_intri_device_poe_port_list_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/device-info */
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_device_info,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_device_intri_device_device_info_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/board-info */
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_board_info,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_device_intri_device_board_info_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/hardware-info */
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_hardware_info,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_device_intri_device_hardware_info_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_mro */

/********************************************************************
 * FUNCTION y_intri_device_init
 *
 * initialize the intri-device server instrumentation library
 *
 * INPUTS:
 *    modname == requested module name
 *    revision == requested version (NULL for any)
 *
 * RETURNS:
 *     error status
 ********************************************************************/
status_t y_intri_device_init(
    const xmlChar *modname,
    const xmlChar *revision) {
  status_t res = NO_ERR;
  agt_profile_t *agt_profile = agt_get_profile();

  y_intri_device_init_static_vars();

  /* change if custom handling done */
  if (xml_strcmp(modname, y_intri_device_M_intri_device)) {
    return ERR_NCX_UNKNOWN_MODULE;
  }

  if (revision && xml_strcmp(revision, y_intri_device_R_intri_device)) {
    return ERR_NCX_WRONG_VERSION;
  }
  res = ncxmod_load_module(
      y_intri_device_M_intri_device,
      y_intri_device_R_intri_device,
      &agt_profile->agt_savedevQ,
      &intri_device_mod);
  if (res != NO_ERR) {
    return res;
  }

  intri_device_obj = ncx_find_object(
      intri_device_mod,
      y_intri_device_N_intri_device);
  if (intri_device_obj == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  /* put your module initialization code here */

  return res;
} /* y_intri_device_init */

/********************************************************************
 * FUNCTION y_intri_device_init2
 *
 * SIL init phase 2: non-config data structures
 * Called after running config is loaded
 *
 * RETURNS:
 *     error status
 ********************************************************************/
status_t y_intri_device_init2(void) {
  status_t res = NO_ERR;

  /* add /intri-device */
  intri_device_val = agt_init_cache(
      y_intri_device_M_intri_device,
      y_intri_device_N_intri_device,
      &res);
  if (res != NO_ERR) {
    return res;
  }
  if (intri_device_val == NULL) {
    res = agt_add_top_container(intri_device_obj, &intri_device_val);
    if (res != NO_ERR) {
      return res;
    }
  }

  /* put your init2 code here */
  res = intri_device_intri_device_mro(intri_device_val);
  if (res != NO_ERR) {
    return res;
  }

  return res;
} /* y_intri_device_init2 */

/********************************************************************
 * FUNCTION y_intri_device_cleanup
 *    cleanup the server instrumentation library
 *
 ********************************************************************/
void y_intri_device_cleanup(void) {
  /* put your cleanup code here */

} /* y_intri_device_cleanup */

/* END intri_device.c */
