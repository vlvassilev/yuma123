
/*
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.13-0

  Combined SIL module
  module intri-device
  revision 2022-06-14
  namespace intri:intri-device
  organization Intrising Inc.

 */

#include <libxml/xmlstring.h>

#include "../../../.libintrishare/libintrishare.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "intri-device.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "procdefs.h"
#include "status.h"

/* module static variables */
static ncx_module_t *intri_device_mod;
static obj_template_t *intri_device_obj;
static val_value_t *intri_device_val;

/* put your static variables here */

/* ian: custom func */
status_t build_InterfaceIdentify(
    val_value_t *parentval,
    struct devicepb_InterfaceIdentify *ifno) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  childval = agt_make_object(
      parentval->obj,
      y_intri_device_N_InterfaceIdentify_Type,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  const xmlChar *enum_str = EMPTY_STRING;
  switch (ifno->Type) {
    case devicepb_InterfaceTypeOptions_INTERFACE_TYPE_PORT:
      enum_str = "INTERFACE_TYPE_PORT";
      childval = agt_make_int_leaf(
          parentval->obj,
          y_intri_device_N_InterfaceIdentify_DeviceID,
          ifno->DeviceID,
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      childval = agt_make_int_leaf(
          parentval->obj,
          y_intri_device_N_InterfaceIdentify_PortNo,
          ifno->PortNo,
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
    case devicepb_InterfaceTypeOptions_INTERFACE_TYPE_TRUNK:
      enum_str = "INTERFACE_TYPE_TRUNK";
      childval = agt_make_int_leaf(
          parentval->obj,
          y_intri_device_N_InterfaceIdentify_LAGNo,
          ifno->LAGNo,
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
    case devicepb_InterfaceTypeOptions_INTERFACE_TYPE_VLAN:
      enum_str = "INTERFACE_TYPE_VLAN";
      childval = agt_make_int_leaf(
          parentval->obj,
          y_intri_device_N_InterfaceIdentify_VlanID,
          ifno->VlanID,
          &res);
      if (childval != NULL) {
        val_add_child(childval, parentval);
      } else if (res != NO_ERR) {
        return SET_ERROR(res);
      }
      break;
    case devicepb_InterfaceTypeOptions_INTERFACE_TYPE_MULTICAST:
      enum_str = "INTERFACE_TYPE_MULTICAST";
      break;
  }
  res = val_set_simval_obj(
      childval,
      childval->obj,
      enum_str);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  return res;
}

status_t build_PhyInterface(
    val_value_t *parentval,
    struct devicepb_PhyInterface *phy_inf) {
  status_t res = NO_ERR;

  val_value_t *childval = NULL;

  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_PhyInterface_Interface,
      phy_inf->Interface,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  childval = agt_make_object(
      parentval->obj,
      y_intri_device_N_PhyInterface_Type,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  const xmlChar *enum_str = EMPTY_STRING;
  switch (phy_inf->Type) {
    case devicepb_PhyInterfaceTypeOptions_PHY_INTERFACE_TYPE_SMI:
      enum_str = "PHY_INTERFACE_TYPE_SMI";
      break;
    case devicepb_PhyInterfaceTypeOptions_PHY_INTERFACE_TYPE_XSMI:
      enum_str = "PHY_INTERFACE_TYPE_XSMI";
      break;
    case devicepb_PhyInterfaceTypeOptions_PHY_INTERFACE_TYPE_UNUSED:
      enum_str = "PHY_INTERFACE_TYPE_UNUSED";
      break;
  }
  res = val_set_simval_obj(
      childval,
      childval->obj,
      enum_str);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  return res;
}

status_t build_PortInfo(
    val_value_t *parentval,
    struct devicepb_PortInfo *port_info) {
  status_t res = NO_ERR;

  val_value_t *childval = NULL;

  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_PortNo,
      port_info->PortNo,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_MACChip,
      port_info->MACChip,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_MACNo,
      port_info->MACNo,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_PortGroup,
      port_info->PortGroup,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_PhyID1,
      port_info->PhyID1,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_PhyID2,
      port_info->PhyID2,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  childval = agt_make_object(
      parentval->obj,
      y_intri_device_N_PortInfo_PhyInterface,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  res = build_PhyInterface(childval, port_info->PhyInterface);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_PoENo,
      port_info->PoENo,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  for (int i = 0; i < port_info->PoEChannel_Len; i++) {
    childval = agt_make_int_leaf(
        parentval->obj,
        y_intri_device_N_PortInfo_PoEChannel,
        port_info->PoEChannel[i],
        &res);
    if (childval != NULL) {
      val_add_child(childval, parentval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }

  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_PoEChipNo,
      port_info->PoEChipNo,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_MacsecEncLen,
      port_info->MacsecEncLen,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  childval = agt_make_object(
      parentval->obj,
      y_intri_device_N_PortInfo_InterfaceType,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  const xmlChar *enum_str = EMPTY_STRING;
  switch (port_info->InterfaceType) {
    case devicepb_PortInterfaceTypeOptions_PORT_INTERFACE_TYPE_COPPER:
      enum_str = "PORT_INTERFACE_TYPE_COPPER";
      break;
    case devicepb_PortInterfaceTypeOptions_PORT_INTERFACE_TYPE_OPTICAL:
      enum_str = "PORT_INTERFACE_TYPE_OPTICAL";
      break;
  }
  res = val_set_simval_obj(
      childval,
      childval->obj,
      enum_str);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  for (int i = 0; i < port_info->Properties_Len; i++) {
    childval = agt_make_object(
        parentval->obj,
        y_intri_device_N_PortInfo_Properties,
        &res);
    if (childval != NULL) {
      val_add_child(childval, parentval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    const xmlChar *enum_str = EMPTY_STRING;
    switch (port_info->Properties[i]) {
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_10M_FULL:
        enum_str = "PORT_PROPERTIES_TYPE_10M_FULL";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_10M_HALF:
        enum_str = "PORT_PROPERTIES_TYPE_10M_HALF";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_100M_FULL:
        enum_str = "PORT_PROPERTIES_TYPE_100M_FULL";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_100M_HALF:
        enum_str = "PORT_PROPERTIES_TYPE_100M_HALF";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_1000M_FULL:
        enum_str = "PORT_PROPERTIES_TYPE_1000M_FULL";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_2500M_FULL:
        enum_str = "PORT_PROPERTIES_TYPE_2500M_FULL";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_5G_FULL:
        enum_str = "PORT_PROPERTIES_TYPE_5G_FULL";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_10G_FULL:
        enum_str = "PORT_PROPERTIES_TYPE_10G_FULL";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_25G_FULL:
        enum_str = "PORT_PROPERTIES_TYPE_25G_FULL";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_RJ45:
        enum_str = "PORT_PROPERTIES_TYPE_RJ45";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_SFP:
        enum_str = "PORT_PROPERTIES_TYPE_SFP";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_POE:
        enum_str = "PORT_PROPERTIES_TYPE_POE";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_POE_PLUS:
        enum_str = "PORT_PROPERTIES_TYPE_POE_PLUS";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_POE_PLUS_PLUS:
        enum_str = "PORT_PROPERTIES_TYPE_POE_PLUS_PLUS";
        break;
      case devicepb_PortPropertyTypeOptions_PORT_PROPERTIES_TYPE_LINK_PORT:
        enum_str = "PORT_PROPERTIES_TYPE_LINK_PORT";
        break;
    }
    res = val_set_simval_obj(
        childval,
        childval->obj,
        enum_str);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }

  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_PortInfo_DeviceID,
      port_info->DeviceID,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  for (int i = 0; i < port_info->SpeedProperties_Len; i++) {
    childval = agt_make_object(
        parentval->obj,
        y_intri_device_N_PortInfo_SpeedProperties,
        &res);
    if (childval != NULL) {
      val_add_child(childval, parentval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    const xmlChar *enum_str = EMPTY_STRING;
    switch (port_info->SpeedProperties[i]) {
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_AUTO:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_AUTO";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_10M_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_10M_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_10M_HALF:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_10M_HALF";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_100M_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_100M_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_100M_HALF:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_100M_HALF";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_1000M_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_1000M_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_2500M_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_2500M_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_5G_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_5G_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_10G_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_10G_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_25G_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_25G_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_40G_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_40G_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_100G_FULL:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_100G_FULL";
        break;
      case devicepb_DevicePortSpeedDuplexTypeOptions_DEVICE_PORT_SPEED_DUPLEX_TYPE_NA:
        enum_str = "DEVICE_PORT_SPEED_DUPLEX_TYPE_NA";
        break;
    }
    res = val_set_simval_obj(
        childval,
        childval->obj,
        enum_str);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }

  return res;
}

status_t build_HardwareTableSize(
    val_value_t *parentval,
    struct devicepb_HardwareTableSize *hw_tb_size) {
  status_t res = NO_ERR;

  val_value_t *childval = NULL;

  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_ARPTableEntries,
      hw_tb_size->ARPTableEntries,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_BridgeFDBEntries,
      hw_tb_size->BridgeFDBEntries,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_CentralizedCounters,
      hw_tb_size->CentralizedCounters,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_L2L3PortIsolation,
      hw_tb_size->L2L3PortIsolation,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_MulticastLinkedListEntries,
      hw_tb_size->MulticastLinkedListEntries,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_MulticastPhysicalPortGroups,
      hw_tb_size->MulticastPhysicalPortGroups,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_QoSProfiles,
      hw_tb_size->QoSProfiles,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_RouterIPv4HostEntries,
      hw_tb_size->RouterIPv4HostEntries,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_RouterIPv6HostEntries,
      hw_tb_size->RouterIPv6HostEntries,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_RouterNextHopEntries,
      hw_tb_size->RouterNextHopEntries,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_SpanningTreeGroups,
      hw_tb_size->SpanningTreeGroups,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_TcamSize,
      hw_tb_size->TcamSize,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_VirtualBridgeDomains,
      hw_tb_size->VirtualBridgeDomains,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_HardwareTableSize_VirtualPorts,
      hw_tb_size->VirtualPorts,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  return res;
}

status_t build_LedInfo(
    val_value_t *parentval,
    struct devicepb_LedInfo *led_info) {
  status_t res = NO_ERR;

  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;

  childval = agt_make_leaf(
      parentval->obj,
      y_intri_device_N_LedInfo_Name,
      led_info->Name,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_LedInfo_PortNo,
      led_info->PortNo,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  childval = agt_make_object(
      parentval->obj,
      y_intri_device_N_LedInfo_Type,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  switch (led_info->Type) {
    case devicepb_DeviceTypeOptions_DEVICE_TYPE_MCU:
      enum_str = "DEVICE_TYPE_MCU";
      break;
    case devicepb_DeviceTypeOptions_DEVICE_TYPE_I2C:
      enum_str = "DEVICE_TYPE_I2C";
      break;
    case devicepb_DeviceTypeOptions_DEVICE_TYPE_GPIO:
      enum_str = "DEVICE_TYPE_GPIO";
      break;
  }
  res = val_set_simval_obj(
      childval,
      childval->obj,
      enum_str);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  childval = agt_make_int_leaf(
      parentval->obj,
      y_intri_device_N_LedInfo_Direction,
      led_info->Direction,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  switch (led_info->Device_Union_Option) {
    case devicepb_LedInfo_Device_Union_Options_LEDDevice:
      childval = agt_make_object(
          parentval->obj,
          y_intri_device_N_LedInfo_LEDDevice,
          &res);
      // led_info->Device.Device_LEDDevice;
    case devicepb_LedInfo_Device_Union_Options_I2CDevice:
      childval = agt_make_object(
          parentval->obj,
          y_intri_device_N_LedInfo_I2CDevice,
          &res);
    // led_info->Device.Device_I2CDevice;
    case devicepb_LedInfo_Device_Union_Options_GPIODevice:
      childval = agt_make_object(
          parentval->obj,
          y_intri_device_N_LedInfo_GPIODevice,
          &res);
      // led_info->Device.Device_GPIODevice;
  }

  return res;
}

status_t build_HardwareInfo(
    val_value_t *parentval,
    struct devicepb_HardwareInfo *hw_info) {
  status_t res = NO_ERR;

  val_value_t *childval = NULL;

  childval = agt_make_object(
      parentval->obj,
      y_intri_device_N_HardwareInfo_DeviceLed,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < hw_info->DeviceLed_Len; i++) {
    val_value_t *entry_val = NULL;
    entry_val = agt_make_list(
        child_val->obj,
        y_intri_device_N_Entry,
        &res);
    if (entry_val != NULL) {
      val_add_child(entry_val, child_val);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }

  // childval = agt_make_object(
  //     parentval->obj,
  //     y_intri_device_N_HardwareInfo_DeviceHWMonitor,
  //     &res);
  // if (childval != NULL) {
  //   val_add_child(childval, parentval);
  // } else if (res != NO_ERR) {
  //   return SET_ERROR(res);
  // }
  // childval = agt_make_object(
  //     parentval->obj,
  //     y_intri_device_N_HardwareInfo_DevicePSU,
  //     &res);
  // if (childval != NULL) {
  //   val_add_child(childval, parentval);
  // } else if (res != NO_ERR) {
  //   return SET_ERROR(res);
  // }
  // childval = agt_make_object(
  //     parentval->obj,
  //     y_intri_device_N_HardwareInfo_DeviceI2C,
  //     &res);
  // if (childval != NULL) {
  //   val_add_child(childval, parentval);
  // } else if (res != NO_ERR) {
  //   return SET_ERROR(res);
  // }
  // childval = agt_make_object(
  //     parentval->obj,
  //     y_intri_device_N_HardwareInfo_DeviceHW,
  //     &res);
  // if (childval != NULL) {
  //   val_add_child(childval, parentval);
  // } else if (res != NO_ERR) {
  //   return SET_ERROR(res);
  // }
  // childval = agt_make_object(
  //     parentval->obj,
  //     y_intri_device_N_HardwareInfo_DevicePTP,
  //     &res);
  // if (childval != NULL) {
  //   val_add_child(childval, parentval);
  // } else if (res != NO_ERR) {
  //   return SET_ERROR(res);
  // }
  // childval = agt_make_object(
  //     parentval->obj,
  //     y_intri_device_N_HardwareInfo_DeviceGPS,
  //     &res);
  // if (childval != NULL) {
  //   val_add_child(childval, parentval);
  // } else if (res != NO_ERR) {
  //   return SET_ERROR(res);
  // }
  // childval = agt_make_object(
  //     parentval->obj,
  //     y_intri_device_N_HardwareInfo_DeviceToD,
  //     &res);
  // if (childval != NULL) {
  //   val_add_child(childval, parentval);
  // } else if (res != NO_ERR) {
  //   return SET_ERROR(res);
  // }
  // childval = agt_make_object(
  //     parentval->obj,
  //     y_intri_device_N_HardwareInfo_DeviceFan,
  //     &res);
  // if (childval != NULL) {
  //   val_add_child(childval, parentval);
  // } else if (res != NO_ERR) {
  //   return SET_ERROR(res);
  // }
  // childval = agt_make_object(
  //     parentval->obj,
  //     y_intri_device_N_HardwareInfo_DevicePoE,
  //     &res);
  // if (childval != NULL) {
  //   val_add_child(childval, parentval);
  // } else if (res != NO_ERR) {
  //   return SET_ERROR(res);
  // }

  // for (int i = 0; i < hw_info->DeviceHWMonitor_Len; i++) {
  // }
  // for (int i = 0; i < hw_info->DevicePSU_Len; i++) {
  // }
  // for (int i = 0; i < hw_info->DeviceI2C_Len; i++) {
  // }
  // for (int i = 0; i < hw_info->DeviceHW_Len; i++) {
  // }
  // for (int i = 0; i < hw_info->DevicePTP_Len; i++) {
  // }
  // for (int i = 0; i < hw_info->DeviceGPS_Len; i++) {
  // }
  // for (int i = 0; i < hw_info->DeviceToD_Len; i++) {
  // }
  // for (int i = 0; i < hw_info->DeviceFan_Len; i++) {
  // }
  // for (int i = 0; i < hw_info->DevicePoE_Len; i++) {
  // }

  return res;
}

/********************************************************************
 * FUNCTION y_intri_device_init_static_vars
 *
 * initialize module static variables
 *
 ********************************************************************/
static void y_intri_device_init_static_vars(void) {
  intri_device_mod = NULL;
  intri_device_obj = NULL;

  /* init your static variables here */

} /* y_intri_device_init_static_vars */

/********************************************************************
 * FUNCTION intri_device_intri_device_mac_addr_mac_addr_get
 *
 * Get database object callback
 * Path: /intri-device/mac-addr/mac-addr
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t intri_device_intri_device_mac_addr_mac_addr_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;
  const xmlChar *mac_addr;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_mac_addr_mac_addr_get callback");
  }

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if virval is used */
  (void)virval;

  if (cbmode != GETCB_GET_VALUE) {
    return ERR_NCX_OPERATION_NOT_SUPPORTED;
  }

  /* set the mac_addr var here, change EMPTY_STRING */
  struct emptypb_Empty in;
  struct commonpb_MACAddress out;
  device_Device_GetMACAddress(&in, &out);
  mac_addr = out.MACAddr;
  res = val_set_simval_obj(
      dstval,
      dstval->obj,
      mac_addr);

  return res;

} /* intri_device_intri_device_mac_addr_mac_addr_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_mac_addr_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/mac-addr
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_mac_addr_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/mac-addr/mac-addr */
  childval = agt_make_virtual_leaf(
      parentval->obj,
      y_intri_device_N_mac_addr,
      intri_device_intri_device_mac_addr_mac_addr_get,
      &res);
  if (childval != NULL) {
    val_add_child(childval, parentval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  return res;

} /* intri_device_intri_device_mac_addr_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_port_list_get
 *
 * Get database object callback
 * Path: /intri-device/port-list
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_port_list_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_port_list_get");
  }

  /* calls the private api */
  struct emptypb_Empty in;
  struct devicepb_PortList out;
  device_Device_GetPortLists(&in, &out);

  for (int i = 0; i < out.List_Len; i++) {
    val_value_t *entry_val = NULL;

    /* add /intri-device/port-list/Entry */
    entry_val = agt_make_list(
        dstval->obj,
        y_intri_device_N_Entry,
        &res);
    if (entry_val != NULL) {
      val_add_child(entry_val, dstval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }

    res = build_InterfaceIdentify(
        entry_val,
        out.List[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }

  return res;
} /* intri_device_intri_device_port_list_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_port_list_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/port-list
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_port_list_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* init /intri-device/port-list */
  val_init_virtual(
      parentval,
      intri_device_intri_device_port_list_get,
      parentval->obj);

  return res;

} /* intri_device_intri_device_port_list_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_lag_port_list_get
 *
 * Get database object callback
 * Path: /intri-device/lag-port-list
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_lag_port_list_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_lag_port_list_get");
  }

  /* calls the private api */
  struct emptypb_Empty in;
  struct devicepb_PortList out;
  device_Device_GetLAGPortLists(&in, &out);

  for (int i = 0; i < out.List_Len; i++) {
    val_value_t *entry_val = NULL;

    /* add /intri-device/lag-port-list/Entry */
    entry_val = agt_make_list(
        dstval->obj,
        y_intri_device_N_Entry,
        &res);
    if (entry_val != NULL) {
      val_add_child(entry_val, dstval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }

    res = build_InterfaceIdentify(
        entry_val,
        out.List[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }

  return res;
} /* intri_device_intri_device_lag_port_list_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_lag_port_list_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/lag-port-list
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_lag_port_list_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* init /intri-device/lag-port-list */
  val_init_virtual(
      parentval,
      intri_device_intri_device_lag_port_list_get,
      parentval->obj);

  return res;

} /* intri_device_intri_device_lag_port_list_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_poe_port_list_get
 *
 * Get database object callback
 * Path: /intri-device/poe-port-list
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_poe_port_list_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_poe_port_list_get");
  }

  /* calls the private api */
  struct emptypb_Empty in;
  struct devicepb_PortList out;
  device_Device_GetPoEPortLists(&in, &out);

  for (int i = 0; i < out.List_Len; i++) {
    val_value_t *entry_val = NULL;

    /* add /intri-device/poe-port-list/Entry */
    entry_val = agt_make_list(
        dstval->obj,
        y_intri_device_N_Entry,
        &res);
    if (entry_val != NULL) {
      val_add_child(entry_val, dstval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }

    res = build_InterfaceIdentify(
        entry_val,
        out.List[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }

  return res;
} /* intri_device_intri_device_poe_port_list_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_poe_port_list_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/poe-port-list
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_poe_port_list_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* init /intri-device/poe-port-list */
  val_init_virtual(
      parentval,
      intri_device_intri_device_poe_port_list_get,
      parentval->obj);

  return res;

} /* intri_device_intri_device_poe_port_list_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_device_info_get
 *
 * Get database object callback
 * Path: /intri-device/device-info
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_device_info_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_device_info_get");
  }

  /* calls the private api */
  struct emptypb_Empty in;
  struct devicepb_Info out;
  device_Device_GetDeviceInfo(&in, &out);

  struct devicepb_Info *device_info = &out;
  val_value_t *child_val;

  /* add /intri-device/device-info/Info_AltBuildDateTime */
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_AltBuildDateTime,
      device_info->AltBuildDateTime,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  /* add /intri-device/device-info/Info_AltSwVersion */
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_AltSwVersion,
      device_info->AltSwVersion,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  /* add /intri-device/device-info/Info_Board */
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_Board,
      device_info->Board,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  /* add /intri-device/device-info/Info_CurrentBuildDateTime */
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_CurrentBuildDateTime,
      device_info->CurrentBuildDateTime,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  /* add /intri-device/device-info/Info_CurrentImage */
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_CurrentImage,
      device_info->CurrentImage,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  /* add /intri-device/device-info/Info_CurrentSwVersion */
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_CurrentSwVersion,
      device_info->CurrentSwVersion,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  /* add /intri-device/device-info/Info_HwVersion */
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_HwVersion,
      device_info->HwVersion,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  /* add /intri-device/device-info/Info_MACAddr */
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_MACAddr,
      device_info->MACAddr,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  /* add /intri-device/device-info/Info_MACAddrFactory */
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_MACAddrFactory,
      device_info->MACAddrFactory,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  /* add /intri-device/device-info/Info_Model */
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_Model,
      device_info->Model,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  /* add /intri-device/device-info/Info_SerialNo */
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_SerialNo,
      device_info->SerialNo,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  /* add /intri-device/device-info/Info_Vendor */
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_Info_Vendor,
      device_info->Vendor,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  /* add /intri-device/device-info/Info_Layer */
  child_val = agt_make_object(
      dstval->obj,
      y_intri_device_N_Info_Layer,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  const xmlChar *enum_str = EMPTY_STRING;
  switch (device_info->Layer) {
    case devicepb_LayerTypeOptions_LAYER_TYPE_L2:
      enum_str = "LAYER_TYPE_L2";
      break;
    case devicepb_LayerTypeOptions_LAYER_TYPE_L3:
      enum_str = "LAYER_TYPE_L3";
      break;
  }
  res = val_set_simval_obj(
      child_val,
      child_val->obj,
      enum_str);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  return res;
} /* intri_device_intri_device_device_info_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_device_info_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/device-info
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_device_info_mro(val_value_t *parentval) {
  status_t res = NO_ERR;

  /* init /intri-device/device-info */
  val_init_virtual(
      parentval,
      intri_device_intri_device_device_info_get,
      parentval->obj);

  return res;

} /* intri_device_intri_device_device_info_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_get
 *
 * Get database object callback
 * Path: /intri-device/board-info
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_board_info_get");
  }

  /* calls the private api */
  struct emptypb_Empty in;
  struct devicepb_BoardInfo out;
  device_Device_GetBoardInfo(&in, &out);

  struct devicepb_BoardInfo *board_info = &out;
  val_value_t *child_val;

  /* add /intri-device/board-info/BoardInfo_SystemDescription */
  child_val = agt_make_leaf(
      dstval->obj,
      y_intri_device_N_BoardInfo_SystemDescription,
      board_info->SystemDescription,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  /* add /intri-device/board-info/BoardInfo_PortLists */
  child_val = agt_make_object(
      dstval->obj,
      y_intri_device_N_BoardInfo_PortLists,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  for (int i = 0; i < board_info->PortLists_Len; i++) {
    val_value_t *entry_val = NULL;

    /* add /intri-device/board-info/BoardInfo_PortLists/Entry */
    entry_val = agt_make_list(
        child_val->obj,
        y_intri_device_N_Entry,
        &res);
    if (entry_val != NULL) {
      val_add_child(entry_val, child_val);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }

    res = build_PortInfo(entry_val, board_info->PortLists[i]);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }

  /* add /intri-device/board-info/BoardInfo_HwFeature */
  for (int i = 0; i < board_info->HwFeatures_Len; i++) {
    child_val = agt_make_object(
        dstval->obj,
        y_intri_device_N_BoardInfo_HwFeatures,
        &res);
    if (child_val != NULL) {
      val_add_child(child_val, dstval);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    const xmlChar *enum_str = EMPTY_STRING;
    switch (board_info->HwFeatures[i]) {
      case devicepb_FactoryHwFeatureTypeOptions_FACTORY_HW_FEATURE_TYPE_POE_PLUS_PLUS:
        enum_str = "FACTORY_HW_FEATURE_TYPE_POE_PLUS_PLUS";
        break;
      case devicepb_FactoryHwFeatureTypeOptions_FACTORY_HW_FEATURE_TYPE_POE_PLUS:
        enum_str = "FACTORY_HW_FEATURE_TYPE_POE_PLUS";
        break;
      case devicepb_FactoryHwFeatureTypeOptions_FACTORY_HW_FEATURE_TYPE_EEE:
        enum_str = "FACTORY_HW_FEATURE_TYPE_EEE";
        break;
      case devicepb_FactoryHwFeatureTypeOptions_FACTORY_HW_FEATURE_TYPE_RTC:
        enum_str = "FACTORY_HW_FEATURE_TYPE_RTC";
        break;
      case devicepb_FactoryHwFeatureTypeOptions_FACTORY_HW_FEATURE_TYPE_SFP:
        enum_str = "FACTORY_HW_FEATURE_TYPE_SFP";
        break;
    }
    res = val_set_simval_obj(
        child_val,
        child_val->obj,
        enum_str);
    if (res != NO_ERR) {
      return SET_ERROR(res);
    }
  }

  /* add /intri-device/board-info/BoardInfo_HwSize */
  child_val = agt_make_object(
      dstval->obj,
      y_intri_device_N_BoardInfo_HwSize,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  res = build_HardwareTableSize(
      child_val,
      board_info->HwSize);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  /* add /intri-device/board-info/BoardInfo_CPUPort */
  child_val = agt_make_int_leaf(
      dstval->obj,
      y_intri_device_N_BoardInfo_CPUPort,
      board_info->CPUPort & res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  /* add /intri-device/board-info/BoardInfo_BoardDevice */
  child_val = agt_make_object(
      dstval->obj,
      y_intri_device_N_BoardInfo_BoardDevice,
      &res);
  if (child_val != NULL) {
    val_add_child(child_val, dstval);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  res = build_HardwareInfo(
      child_val,
      board_info->BoardDevice);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  return res;
} /* intri_device_intri_device_board_info_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_board_info_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/board-info
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_board_info_mro(val_value_t *parentval) {
  status_t res = NO_ERR;

  /* init /intri-device/board-info */
  val_init_virtual(
      parentval,
      intri_device_intri_device_board_info_get,
      parentval->obj);

  return res;

} /* intri_device_intri_device_board_info_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_get
 *
 * Get database object callback
 * Path: /intri-device/board-info
 * Fill in 'dstval' contents
 *
 * INPUTS:
 *     see ncx/getcb.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_get(
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval) {
  status_t res = NO_ERR;

  if (LOGDEBUG) {
    log_debug("\nEnter intri_device_intri_device_hardware_info_get");
  }

  /* calls the private api */
  struct emptypb_Empty in;
  struct devicepb_HardwareInfo out;
  device_Device_GetHardwareInfo(&in, &out);

  // res = build_HardwareInfo(dstval, &out);
  // if (res != NO_ERR) {
  //   return SET_ERROR(res);
  // }

  return res;
} /* intri_device_intri_device_hardware_info_get */

/********************************************************************
 * FUNCTION intri_device_intri_device_hardware_info_mro
 *
 * Make read-only child nodes
 * Path: /intri-device/hardware-info
 *
 * INPUTS:
 *     parentval == the parent struct to use for new child nodes
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_hardware_info_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  return res;

} /* intri_device_intri_device_hardware_info_mro */

/********************************************************************
 * FUNCTION intri_device_intri_device_mro
 *
 * Make read-only top-level node
 * Path: /intri-device
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t
intri_device_intri_device_mro(val_value_t *parentval) {
  status_t res = NO_ERR;
  val_value_t *childval = NULL;

  /* add /intri-device/mac-addr */
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_mac_addr,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_device_intri_device_mac_addr_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/port-list */
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_port_list,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_device_intri_device_port_list_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/lag-port-list */
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_lag_port_list,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_device_intri_device_lag_port_list_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/poe-port-list */
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_poe_port_list,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_device_intri_device_poe_port_list_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/device-info */
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_device_info,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_device_intri_device_device_info_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/board-info */
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_board_info,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_device_intri_device_board_info_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  /* add /intri-device/hardware-info */
  res = agt_add_container(
      y_intri_device_M_intri_device,
      y_intri_device_N_hardware_info,
      parentval,
      &childval);
  if (res != NO_ERR) {
    return res;
  }
  res = intri_device_intri_device_hardware_info_mro(childval);
  if (res != NO_ERR) {
    return res;
  }

  return res;

} /* intri_device_intri_device_mro */

/********************************************************************
 * FUNCTION y_intri_device_init
 *
 * initialize the intri-device server instrumentation library
 *
 * INPUTS:
 *    modname == requested module name
 *    revision == requested version (NULL for any)
 *
 * RETURNS:
 *     error status
 ********************************************************************/
status_t y_intri_device_init(
    const xmlChar *modname,
    const xmlChar *revision) {
  status_t res = NO_ERR;
  agt_profile_t *agt_profile = agt_get_profile();

  y_intri_device_init_static_vars();

  /* change if custom handling done */
  if (xml_strcmp(modname, y_intri_device_M_intri_device)) {
    return ERR_NCX_UNKNOWN_MODULE;
  }

  if (revision && xml_strcmp(revision, y_intri_device_R_intri_device)) {
    return ERR_NCX_WRONG_VERSION;
  }
  res = ncxmod_load_module(
      y_intri_device_M_intri_device,
      y_intri_device_R_intri_device,
      &agt_profile->agt_savedevQ,
      &intri_device_mod);
  if (res != NO_ERR) {
    return res;
  }

  intri_device_obj = ncx_find_object(
      intri_device_mod,
      y_intri_device_N_intri_device);
  if (intri_device_obj == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  /* put your module initialization code here */

  return res;
} /* y_intri_device_init */

/********************************************************************
 * FUNCTION y_intri_device_init2
 *
 * SIL init phase 2: non-config data structures
 * Called after running config is loaded
 *
 * RETURNS:
 *     error status
 ********************************************************************/
status_t y_intri_device_init2(void) {
  status_t res = NO_ERR;

  /* add /intri-device */
  intri_device_val = agt_init_cache(
      y_intri_device_M_intri_device,
      y_intri_device_N_intri_device,
      &res);
  if (res != NO_ERR) {
    return res;
  }
  if (intri_device_val == NULL) {
    res = agt_add_top_container(intri_device_obj, &intri_device_val);
    if (res != NO_ERR) {
      return res;
    }
  }

  /* put your init2 code here */
  res = intri_device_intri_device_mro(intri_device_val);
  if (res != NO_ERR) {
    return res;
  }

  return res;
} /* y_intri_device_init2 */

/********************************************************************
 * FUNCTION y_intri_device_cleanup
 *    cleanup the server instrumentation library
 *
 ********************************************************************/
void y_intri_device_cleanup(void) {
  /* put your cleanup code here */

} /* y_intri_device_cleanup */

/* END intri_device.c */
