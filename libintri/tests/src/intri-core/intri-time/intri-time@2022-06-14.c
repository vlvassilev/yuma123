
/*
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.13-0

  Combined SIL module
  module intri-time
  revision 2022-06-14
  namespace intri:intri-time
  organization Intrising Inc.

 */

#include <libxml/xmlstring.h>

#include "../../../../.libintrishare/libintrishare.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "intri-time.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "procdefs.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"

/* module static variables */
static ncx_module_t *intri_time_mod;
static obj_template_t *intri_time_get_config_obj;
static obj_template_t *intri_time_set_config_obj;
static obj_template_t *intri_time_get_status_obj;
static obj_template_t *intri_time_run_sync_now_obj;
static obj_template_t *intri_time_run_list_timezone_obj;
static obj_template_t *intri_time_get_correction_time_obj;
static obj_template_t *intri_time_get_correction_time_with_int64_obj;
static obj_template_t *intri_time_get_utc_obj;

/* put your static variables here */

/* ian: custom func */

/********************************************************************
 * FUNCTION y_intri_time_init_static_vars
 *
 * initialize module static variables
 *
 ********************************************************************/
static void y_intri_time_init_static_vars(void) {
  intri_time_mod = NULL;
  intri_time_get_config_obj = NULL;
  intri_time_set_config_obj = NULL;
  intri_time_get_status_obj = NULL;
  intri_time_run_sync_now_obj = NULL;
  intri_time_run_list_timezone_obj = NULL;
  intri_time_get_correction_time_obj = NULL;
  intri_time_get_correction_time_with_int64_obj = NULL;
  intri_time_get_utc_obj = NULL;

  /* init your static variables here */

} /* y_intri_time_init_static_vars */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_get_config_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_get_config_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_time_intri_time_get_config_validate */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_get_config_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_get_config_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  struct emptypb_Empty in;
  struct timepb_Config out;
  time_Time_GetConfig(&in, &out);

  val_value_t *msg_val = val_new_value();
  val_init_from_template(msg_val, intri_time_get_config_obj);

  val_value_t *res_val = NULL;
  res_val = agt_make_object(
      msg_val->obj,
      "output",
      &res);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  obj_template_t *cfg_obj = res_val->obj;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;

  childval = agt_make_object(
      cfg_obj,
      y_intri_time_N_Config_Mode,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  switch (out.Mode) {
    case timepb_ModeTypeOptions_MODE_TYPE_MANUAL:
      enum_str = "MODE_TYPE_MANUAL";
      break;
    case timepb_ModeTypeOptions_MODE_TYPE_AUTO:
      enum_str = "MODE_TYPE_AUTO";
      break;
    case timepb_ModeTypeOptions_MODE_TYPE_GNSS:
      enum_str = "MODE_TYPE_GNSS";
      break;
    case timepb_ModeTypeOptions_MODE_TYPE_PTP:
      enum_str = "MODE_TYPE_PTP";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;

  childval = agt_make_object(
      cfg_obj,
      y_intri_time_N_Config_MainNTPServer,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  VAL_STRING(childval) = out.MainNTPServer;

  childval = agt_make_object(
      cfg_obj,
      y_intri_time_N_Config_BackupNTPServer,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  VAL_STRING(childval) = out.BackupNTPServer;

  childval = agt_make_object(
      cfg_obj,
      y_intri_time_N_Config_TrustedServerEnabled,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  VAL_BOOL(childval) = out.TrustedServerEnabled;

  childval = agt_make_object(
      cfg_obj,
      y_intri_time_N_Config_SyncInterval,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  VAL_INT32(childval) = out.SyncInterval;

  childval = agt_make_object(
      cfg_obj,
      y_intri_time_N_Config_TimeZone,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  VAL_STRING(childval) = out.TimeZone;

  childval = agt_make_object(
      cfg_obj,
      y_intri_time_N_Config_TimeFormat,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  VAL_STRING(childval) = out.TimeFormat;

  childval = agt_make_object(
      cfg_obj,
      y_intri_time_N_Config_DateFormat,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  VAL_STRING(childval) = out.DateFormat;

  childval = agt_make_object(
      cfg_obj,
      y_intri_time_N_Config_Manual,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  VAL_STRING(childval) = out.Manual;

  return res;

} /* y_intri_time_intri_time_get_config_invoke */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_set_config_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_set_config_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *Config_Mode_val;
  const xmlChar *Config_Mode;
  val_value_t *Config_MainNTPServer_val;
  const xmlChar *Config_MainNTPServer;
  val_value_t *Config_BackupNTPServer_val;
  const xmlChar *Config_BackupNTPServer;
  val_value_t *Config_TrustedServerEnabled_val;
  boolean Config_TrustedServerEnabled;
  val_value_t *Config_SyncInterval_val;
  int32 Config_SyncInterval;
  val_value_t *Config_TimeZone_val;
  const xmlChar *Config_TimeZone;
  val_value_t *Config_TimeFormat_val;
  const xmlChar *Config_TimeFormat;
  val_value_t *Config_DateFormat_val;
  const xmlChar *Config_DateFormat;
  val_value_t *Config_Manual_val;
  const xmlChar *Config_Manual;

  Config_Mode_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_Mode);
  if (Config_Mode_val != NULL && Config_Mode_val->res == NO_ERR) {
    Config_Mode = VAL_ENUM_NAME(Config_Mode_val);
  }

  Config_MainNTPServer_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_MainNTPServer);
  if (Config_MainNTPServer_val != NULL && Config_MainNTPServer_val->res == NO_ERR) {
    Config_MainNTPServer = VAL_STRING(Config_MainNTPServer_val);
  }

  Config_BackupNTPServer_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_BackupNTPServer);
  if (Config_BackupNTPServer_val != NULL && Config_BackupNTPServer_val->res == NO_ERR) {
    Config_BackupNTPServer = VAL_STRING(Config_BackupNTPServer_val);
  }

  Config_TrustedServerEnabled_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_TrustedServerEnabled);
  if (Config_TrustedServerEnabled_val != NULL && Config_TrustedServerEnabled_val->res == NO_ERR) {
    Config_TrustedServerEnabled = VAL_BOOL(Config_TrustedServerEnabled_val);
  }

  Config_SyncInterval_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_SyncInterval);
  if (Config_SyncInterval_val != NULL && Config_SyncInterval_val->res == NO_ERR) {
    Config_SyncInterval = VAL_INT(Config_SyncInterval_val);
  }

  Config_TimeZone_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_TimeZone);
  if (Config_TimeZone_val != NULL && Config_TimeZone_val->res == NO_ERR) {
    Config_TimeZone = VAL_STRING(Config_TimeZone_val);
  }

  Config_TimeFormat_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_TimeFormat);
  if (Config_TimeFormat_val != NULL && Config_TimeFormat_val->res == NO_ERR) {
    Config_TimeFormat = VAL_STRING(Config_TimeFormat_val);
  }

  Config_DateFormat_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_DateFormat);
  if (Config_DateFormat_val != NULL && Config_DateFormat_val->res == NO_ERR) {
    Config_DateFormat = VAL_STRING(Config_DateFormat_val);
  }

  Config_Manual_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_Manual);
  if (Config_Manual_val != NULL && Config_Manual_val->res == NO_ERR) {
    Config_Manual = VAL_STRING(Config_Manual_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_time_intri_time_set_config_validate */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_set_config_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_set_config_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *Config_Mode_val;
  val_value_t *Config_MainNTPServer_val;
  val_value_t *Config_BackupNTPServer_val;
  val_value_t *Config_TrustedServerEnabled_val;
  val_value_t *Config_SyncInterval_val;
  val_value_t *Config_TimeZone_val;
  val_value_t *Config_TimeFormat_val;
  val_value_t *Config_DateFormat_val;
  val_value_t *Config_Manual_val;

  struct emptypb_Empty epty;
  struct timepb_Config cfg;
  time_Time_GetConfig(&epty, &cfg);

  Config_Mode_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_Mode);
  if (Config_Mode_val != NULL && Config_Mode_val->res == NO_ERR) {
    cfg.Mode = VAL_ENUM(Config_Mode_val);
  }

  Config_MainNTPServer_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_MainNTPServer);
  if (Config_MainNTPServer_val != NULL && Config_MainNTPServer_val->res == NO_ERR) {
    cfg.MainNTPServer = VAL_STRING(Config_MainNTPServer_val);
  }

  Config_BackupNTPServer_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_BackupNTPServer);
  if (Config_BackupNTPServer_val != NULL && Config_BackupNTPServer_val->res == NO_ERR) {
    cfg.BackupNTPServer = VAL_STRING(Config_BackupNTPServer_val);
  }

  Config_TrustedServerEnabled_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_TrustedServerEnabled);
  if (Config_TrustedServerEnabled_val != NULL && Config_TrustedServerEnabled_val->res == NO_ERR) {
    cfg.TrustedServerEnabled = VAL_BOOL(Config_TrustedServerEnabled_val);
  }

  Config_SyncInterval_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_SyncInterval);
  if (Config_SyncInterval_val != NULL && Config_SyncInterval_val->res == NO_ERR) {
    cfg.SyncInterval = VAL_INT(Config_SyncInterval_val);
  }

  Config_TimeZone_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_TimeZone);
  if (Config_TimeZone_val != NULL && Config_TimeZone_val->res == NO_ERR) {
    cfg.TimeZone = VAL_STRING(Config_TimeZone_val);
  }

  Config_TimeFormat_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_TimeFormat);
  if (Config_TimeFormat_val != NULL && Config_TimeFormat_val->res == NO_ERR) {
    cfg.TimeFormat = VAL_STRING(Config_TimeFormat_val);
  }

  Config_DateFormat_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_DateFormat);
  if (Config_DateFormat_val != NULL && Config_DateFormat_val->res == NO_ERR) {
    cfg.DateFormat = VAL_STRING(Config_DateFormat_val);
  }

  Config_Manual_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_Config_Manual);
  if (Config_Manual_val != NULL && Config_Manual_val->res == NO_ERR) {
    cfg.Manual = VAL_STRING(Config_Manual_val);
  }

  time_Time_SetConfig(&cfg, &epty);

  /* remove the next line if scb is used */
  (void)scb;

  /* remove the next line if methnode is used */
  (void)methnode;

  /* invoke your device instrumentation code here */

  return res;

} /* y_intri_time_intri_time_set_config_invoke */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_get_status_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_get_status_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_time_intri_time_get_status_validate */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_get_status_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_get_status_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  struct emptypb_Empty in;
  struct timepb_Status out;
  time_Time_GetStatus(&in, &out);

  val_value_t *msg_val = val_new_value();
  val_init_from_template(msg_val, intri_time_get_status_obj);

  val_value_t *res_val = NULL;
  res_val = agt_make_object(
      msg_val->obj,
      "output",
      &res);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  obj_template_t *cfg_obj = res_val->obj;
  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;

  childval = agt_make_object(
      cfg_obj,
      y_intri_time_N_Status_Status,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  switch (out.Status) {
    case timepb_StatusTypeOptions_STATUS_TYPE_UNSET:
      enum_str = "STATUS_TYPE_UNSET";
      break;
    case timepb_StatusTypeOptions_STATUS_TYPE_MANUALLY_SET:
      enum_str = "STATUS_TYPE_MANUALLY_SET";
      break;
    case timepb_StatusTypeOptions_STATUS_TYPE_SYNCHRONIZED:
      enum_str = "STATUS_TYPE_SYNCHRONIZED";
      break;
    case timepb_StatusTypeOptions_STATUS_TYPE_SYNC_FAILED:
      enum_str = "STATUS_TYPE_SYNC_FAILED";
      break;
    case timepb_StatusTypeOptions_STATUS_TYPE_DAY_LIGHT_SAVING_TIME:
      enum_str = "STATUS_TYPE_DAY_LIGHT_SAVING_TIME";
      break;
    case timepb_StatusTypeOptions_STATUS_TYPE_GNSS_SET:
      enum_str = "STATUS_TYPE_GNSS_SET";
      break;
    case timepb_StatusTypeOptions_STATUS_TYPE_GNSS_FAILED:
      enum_str = "STATUS_TYPE_GNSS_FAILED";
      break;
    case timepb_StatusTypeOptions_STATUS_TYPE_PTP_SET:
      enum_str = "STATUS_TYPE_PTP_SET";
      break;
    case timepb_StatusTypeOptions_STATUS_TYPE_PTP_FAILED:
      enum_str = "STATUS_TYPE_PTP_FAILED";
      break;
  }
  VAL_ENUM_NAME(childval) = enum_str;

  childval = agt_make_object(
      cfg_obj,
      y_intri_time_N_Status_LocalTime,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  VAL_STRING(childval) = out.LocalTime;

  childval = agt_make_object(
      cfg_obj,
      y_intri_time_N_Status_LocalDate,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  VAL_STRING(childval) = out.LocalDate;

  childval = agt_make_object(
      cfg_obj,
      y_intri_time_N_Status_UsedNTPServer,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  VAL_STRING(childval) = out.UsedNTPServer;

  return res;

} /* y_intri_time_intri_time_get_status_invoke */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_run_sync_now_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_run_sync_now_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_time_intri_time_run_sync_now_validate */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_run_sync_now_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_run_sync_now_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  struct emptypb_Empty epty;
  time_Time_RunSyncNow(&epty, &epty);

  return res;

} /* y_intri_time_intri_time_run_sync_now_invoke */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_run_list_timezone_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_run_list_timezone_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_time_intri_time_run_list_timezone_validate */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_run_list_timezone_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_run_list_timezone_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  val_value_t *msg_val = val_new_value();
  val_init_from_template(msg_val, intri_time_run_list_timezone_obj);

  val_value_t *res_val = NULL;
  res_val = agt_make_object(
      msg_val->obj,
      "output",
      &res);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  struct emptypb_Empty epty;
  struct timepb_ListTimeZones tz_list;
  time_Time_RunListTimeZones(&epty, &tz_list);

  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;

  for (int i = 0; i < tz_list.List_Len; i++) {
    childval = agt_make_object(
        res_val->obj,
        y_intri_time_N_ListTimeZones_List,
        &res);
    if (childval != NULL) {
      dlq_enque(childval, &msg->rpc_dataQ);
    } else if (res != NO_ERR) {
      return SET_ERROR(res);
    }
    VAL_STRING(childval) = tz_list.List[i];
  }

  return res;

} /* y_intri_time_intri_time_run_list_timezone_invoke */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_get_correction_time_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_get_correction_time_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *RequestWithTimestamp_Ts_val;
  y_intri_time_T_intri_time_get_correction_time_input_RequestWithTimestamp_Ts RequestWithTimestamp_Ts;

  RequestWithTimestamp_Ts_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_RequestWithTimestamp_Ts);
  if (RequestWithTimestamp_Ts_val != NULL && RequestWithTimestamp_Ts_val->res == NO_ERR) {
    /* replace the following line with real code to fill in structure */
    (void)RequestWithTimestamp_Ts;
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_time_intri_time_get_correction_time_validate */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_get_correction_time_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_get_correction_time_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  struct timepb_RequestWithTimestamp in;
  struct timepb_Response out;

  val_value_t *RequestWithTimestamp_Ts_val;

  RequestWithTimestamp_Ts_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_RequestWithTimestamp_Ts);
  if (RequestWithTimestamp_Ts_val != NULL && RequestWithTimestamp_Ts_val->res == NO_ERR) {
    val_value_t *tmp_val = NULL;
    tmp_val = val_find_child(
        RequestWithTimestamp_Ts_val,
        y_intri_time_M_intri_time,
        "Seconds");
    if (tmp_val != NULL && tmp_val->res == NO_ERR) {
      in.Ts->Seconds = VAL_INT64(tmp_val);
    }
    tmp_val = val_find_child(
        RequestWithTimestamp_Ts_val,
        y_intri_time_M_intri_time,
        "Nanos");
    if (tmp_val != NULL && tmp_val->res == NO_ERR) {
      in.Ts->Nanos = VAL_INT64(tmp_val);
    }
  }

  time_Time_GetCorrectionTime(&in, &out);

  val_value_t *msg_val = val_new_value();
  val_init_from_template(msg_val, intri_time_get_correction_time_obj);

  val_value_t *res_val = NULL;
  res_val = agt_make_object(
      msg_val->obj,
      "output",
      &res);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;

  childval = agt_make_object(
      res_val->obj,
      y_intri_time_N_Response_Ts,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  VAL_STRING(childval) = out.Ts;

  return res;

} /* y_intri_time_intri_time_get_correction_time_invoke */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_get_correction_time_with_int64_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_get_correction_time_with_int64_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  val_value_t *RequestWithInt64_Ts_val;
  int64 RequestWithInt64_Ts;

  RequestWithInt64_Ts_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_RequestWithInt64_Ts);
  if (RequestWithInt64_Ts_val != NULL && RequestWithInt64_Ts_val->res == NO_ERR) {
    RequestWithInt64_Ts = VAL_LONG(RequestWithInt64_Ts_val);
  }

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_time_intri_time_get_correction_time_with_int64_validate */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_get_correction_time_with_int64_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_get_correction_time_with_int64_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  struct timepb_RequestWithInt64 in;
  struct timepb_Response out;

  val_value_t *RequestWithInt64_Ts_val;

  RequestWithInt64_Ts_val = val_find_child(
      msg->rpc_input,
      y_intri_time_M_intri_time,
      y_intri_time_N_RequestWithInt64_Ts);
  if (RequestWithInt64_Ts_val != NULL && RequestWithInt64_Ts_val->res == NO_ERR) {
    in.Ts = VAL_LONG(RequestWithInt64_Ts_val);
  }

  time_Time_GetCorrectionTimeWithInt64(&in, &out);

  val_value_t *msg_val = val_new_value();
  val_init_from_template(msg_val, intri_time_get_correction_time_with_int64_obj);

  val_value_t *res_val = NULL;
  res_val = agt_make_object(
      msg_val->obj,
      "output",
      &res);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;

  childval = agt_make_object(
      res_val->obj,
      y_intri_time_N_Response_Ts,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  VAL_STRING(childval) = out.Ts;

  return res;

} /* y_intri_time_intri_time_get_correction_time_with_int64_invoke */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_get_utc_validate
 *
 * RPC validation phase
 * All YANG constraints have passed at this point.
 * Add description-stmt checks in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_get_utc_validate(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  val_value_t *errorval = NULL;

  if (res != NO_ERR) {
    agt_record_error(
        scb,
        &msg->mhdr,
        NCX_LAYER_OPERATION,
        res,
        methnode,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval,
        (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
        errorval);
  }
  return res;

} /* y_intri_time_intri_time_get_utc_validate */

/********************************************************************
 * FUNCTION y_intri_time_intri_time_get_utc_invoke
 *
 * RPC invocation phase
 * All constraints have passed at this point.
 * Call device instrumentation code in this function.
 *
 * INPUTS:
 *     see agt/agt_rpc.h for details
 *
 * RETURNS:
 *     error status
 ********************************************************************/
static status_t y_intri_time_intri_time_get_utc_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;

  struct emptypb_Empty in;
  struct timepb_Response out;

  time_Time_GetUTC(&in, &out);

  val_value_t *msg_val = val_new_value();
  val_init_from_template(msg_val, intri_time_get_correction_time_with_int64_obj);

  val_value_t *res_val = NULL;
  res_val = agt_make_object(
      msg_val->obj,
      "output",
      &res);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  val_value_t *childval = NULL;
  const xmlChar *enum_str = EMPTY_STRING;

  childval = agt_make_object(
      res_val->obj,
      y_intri_time_N_Response_Ts,
      &res);
  if (childval != NULL) {
    dlq_enque(childval, &msg->rpc_dataQ);
  } else if (res != NO_ERR) {
    return SET_ERROR(res);
  }
  VAL_STRING(childval) = out.Ts;

  return res;

} /* y_intri_time_intri_time_get_utc_invoke */

/********************************************************************
 * FUNCTION y_intri_time_init
 *
 * initialize the intri-time server instrumentation library
 *
 * INPUTS:
 *    modname == requested module name
 *    revision == requested version (NULL for any)
 *
 * RETURNS:
 *     error status
 ********************************************************************/
status_t y_intri_time_init(
    const xmlChar *modname,
    const xmlChar *revision) {
  status_t res = NO_ERR;
  agt_profile_t *agt_profile = agt_get_profile();

  y_intri_time_init_static_vars();

  /* change if custom handling done */
  if (xml_strcmp(modname, y_intri_time_M_intri_time)) {
    return ERR_NCX_UNKNOWN_MODULE;
  }

  if (revision && xml_strcmp(revision, y_intri_time_R_intri_time)) {
    return ERR_NCX_WRONG_VERSION;
  }
  res = ncxmod_load_module(
      y_intri_time_M_intri_time,
      y_intri_time_R_intri_time,
      &agt_profile->agt_savedevQ,
      &intri_time_mod);
  if (res != NO_ERR) {
    return res;
  }

  intri_time_get_config_obj = ncx_find_object(
      intri_time_mod,
      y_intri_time_N_intri_time_get_config);
  if (intri_time_get_config_obj == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_time_set_config_obj = ncx_find_object(
      intri_time_mod,
      y_intri_time_N_intri_time_set_config);
  if (intri_time_set_config_obj == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_time_get_status_obj = ncx_find_object(
      intri_time_mod,
      y_intri_time_N_intri_time_get_status);
  if (intri_time_get_status_obj == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_time_run_sync_now_obj = ncx_find_object(
      intri_time_mod,
      y_intri_time_N_intri_time_run_sync_now);
  if (intri_time_run_sync_now_obj == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_time_run_list_timezone_obj = ncx_find_object(
      intri_time_mod,
      y_intri_time_N_intri_time_run_list_timezone);
  if (intri_time_run_list_timezone_obj == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_time_get_correction_time_obj = ncx_find_object(
      intri_time_mod,
      y_intri_time_N_intri_time_get_correction_time);
  if (intri_time_get_correction_time_obj == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_time_get_correction_time_with_int64_obj = ncx_find_object(
      intri_time_mod,
      y_intri_time_N_intri_time_get_correction_time_with_int64);
  if (intri_time_get_correction_time_with_int64_obj == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  intri_time_get_utc_obj = ncx_find_object(
      intri_time_mod,
      y_intri_time_N_intri_time_get_utc);
  if (intri_time_get_utc_obj == NULL) {
    return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
  }
  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_get_config,
      AGT_RPC_PH_VALIDATE,
      y_intri_time_intri_time_get_config_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_get_config,
      AGT_RPC_PH_INVOKE,
      y_intri_time_intri_time_get_config_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_set_config,
      AGT_RPC_PH_VALIDATE,
      y_intri_time_intri_time_set_config_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_set_config,
      AGT_RPC_PH_INVOKE,
      y_intri_time_intri_time_set_config_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_get_status,
      AGT_RPC_PH_VALIDATE,
      y_intri_time_intri_time_get_status_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_get_status,
      AGT_RPC_PH_INVOKE,
      y_intri_time_intri_time_get_status_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_run_sync_now,
      AGT_RPC_PH_VALIDATE,
      y_intri_time_intri_time_run_sync_now_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_run_sync_now,
      AGT_RPC_PH_INVOKE,
      y_intri_time_intri_time_run_sync_now_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_run_list_timezone,
      AGT_RPC_PH_VALIDATE,
      y_intri_time_intri_time_run_list_timezone_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_run_list_timezone,
      AGT_RPC_PH_INVOKE,
      y_intri_time_intri_time_run_list_timezone_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_get_correction_time,
      AGT_RPC_PH_VALIDATE,
      y_intri_time_intri_time_get_correction_time_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_get_correction_time,
      AGT_RPC_PH_INVOKE,
      y_intri_time_intri_time_get_correction_time_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_get_correction_time_with_int64,
      AGT_RPC_PH_VALIDATE,
      y_intri_time_intri_time_get_correction_time_with_int64_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_get_correction_time_with_int64,
      AGT_RPC_PH_INVOKE,
      y_intri_time_intri_time_get_correction_time_with_int64_invoke);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_get_utc,
      AGT_RPC_PH_VALIDATE,
      y_intri_time_intri_time_get_utc_validate);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_get_utc,
      AGT_RPC_PH_INVOKE,
      y_intri_time_intri_time_get_utc_invoke);
  if (res != NO_ERR) {
    return res;
  }

  /* put your module initialization code here */

  return res;
} /* y_intri_time_init */

/********************************************************************
 * FUNCTION y_intri_time_init2
 *
 * SIL init phase 2: non-config data structures
 * Called after running config is loaded
 *
 * RETURNS:
 *     error status
 ********************************************************************/
status_t y_intri_time_init2(void) {
  status_t res = NO_ERR;

  /* put your init2 code here */

  return res;
} /* y_intri_time_init2 */

/********************************************************************
 * FUNCTION y_intri_time_cleanup
 *    cleanup the server instrumentation library
 *
 ********************************************************************/
void y_intri_time_cleanup(void) {
  agt_rpc_unregister_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_get_config);

  agt_rpc_unregister_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_set_config);

  agt_rpc_unregister_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_get_status);

  agt_rpc_unregister_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_run_sync_now);

  agt_rpc_unregister_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_run_list_timezone);

  agt_rpc_unregister_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_get_correction_time);

  agt_rpc_unregister_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_get_correction_time_with_int64);

  agt_rpc_unregister_method(
      y_intri_time_M_intri_time,
      y_intri_time_N_intri_time_get_utc);
  /* put your cleanup code here */

} /* y_intri_time_cleanup */

/* END intri_time.c */
