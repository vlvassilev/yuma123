module sercom-qos {

  namespace "sercom:sercom-qos";
  prefix "sercom-qos";
  organization "
    Sercomm Inc.";
  contact "
    sercomm@sercomm.com.tw";
  revision 2022-06-24 {
    description "Build date.";
  }

  import sercom-device {
    prefix sercom-device;
  }
  import sercom-empty {
    prefix sercom-empty;
  }
  typedef ModeTypeOptions {
    type enumeration {
      enum MODE_TYPE_DISABLED {
        description "[Disable] this mode has no type of traffic prioritized over another queue";
        value 0;
      }
      enum MODE_TYPE_BASIC {
        description "[Basic] this mode allows the type of traffic prioritized with the trust mode to queue";
        value 1;
      }
    }
  }
  typedef TrustModeTypeOptions {
    type enumeration {
      enum TRUST_MODE_TYPE_COS {
        description "[CoS] this mode sets CoS/802.1p to queue prioritized";
        value 0;
      }
      enum TRUST_MODE_TYPE_DSCP_ONLY {
        description "[DSCP Only] this mode sets DSCP to queue prioritized";
        value 1;
      }
      enum TRUST_MODE_TYPE_DSCP_FIRST {
        description "[DSCP First] this mode sets DSCP to queue as the first priority, and then CoS to queue as the second";
        value 2;
      }
    }
  }
  typedef PrioritySchemeTypeOptions {
    type enumeration {
      enum PRIORITY_SCHEME_TYPE_WRR {
        description "[WRR] WRR(Weighted Round Robin) queuing schedules all the queues, which in turn ensures every queue served for a certain time";
        value 0;
      }
      enum PRIORITY_SCHEME_TYPE_SP {
        description "[SP] SP(Strict Priority) queuing allows queue priority to reduce the response delay when congestion occurs";
        value 1;
      }
      enum PRIORITY_SCHEME_TYPE_WRR_AND_SP {
        description "[WRR+SP] WRR+SP queuing";
        value 2;
      }
    }
  }
  grouping WeightedFairTrafficRatioQueueEntry {
    leaf QueueNo {
      mandatory "true";
      type int32;
    }
    leaf Priority {
      mandatory "true";
      type int32;
    }
    leaf Scheme {
      mandatory "true";
      type PrioritySchemeTypeOptions;
    }
  }
  grouping MappingCoSDot1PToQueueEntry {
    leaf CosNo {
      mandatory "true";
      type int32;
    }
    leaf QueueNo {
      mandatory "true";
      type int32;
    }
  }
  grouping MappingDSCPToQueueEntry {
    leaf DSCPNo {
      mandatory "true";
      type int32;
    }
    leaf QueueNo {
      mandatory "true";
      type int32;
    }
  }
  grouping InterfaceConfigEntry {
    container IdentifyNo {
      uses sercom-device:InterfaceIdentify;
    }
    leaf IsEnabled {
      mandatory "true";
      type boolean;
    }
    leaf EgressBandwidth {
      mandatory "true";
      type int32;
    }
    leaf IngressBandwidth {
      mandatory "true";
      type int32;
    }
    leaf IngressUnicastEnabled {
      mandatory "true";
      type boolean;
    }
    leaf IngressMulticastEnabled {
      mandatory "true";
      type boolean;
    }
    leaf IngressBroadcastEnabled {
      mandatory "true";
      type boolean;
    }
  }
  grouping Config {
    leaf ModeOption {
      mandatory "true";
      type ModeTypeOptions;
    }
    leaf TrustModeOption {
      mandatory "true";
      type TrustModeTypeOptions;
    }
    container QueueList {
      list QueueList_Entry {
        uses WeightedFairTrafficRatioQueueEntry;
      }
    }
    container CoSList {
      list CoSList_Entry {
        uses MappingCoSDot1PToQueueEntry;
      }
    }
    container DSCPList {
      list DSCPList_Entry {
        uses MappingDSCPToQueueEntry;
      }
    }
    container InterfaceList {
      list InterfaceList_Entry {
        uses InterfaceConfigEntry;
      }
    }
  }
  grouping Mode {
    leaf Option {
      mandatory "true";
      type ModeTypeOptions;
    }
  }
  grouping TrustMode {
    leaf Option {
      mandatory "true";
      type TrustModeTypeOptions;
    }
  }
  grouping PriorityScheme {
    leaf Option {
      mandatory "true";
      type PrioritySchemeTypeOptions;
    }
  }
  grouping QueueList {
    container List {
      list List_Entry {
        uses WeightedFairTrafficRatioQueueEntry;
      }
    }
  }
  grouping CoSList {
    container List {
      list List_Entry {
        uses MappingCoSDot1PToQueueEntry;
      }
    }
  }
  grouping DSCPList {
    container List {
      list List_Entry {
        uses MappingDSCPToQueueEntry;
      }
    }
  }
  grouping InterfaceList {
    container List {
      list List_Entry {
        uses InterfaceConfigEntry;
      }
    }
  }
  rpc sercom-qos-QoS-GetMode {
    output {
      uses Mode;
    }
  }
  rpc sercom-qos-QoS-SetMode {
    input {
      uses Mode;
    }
  }
  rpc sercom-qos-QoS-GetTrustMode {
    output {
      uses TrustMode;
    }
  }
  rpc sercom-qos-QoS-SetTrustMode {
    input {
      uses TrustMode;
    }
  }
  rpc sercom-qos-QoS-GetQueueList {
    output {
      uses QueueList;
    }
  }
  rpc sercom-qos-QoS-SetAllQueueListPriorityScheme {
    input {
      uses PriorityScheme;
    }
  }
  rpc sercom-qos-QoS-UpdateQueueEntry {
    input {
      uses WeightedFairTrafficRatioQueueEntry;
    }
  }
  rpc sercom-qos-QoS-UpdateQueueList {
    input {
      uses QueueList;
    }
  }
  rpc sercom-qos-QoS-GetCoSList {
    output {
      uses CoSList;
    }
  }
  rpc sercom-qos-QoS-UpdateCoSEntry {
    input {
      uses MappingCoSDot1PToQueueEntry;
    }
  }
  rpc sercom-qos-QoS-UpdateCoSList {
    input {
      uses CoSList;
    }
  }
  rpc sercom-qos-QoS-GetDSCPList {
    output {
      uses DSCPList;
    }
  }
  rpc sercom-qos-QoS-UpdateDSCPEntry {
    input {
      uses MappingDSCPToQueueEntry;
    }
  }
  rpc sercom-qos-QoS-UpdateDSCPList {
    input {
      uses DSCPList;
    }
  }
  rpc sercom-qos-QoS-GetInterfaceList {
    output {
      uses InterfaceList;
    }
  }
  rpc sercom-qos-QoS-UpdateInterfaceEntry {
    input {
      uses InterfaceConfigEntry;
    }
  }
  rpc sercom-qos-QoS-UpdateInterfaceList {
    input {
      uses InterfaceList;
    }
  }
}
