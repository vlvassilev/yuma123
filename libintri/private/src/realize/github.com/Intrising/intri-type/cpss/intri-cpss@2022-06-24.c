// Code generated by protoc-gen-yang(*.c) DO NOT EDIT.

/*****************************************************************************************************
 * Copyright (C) 2017-2022 by Intrising
 *  - ian0113@intrising.com.tw
 * 
 * Generated by protoc-gen-yang@gen-yang
 * 
 *****************************************************************************************************/

#include <libxml/xmlstring.h>
#include "agt.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "procdefs.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"

#include "intri-cpss@2022-06-24.h"
#include "../../../../../../../.libintrishare/libintrishare.h"

#include "../../../../../genc-trans/github.com/Intrising/intri-type/cpss/intri-cpss-trans.h"
#include "../../../../../genc-trans/github.com/golang/protobuf/ptypes/empty/intri-empty-trans.h"

static ncx_module_t *intri_cpss_mod;

static status_t intri_cpss_Device_RunCPSSInit_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_Device_RunCPSSInit(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Device_GetArchitecture_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_DeviceArchitecture *out = malloc(sizeof(*out));

  cpss_Device_GetArchitecture(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_DeviceArchitecture(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Trunking_SetGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_TrunkingGroupMemberEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_TrunkingGroupMemberEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Trunking_SetGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Trunking_AddGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_TrunkingMemberEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_TrunkingMemberEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Trunking_AddGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Trunking_DeleteGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_TrunkingMemberEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_TrunkingMemberEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Trunking_DeleteGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Trunking_SetLoadBalanceMode_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_TrunkingLoadBalanceMode *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_Trunking_GetLoadBalanceMode(out, in);
  res = build_to_priv_cpss_TrunkingLoadBalanceMode(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Trunking_SetLoadBalanceMode(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Trunking_GetLoadBalanceMode_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_TrunkingLoadBalanceMode *out = malloc(sizeof(*out));

  cpss_Trunking_GetLoadBalanceMode(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_TrunkingLoadBalanceMode(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Trunking_GetGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_TrunkingGroupID *in = malloc(sizeof(*in));
  struct cpsspb_TrunkingGroupMemberEntry *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_TrunkingGroupID(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Trunking_GetGroup(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_TrunkingGroupMemberEntry(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_ACL_RunClearAllRules_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_ACL_RunClearAllRules(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_ACL_UpdateControlRule_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_ACLControlRuleEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_ACLControlRuleEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_ACL_UpdateControlRule(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_ACL_AddControlRule_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_ACLControlRuleEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_ACLControlRuleEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_ACL_AddControlRule(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_ACL_DeleteControlRule_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_ACLControlRuleEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_ACLControlRuleEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_ACL_DeleteControlRule(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_ACL_RunClearControlRule_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_ACLControlRuleEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_ACLControlRuleEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_ACL_RunClearControlRule(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_ACL_AddUserDefinedRules_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_ACLUserDefinedRuleList *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_ACLUserDefinedRuleList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_ACL_AddUserDefinedRules(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_ACL_DeleteUserDefinedRules_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_ACLUserDefinedRuleRemovalList *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_ACLUserDefinedRuleRemovalList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_ACL_DeleteUserDefinedRules(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_ACL_RunClearAllUserDefinedRules_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_ACL_RunClearAllUserDefinedRules(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_CNC_AddCounting_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_CNCCountingEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_CNCCountingEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_CNC_AddCounting(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_CNC_DeleteCounting_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_CNCCountingEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_CNCCountingEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_CNC_DeleteCounting(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_CNC_GetCounter_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_CNCCountingEntry *in = malloc(sizeof(*in));
  struct cpsspb_CNCCounter *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_CNCCountingEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_CNC_GetCounter(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_CNCCounter(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_FDB_SetAutoLearnEnable_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_FDBAutoLearningEnable *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_FDBAutoLearningEnable(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_FDB_SetAutoLearnEnable(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_FDB_SetEntry_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_FDBMACEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_FDBMACEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_FDB_SetEntry(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_FDB_DeleteEntry_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_FDBMACEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_FDBMACEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_FDB_DeleteEntry(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_FDB_SetAgingTime_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_FDBAgingTime *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_FDB_GetAgingTime(out, in);
  res = build_to_priv_cpss_FDBAgingTime(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_FDB_SetAgingTime(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_FDB_GetAgingTime_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_FDBAgingTime *out = malloc(sizeof(*out));

  cpss_FDB_GetAgingTime(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_FDBAgingTime(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_FDB_SetSecureBreachNaPortEnable_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_FDBSecureBreachEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_FDBSecureBreachEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_FDB_SetSecureBreachNaPortEnable(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_FDB_GetSecureBreachNaPortEnable_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DevicePortEntry *in = malloc(sizeof(*in));
  struct cpsspb_Enabled *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DevicePortEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_FDB_GetSecureBreachNaPortEnable(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_Enabled(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_FDB_GetCounter_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_FDBCounters *out = malloc(sizeof(*out));

  cpss_FDB_GetCounter(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_FDBCounters(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_FDB_RunFlush_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_FDBFlushEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_FDBFlushEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_FDB_RunFlush(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_FDB_RunDump_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_FDBDumpEntry *out = malloc(sizeof(*out));

  cpss_FDB_RunDump(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_FDBDumpEntry(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Mirroring_RunClearAll_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_Mirroring_RunClearAll(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Mirroring_SetSessions_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_MirroringSessionList *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_MirroringSessionList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Mirroring_SetSessions(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Mirroring_SetPolicyBased_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_MirroringPolicyBased *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_MirroringPolicyBased(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Mirroring_SetPolicyBased(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Misc_RunMACRegisterWrite_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_MiscMACRegisterEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_MiscMACRegisterEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Misc_RunMACRegisterWrite(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Misc_RunMACRegisterRead_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_MiscMACRegisterEntry *in = malloc(sizeof(*in));
  struct cpsspb_MiscRegisterData *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_MiscMACRegisterEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Misc_RunMACRegisterRead(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_MiscRegisterData(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Misc_RunSMIRegisterWrite_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_MiscSMIRegisterEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_MiscSMIRegisterEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Misc_RunSMIRegisterWrite(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Misc_RunSMIRegisterRead_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_MiscSMIRegisterEntry *in = malloc(sizeof(*in));
  struct cpsspb_MiscRegisterData *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_MiscSMIRegisterEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Misc_RunSMIRegisterRead(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_MiscRegisterData(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Misc_RunXSMIRegisterWrite_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_MiscXSMIRegisterEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_MiscXSMIRegisterEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Misc_RunXSMIRegisterWrite(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Misc_RunXSMIRegisterRead_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_MiscXSMIRegisterEntry *in = malloc(sizeof(*in));
  struct cpsspb_MiscRegisterData *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_MiscXSMIRegisterEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Misc_RunXSMIRegisterRead(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_MiscRegisterData(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Misc_GetCPUTemperature_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_MiscTemperature *out = malloc(sizeof(*out));

  cpss_Misc_GetCPUTemperature(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_MiscTemperature(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Misc_GetMACTemperature_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_MiscTemperature *out = malloc(sizeof(*out));

  cpss_Misc_GetMACTemperature(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_MiscTemperature(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Misc_GetPHYPortTemperature_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DevicePortEntry *in = malloc(sizeof(*in));
  struct cpsspb_MiscTemperature *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DevicePortEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Misc_GetPHYPortTemperature(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_MiscTemperature(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Misc_GetCPUModel_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_MiscModel *out = malloc(sizeof(*out));

  cpss_Misc_GetCPUModel(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_MiscModel(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Misc_GetPHYPortModel_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DevicePortEntry *in = malloc(sizeof(*in));
  struct cpsspb_MiscPHYPortModel *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DevicePortEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Misc_GetPHYPortModel(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_MiscPHYPortModel(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_AddGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanID *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_VlanID(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_AddGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_DeleteGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanID *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_VlanID(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_DeleteGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_AddMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanMemberTaggingList *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_VlanMemberTaggingList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_AddMember(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_DeleteMember_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanMemberTaggingList *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_VlanMemberTaggingList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_DeleteMember(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_UpdateAcceptFrameType_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanAcceptFrameTypeEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_VlanAcceptFrameTypeEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_UpdateAcceptFrameType(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_GetAcceptFrameType_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DeviceInterfaceEntry *in = malloc(sizeof(*in));
  struct cpsspb_VlanAcceptFrameTypeEntry *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DeviceInterfaceEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_GetAcceptFrameType(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_VlanAcceptFrameTypeEntry(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_UpdateDefaultVID_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanDefaultVIDEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_VlanDefaultVIDEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_UpdateDefaultVID(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_GetDefaultVID_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DeviceInterfaceEntry *in = malloc(sizeof(*in));
  struct cpsspb_VlanID *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DeviceInterfaceEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_GetDefaultVID(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_VlanID(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_RunFlush_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_Vlan_RunFlush(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_GetStatus_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_VlanStatusList *out = malloc(sizeof(*out));

  cpss_Vlan_GetStatus(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_VlanStatusList(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_UpdateTPIDEntry_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanTPIDEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_VlanTPIDEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_UpdateTPIDEntry(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_DumpTPIDTable_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_VlanTPIDList *out = malloc(sizeof(*out));

  cpss_Vlan_DumpTPIDTable(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_VlanTPIDList(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_UpdateTPIDIndex_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanTPIDIndexEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_VlanTPIDIndexEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_UpdateTPIDIndex(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_GetTPIDIndex_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DeviceInterfaceEntry *in = malloc(sizeof(*in));
  struct cpsspb_VlanTPIDIndexEntry *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DeviceInterfaceEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_GetTPIDIndex(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_VlanTPIDIndexEntry(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_RunClearTPIDIndex_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DeviceInterfaceEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DeviceInterfaceEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_RunClearTPIDIndex(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_SetTunnelEnable_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanTunnelEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_VlanTunnelEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_SetTunnelEnable(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_GetTunnelEnable_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DeviceInterfaceEntry *in = malloc(sizeof(*in));
  struct cpsspb_Enabled *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DeviceInterfaceEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_GetTunnelEnable(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_Enabled(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_UpdateProtocolClass_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanProtocolClassEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_VlanProtocolClassEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_UpdateProtocolClass(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_GetProtocolClass_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanProtocolClassID *in = malloc(sizeof(*in));
  struct cpsspb_VlanProtocolClassEntry *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_VlanProtocolClassID(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_GetProtocolClass(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_VlanProtocolClassEntry(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_RunClearProtocolClass_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanProtocolClassID *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_VlanProtocolClassID(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_RunClearProtocolClass(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_UpdateProtocol_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanProtocolEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_VlanProtocolEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_UpdateProtocol(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_GetProtocol_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanProtocolEntry *in = malloc(sizeof(*in));
  struct cpsspb_VlanProtocolEntry *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_VlanProtocolEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_GetProtocol(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_VlanProtocolEntry(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_RunClearProtocol_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanProtocolEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_VlanProtocolEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_RunClearProtocol(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_UpdateTranslationEnable_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanTranslationEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_VlanTranslationEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_UpdateTranslationEnable(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_GetTranslationEnable_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DeviceInterfaceEntry *in = malloc(sizeof(*in));
  struct cpsspb_Enabled *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DeviceInterfaceEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_GetTranslationEnable(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_Enabled(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_UpdateTranslationMapping_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanTranslationMappingEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_VlanTranslationMappingEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_UpdateTranslationMapping(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_GetTranslationMapping_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanID *in = malloc(sizeof(*in));
  struct cpsspb_VlanID *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_VlanID(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_GetTranslationMapping(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_VlanID(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Vlan_RunClearTranslationMapping_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanID *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_VlanID(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Vlan_RunClearTranslationMapping(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Multicast_SetBridgeGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_MulticastBridgeGroupEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_MulticastBridgeGroupEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Multicast_SetBridgeGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Multicast_DeleteBridgeGroup_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_FDBIdentifyEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_FDBIdentifyEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Multicast_DeleteBridgeGroup(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Multicast_SetUnregisteredFlooding_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_MulticastUnregisteredFloodingEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_MulticastUnregisteredFloodingEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Multicast_SetUnregisteredFlooding(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Multicast_RunClearUnregisteredFlooding_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_VlanID *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_VlanID(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Multicast_RunClearUnregisteredFlooding(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Multicast_RunDump_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_MulticastTable *out = malloc(sizeof(*out));

  cpss_Multicast_RunDump(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_MulticastTable(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Multicast_RunFlush_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_Multicast_RunFlush(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PacketControl_UpdateSTPControl_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PacketControlActionEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_PacketControlActionEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PacketControl_UpdateSTPControl(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PacketControl_UpdateLACPControl_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PacketControlActionEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_PacketControlActionEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PacketControl_UpdateLACPControl(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PacketControl_UpdateDot1XControl_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PacketControlActionEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_PacketControlActionEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PacketControl_UpdateDot1XControl(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PacketControl_UpdateLoopControl_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PacketControlActionEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_PacketControlActionEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PacketControl_UpdateLoopControl(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PacketControl_UpdateDHCPv4DiscoverControl_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PacketControlActionEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_PacketControlActionEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PacketControl_UpdateDHCPv4DiscoverControl(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PacketControl_UpdateDHCPv4BroadcastOfferControl_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PacketControlActionEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_PacketControlActionEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PacketControl_UpdateDHCPv4BroadcastOfferControl(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PacketControl_UpdateDHCPv4UDPDestination68Control_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PacketControlActionEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_PacketControlActionEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PacketControl_UpdateDHCPv4UDPDestination68Control(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PacketControl_UpdateDHCPv4UDPDestination67Control_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PacketControlActionEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_PacketControlActionEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PacketControl_UpdateDHCPv4UDPDestination67Control(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PacketControl_UpdateARPControl_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PacketControlActionEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_PacketControlActionEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PacketControl_UpdateARPControl(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PacketControl_UpdateIGMPVlanControl_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PacketControlActionEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_PacketControlActionEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PacketControl_UpdateIGMPVlanControl(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PacketControl_UpdateMLDVlanControl_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PacketControlActionEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_PacketControlActionEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PacketControl_UpdateMLDVlanControl(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PacketControl_UpdateGVRPControl_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PacketControlActionEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_PacketControlActionEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PacketControl_UpdateGVRPControl(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PacketControl_GetStatus_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_PacketControlStatusList *out = malloc(sizeof(*out));

  cpss_PacketControl_GetStatus(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PacketControlStatusList(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Policer_SetStormCountingEnable_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PolicerStormCountingEnableEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_PolicerStormCountingEnableEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Policer_SetStormCountingEnable(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Policer_GetStormCountingEnable_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DevicePortEntry *in = malloc(sizeof(*in));
  struct cpsspb_PolicerStormCountingEnableEntry *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DevicePortEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Policer_GetStormCountingEnable(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PolicerStormCountingEnableEntry(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Policer_GetStormCountingCounter_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DevicePortEntry *in = malloc(sizeof(*in));
  struct cpsspb_PolicerStormCountingCounterEntry *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DevicePortEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Policer_GetStormCountingCounter(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PolicerStormCountingCounterEntry(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Port_SetEnable_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PortEnableEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_PortEnableEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Port_SetEnable(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Port_GetEnable_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DevicePortEntry *in = malloc(sizeof(*in));
  struct cpsspb_PortEnableEntry *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DevicePortEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Port_GetEnable(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PortEnableEntry(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Port_SetSpeedDuplex_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PortSpeedDuplexEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_PortSpeedDuplexEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Port_SetSpeedDuplex(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Port_GetSpeedDuplex_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DevicePortEntry *in = malloc(sizeof(*in));
  struct cpsspb_PortSpeedDuplexEntry *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DevicePortEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Port_GetSpeedDuplex(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PortSpeedDuplexEntry(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Port_SetFlowControl_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PortFlowControlEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_PortFlowControlEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Port_SetFlowControl(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Port_GetFlowControl_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DevicePortEntry *in = malloc(sizeof(*in));
  struct cpsspb_PortFlowControlEntry *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DevicePortEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Port_GetFlowControl(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PortFlowControlEntry(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Port_SetEnableEEE_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PortEEEEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_PortEEEEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Port_SetEnableEEE(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Port_GetEnableEEE_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DevicePortEntry *in = malloc(sizeof(*in));
  struct cpsspb_PortEEEEntry *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DevicePortEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Port_GetEnableEEE(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PortEEEEntry(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Port_GetCounter_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DevicePortEntry *in = malloc(sizeof(*in));
  struct cpsspb_PortCounterEntry *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DevicePortEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Port_GetCounter(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PortCounterEntry(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Port_RunClearCounter_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DevicePortEntry *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DevicePortEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Port_RunClearCounter(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Port_SetIsolation_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PortIsolationList *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_Port_GetIsolation(out, in);
  res = build_to_priv_cpss_PortIsolationList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Port_SetIsolation(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Port_GetIsolation_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_PortIsolationList *out = malloc(sizeof(*out));

  cpss_Port_GetIsolation(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PortIsolationList(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Port_GetIPG_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_PortIPGSize *out = malloc(sizeof(*out));

  cpss_Port_GetIPG(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PortIPGSize(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Port_GetFaultStatus_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DevicePortEntry *in = malloc(sizeof(*in));
  struct cpsspb_PortFaultStatusEntry *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DevicePortEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Port_GetFaultStatus(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PortFaultStatusEntry(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_Port_GetStatus_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_DevicePortEntry *in = malloc(sizeof(*in));
  struct cpsspb_PortStatusEntry *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_DevicePortEntry(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_Port_GetStatus(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PortStatusEntry(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PTP_SetMode_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PTPMode *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_PTPMode(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PTP_SetMode(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PTP_GetIngrTS_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PTPMessageInfo *in = malloc(sizeof(*in));
  struct cpsspb_PTPQueueInfo *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_PTPMessageInfo(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PTP_GetIngrTS(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PTPQueueInfo(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PTP_GetEgrTS_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PTPMessageInfo *in = malloc(sizeof(*in));
  struct cpsspb_PTPQueueInfo *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_PTPMessageInfo(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PTP_GetEgrTS(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PTPQueueInfo(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PTP_SetLinkDelay_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PTPLinkDelay *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_PTPLinkDelay(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PTP_SetLinkDelay(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PTP_GetLinkDelay_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PTPLinkDelay *in = malloc(sizeof(*in));
  struct cpsspb_PTPLinkDelay *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_PTPLinkDelay(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PTP_GetLinkDelay(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PTPLinkDelay(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PTP_SetEnableSyncE_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PTPSyncE *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_PTPSyncE(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PTP_SetEnableSyncE(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PTP_SetToD_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PTPToD *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_PTP_GetToD(out, in);
  res = build_to_priv_cpss_PTPToD(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PTP_SetToD(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PTP_GetToD_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_PTPToD *out = malloc(sizeof(*out));

  cpss_PTP_GetToD(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PTPToD(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PTP_SetToDFrequency_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PTPToDFrequency *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: has no Get func */
  res = build_to_priv_cpss_PTPToDFrequency(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PTP_SetToDFrequency(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PTP_SetPortDelay_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PTPPortDelay *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_PTPPortDelay(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PTP_SetPortDelay(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_PTP_GetPortDelay_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_PTPPortDelay *in = malloc(sizeof(*in));
  struct cpsspb_PTPPortDelay *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_PTPPortDelay(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_PTP_GetPortDelay(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_PTPPortDelay(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_QoS_SetQoSPortProfile_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_QoSPortProfileList *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_QoS_GetQoSPortProfile(out, in);
  res = build_to_priv_cpss_QoSPortProfileList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_QoS_SetQoSPortProfile(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_QoS_GetQoSPortProfile_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_QoSPortProfileList *out = malloc(sizeof(*out));

  cpss_QoS_GetQoSPortProfile(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_QoSPortProfileList(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_QoS_SetQoSCoSProfile_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_QoSCoSProfileList *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_QoS_GetQoSCoSProfile(out, in);
  res = build_to_priv_cpss_QoSCoSProfileList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_QoS_SetQoSCoSProfile(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_QoS_GetQoSCoSProfile_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_QoSCoSProfileList *out = malloc(sizeof(*out));

  cpss_QoS_GetQoSCoSProfile(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_QoSCoSProfileList(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_QoS_SetQoSDSCPProfile_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_QoSDSCPProfileList *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_QoS_GetQoSDSCPProfile(out, in);
  res = build_to_priv_cpss_QoSDSCPProfileList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_QoS_SetQoSDSCPProfile(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_QoS_GetQoSDSCPProfile_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_QoSDSCPProfileList *out = malloc(sizeof(*out));

  cpss_QoS_GetQoSDSCPProfile(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_QoSDSCPProfileList(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_QoS_SetQoSQueueProfile_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_QoSPortQueueList *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_QoS_GetQoSQueueProfile(out, in);
  res = build_to_priv_cpss_QoSPortQueueList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_QoS_SetQoSQueueProfile(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_QoS_GetQoSQueueProfile_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_QoSPortQueueList *out = malloc(sizeof(*out));

  cpss_QoS_GetQoSQueueProfile(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_QoSPortQueueList(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_RateLimiting_SetIngress_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_RateLimitingIngressList *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_RateLimiting_GetIngress(out, in);
  res = build_to_priv_cpss_RateLimitingIngressList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_RateLimiting_SetIngress(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_RateLimiting_GetIngress_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_RateLimitingIngressList *out = malloc(sizeof(*out));

  cpss_RateLimiting_GetIngress(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_RateLimitingIngressList(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_RateLimiting_SetEgress_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_RateLimitingEgressList *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  cpss_RateLimiting_GetEgress(out, in);
  res = build_to_priv_cpss_RateLimitingEgressList(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_RateLimiting_SetEgress(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_RateLimiting_GetEgress_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct emptypb_Empty *in = malloc(sizeof(*in));
  struct cpsspb_RateLimitingEgressList *out = malloc(sizeof(*out));

  cpss_RateLimiting_GetEgress(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_RateLimitingEgressList(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_STP_SetPortState_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_STPPortState *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_STPPortState(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_STP_SetPortState(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_STP_GetPortState_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_STPPortState *in = malloc(sizeof(*in));
  struct cpsspb_STPIDState *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_STPPortState(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_STP_GetPortState(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_STPIDState(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_STP_SetVlanBinding_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_STPVlanBinding *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: the Get func has input */
  res = build_to_priv_cpss_STPVlanBinding(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_STP_SetVlanBinding(in, out);

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_STP_GetVlanBinding_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_STPID *in = malloc(sizeof(*in));
  struct cpsspb_VlanList *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_STPID(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_STP_GetVlanBinding(in, out);

  obj_template_t *outobj = obj_find_child(
      msg->rpc_method,
      y_M_intri_cpss,
      "output");
  val_value_t *outval = val_new_value();
  val_init_from_template(outval, outobj);

  res = build_to_xml_cpss_VlanList(outval, out);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }

  dlq_block_enque(&outval->v.childQ, &msg->rpc_dataQ);

  /* debug: print `val_value_t` in `msg->rpc_dataQ` */
  // for (val_value_t *val = (val_value_t *)dlq_firstEntry(&msg->rpc_dataQ);
  //      val != NULL;
  //      val = (val_value_t *)dlq_nextEntry(val)) {
  //   val_dump_value(val, 2);
  // }

  free(in);
  free(out);
  return res;
}
static status_t intri_cpss_STP_RunClearVlanBinding_invoke(
    ses_cb_t *scb,
    rpc_msg_t *msg,
    xml_node_t *methnode) {
  status_t res = NO_ERR;
  struct cpsspb_STPVlanBinding *in = malloc(sizeof(*in));
  struct emptypb_Empty *out = malloc(sizeof(*out));

  /* ian: this func has no prefix Update/Set */
  res = build_to_priv_cpss_STPVlanBinding(msg->rpc_input, in);
  if (res != NO_ERR) {
    free(in);
    free(out);
    return SET_ERROR(res);
  }
  cpss_STP_RunClearVlanBinding(in, out);

  free(in);
  free(out);
  return res;
}

status_t y_intri_cpss_init(
    const xmlChar *modname,
    const xmlChar *revision) {
  status_t res = NO_ERR;
  agt_profile_t *agt_profile = agt_get_profile();

  if (xml_strcmp(modname, y_M_intri_cpss)) {
    return ERR_NCX_UNKNOWN_MODULE;
  }
  if (revision && xml_strcmp(revision, y_R_intri_cpss)) {
    return ERR_NCX_WRONG_VERSION;
  }

  res = ncxmod_load_module(
      y_M_intri_cpss,
      y_R_intri_cpss,
      &agt_profile->agt_savedevQ,
      &intri_cpss_mod);
  if (res != NO_ERR) {
    return res;
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Device-RunCPSSInit",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Device_RunCPSSInit_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Device-GetArchitecture",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Device_GetArchitecture_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Trunking-SetGroup",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Trunking_SetGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Trunking-AddGroup",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Trunking_AddGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Trunking-DeleteGroup",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Trunking_DeleteGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Trunking-SetLoadBalanceMode",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Trunking_SetLoadBalanceMode_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Trunking-GetLoadBalanceMode",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Trunking_GetLoadBalanceMode_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Trunking-GetGroup",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Trunking_GetGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-RunClearAllRules",
      AGT_RPC_PH_INVOKE,
      intri_cpss_ACL_RunClearAllRules_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-UpdateControlRule",
      AGT_RPC_PH_INVOKE,
      intri_cpss_ACL_UpdateControlRule_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-AddControlRule",
      AGT_RPC_PH_INVOKE,
      intri_cpss_ACL_AddControlRule_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-DeleteControlRule",
      AGT_RPC_PH_INVOKE,
      intri_cpss_ACL_DeleteControlRule_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-RunClearControlRule",
      AGT_RPC_PH_INVOKE,
      intri_cpss_ACL_RunClearControlRule_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-AddUserDefinedRules",
      AGT_RPC_PH_INVOKE,
      intri_cpss_ACL_AddUserDefinedRules_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-DeleteUserDefinedRules",
      AGT_RPC_PH_INVOKE,
      intri_cpss_ACL_DeleteUserDefinedRules_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-RunClearAllUserDefinedRules",
      AGT_RPC_PH_INVOKE,
      intri_cpss_ACL_RunClearAllUserDefinedRules_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-CNC-AddCounting",
      AGT_RPC_PH_INVOKE,
      intri_cpss_CNC_AddCounting_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-CNC-DeleteCounting",
      AGT_RPC_PH_INVOKE,
      intri_cpss_CNC_DeleteCounting_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-CNC-GetCounter",
      AGT_RPC_PH_INVOKE,
      intri_cpss_CNC_GetCounter_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-SetAutoLearnEnable",
      AGT_RPC_PH_INVOKE,
      intri_cpss_FDB_SetAutoLearnEnable_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-SetEntry",
      AGT_RPC_PH_INVOKE,
      intri_cpss_FDB_SetEntry_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-DeleteEntry",
      AGT_RPC_PH_INVOKE,
      intri_cpss_FDB_DeleteEntry_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-SetAgingTime",
      AGT_RPC_PH_INVOKE,
      intri_cpss_FDB_SetAgingTime_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-GetAgingTime",
      AGT_RPC_PH_INVOKE,
      intri_cpss_FDB_GetAgingTime_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-SetSecureBreachNaPortEnable",
      AGT_RPC_PH_INVOKE,
      intri_cpss_FDB_SetSecureBreachNaPortEnable_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-GetSecureBreachNaPortEnable",
      AGT_RPC_PH_INVOKE,
      intri_cpss_FDB_GetSecureBreachNaPortEnable_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-GetCounter",
      AGT_RPC_PH_INVOKE,
      intri_cpss_FDB_GetCounter_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-RunFlush",
      AGT_RPC_PH_INVOKE,
      intri_cpss_FDB_RunFlush_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-RunDump",
      AGT_RPC_PH_INVOKE,
      intri_cpss_FDB_RunDump_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Mirroring-RunClearAll",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Mirroring_RunClearAll_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Mirroring-SetSessions",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Mirroring_SetSessions_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Mirroring-SetPolicyBased",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Mirroring_SetPolicyBased_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-RunMACRegisterWrite",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Misc_RunMACRegisterWrite_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-RunMACRegisterRead",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Misc_RunMACRegisterRead_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-RunSMIRegisterWrite",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Misc_RunSMIRegisterWrite_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-RunSMIRegisterRead",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Misc_RunSMIRegisterRead_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-RunXSMIRegisterWrite",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Misc_RunXSMIRegisterWrite_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-RunXSMIRegisterRead",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Misc_RunXSMIRegisterRead_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-GetCPUTemperature",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Misc_GetCPUTemperature_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-GetMACTemperature",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Misc_GetMACTemperature_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-GetPHYPortTemperature",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Misc_GetPHYPortTemperature_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-GetCPUModel",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Misc_GetCPUModel_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-GetPHYPortModel",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Misc_GetPHYPortModel_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-AddGroup",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_AddGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-DeleteGroup",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_DeleteGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-AddMember",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_AddMember_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-DeleteMember",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_DeleteMember_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateAcceptFrameType",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_UpdateAcceptFrameType_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetAcceptFrameType",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_GetAcceptFrameType_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateDefaultVID",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_UpdateDefaultVID_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetDefaultVID",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_GetDefaultVID_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-RunFlush",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_RunFlush_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetStatus",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_GetStatus_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateTPIDEntry",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_UpdateTPIDEntry_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-DumpTPIDTable",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_DumpTPIDTable_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateTPIDIndex",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_UpdateTPIDIndex_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetTPIDIndex",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_GetTPIDIndex_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-RunClearTPIDIndex",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_RunClearTPIDIndex_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-SetTunnelEnable",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_SetTunnelEnable_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetTunnelEnable",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_GetTunnelEnable_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateProtocolClass",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_UpdateProtocolClass_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetProtocolClass",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_GetProtocolClass_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-RunClearProtocolClass",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_RunClearProtocolClass_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateProtocol",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_UpdateProtocol_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetProtocol",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_GetProtocol_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-RunClearProtocol",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_RunClearProtocol_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateTranslationEnable",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_UpdateTranslationEnable_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetTranslationEnable",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_GetTranslationEnable_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateTranslationMapping",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_UpdateTranslationMapping_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetTranslationMapping",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_GetTranslationMapping_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-RunClearTranslationMapping",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Vlan_RunClearTranslationMapping_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Multicast-SetBridgeGroup",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Multicast_SetBridgeGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Multicast-DeleteBridgeGroup",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Multicast_DeleteBridgeGroup_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Multicast-SetUnregisteredFlooding",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Multicast_SetUnregisteredFlooding_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Multicast-RunClearUnregisteredFlooding",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Multicast_RunClearUnregisteredFlooding_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Multicast-RunDump",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Multicast_RunDump_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Multicast-RunFlush",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Multicast_RunFlush_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateSTPControl",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PacketControl_UpdateSTPControl_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateLACPControl",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PacketControl_UpdateLACPControl_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateDot1XControl",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PacketControl_UpdateDot1XControl_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateLoopControl",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PacketControl_UpdateLoopControl_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateDHCPv4DiscoverControl",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PacketControl_UpdateDHCPv4DiscoverControl_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateDHCPv4BroadcastOfferControl",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PacketControl_UpdateDHCPv4BroadcastOfferControl_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateDHCPv4UDPDestination68Control",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PacketControl_UpdateDHCPv4UDPDestination68Control_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateDHCPv4UDPDestination67Control",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PacketControl_UpdateDHCPv4UDPDestination67Control_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateARPControl",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PacketControl_UpdateARPControl_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateIGMPVlanControl",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PacketControl_UpdateIGMPVlanControl_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateMLDVlanControl",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PacketControl_UpdateMLDVlanControl_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateGVRPControl",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PacketControl_UpdateGVRPControl_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-GetStatus",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PacketControl_GetStatus_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Policer-SetStormCountingEnable",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Policer_SetStormCountingEnable_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Policer-GetStormCountingEnable",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Policer_GetStormCountingEnable_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Policer-GetStormCountingCounter",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Policer_GetStormCountingCounter_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Port-SetEnable",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Port_SetEnable_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetEnable",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Port_GetEnable_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Port-SetSpeedDuplex",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Port_SetSpeedDuplex_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetSpeedDuplex",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Port_GetSpeedDuplex_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Port-SetFlowControl",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Port_SetFlowControl_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetFlowControl",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Port_GetFlowControl_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Port-SetEnableEEE",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Port_SetEnableEEE_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetEnableEEE",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Port_GetEnableEEE_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetCounter",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Port_GetCounter_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Port-RunClearCounter",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Port_RunClearCounter_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Port-SetIsolation",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Port_SetIsolation_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetIsolation",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Port_GetIsolation_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetIPG",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Port_GetIPG_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetFaultStatus",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Port_GetFaultStatus_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetStatus",
      AGT_RPC_PH_INVOKE,
      intri_cpss_Port_GetStatus_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-SetMode",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PTP_SetMode_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-GetIngrTS",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PTP_GetIngrTS_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-GetEgrTS",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PTP_GetEgrTS_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-SetLinkDelay",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PTP_SetLinkDelay_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-GetLinkDelay",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PTP_GetLinkDelay_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-SetEnableSyncE",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PTP_SetEnableSyncE_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-SetToD",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PTP_SetToD_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-GetToD",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PTP_GetToD_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-SetToDFrequency",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PTP_SetToDFrequency_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-SetPortDelay",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PTP_SetPortDelay_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-GetPortDelay",
      AGT_RPC_PH_INVOKE,
      intri_cpss_PTP_GetPortDelay_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-SetQoSPortProfile",
      AGT_RPC_PH_INVOKE,
      intri_cpss_QoS_SetQoSPortProfile_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-GetQoSPortProfile",
      AGT_RPC_PH_INVOKE,
      intri_cpss_QoS_GetQoSPortProfile_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-SetQoSCoSProfile",
      AGT_RPC_PH_INVOKE,
      intri_cpss_QoS_SetQoSCoSProfile_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-GetQoSCoSProfile",
      AGT_RPC_PH_INVOKE,
      intri_cpss_QoS_GetQoSCoSProfile_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-SetQoSDSCPProfile",
      AGT_RPC_PH_INVOKE,
      intri_cpss_QoS_SetQoSDSCPProfile_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-GetQoSDSCPProfile",
      AGT_RPC_PH_INVOKE,
      intri_cpss_QoS_GetQoSDSCPProfile_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-SetQoSQueueProfile",
      AGT_RPC_PH_INVOKE,
      intri_cpss_QoS_SetQoSQueueProfile_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-GetQoSQueueProfile",
      AGT_RPC_PH_INVOKE,
      intri_cpss_QoS_GetQoSQueueProfile_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-RateLimiting-SetIngress",
      AGT_RPC_PH_INVOKE,
      intri_cpss_RateLimiting_SetIngress_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-RateLimiting-GetIngress",
      AGT_RPC_PH_INVOKE,
      intri_cpss_RateLimiting_GetIngress_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-RateLimiting-SetEgress",
      AGT_RPC_PH_INVOKE,
      intri_cpss_RateLimiting_SetEgress_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-RateLimiting-GetEgress",
      AGT_RPC_PH_INVOKE,
      intri_cpss_RateLimiting_GetEgress_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-STP-SetPortState",
      AGT_RPC_PH_INVOKE,
      intri_cpss_STP_SetPortState_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-STP-GetPortState",
      AGT_RPC_PH_INVOKE,
      intri_cpss_STP_GetPortState_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-STP-SetVlanBinding",
      AGT_RPC_PH_INVOKE,
      intri_cpss_STP_SetVlanBinding_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-STP-GetVlanBinding",
      AGT_RPC_PH_INVOKE,
      intri_cpss_STP_GetVlanBinding_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  res = agt_rpc_register_method(
      y_M_intri_cpss,
      "intri-cpss-STP-RunClearVlanBinding",
      AGT_RPC_PH_INVOKE,
      intri_cpss_STP_RunClearVlanBinding_invoke);
  if (res != NO_ERR) {
    return SET_ERROR(res);
  }

  return res;
}

status_t y_intri_cpss_init2(void) {
  status_t res = NO_ERR;
  return res;
}

void y_intri_cpss_cleanup(void) {
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Device-RunCPSSInit");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Device-GetArchitecture");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Trunking-SetGroup");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Trunking-AddGroup");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Trunking-DeleteGroup");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Trunking-SetLoadBalanceMode");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Trunking-GetLoadBalanceMode");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Trunking-GetGroup");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-RunClearAllRules");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-UpdateControlRule");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-AddControlRule");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-DeleteControlRule");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-RunClearControlRule");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-AddUserDefinedRules");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-DeleteUserDefinedRules");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-ACL-RunClearAllUserDefinedRules");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-CNC-AddCounting");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-CNC-DeleteCounting");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-CNC-GetCounter");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-SetAutoLearnEnable");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-SetEntry");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-DeleteEntry");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-SetAgingTime");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-GetAgingTime");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-SetSecureBreachNaPortEnable");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-GetSecureBreachNaPortEnable");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-GetCounter");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-RunFlush");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-FDB-RunDump");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Mirroring-RunClearAll");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Mirroring-SetSessions");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Mirroring-SetPolicyBased");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-RunMACRegisterWrite");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-RunMACRegisterRead");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-RunSMIRegisterWrite");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-RunSMIRegisterRead");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-RunXSMIRegisterWrite");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-RunXSMIRegisterRead");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-GetCPUTemperature");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-GetMACTemperature");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-GetPHYPortTemperature");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-GetCPUModel");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Misc-GetPHYPortModel");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-AddGroup");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-DeleteGroup");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-AddMember");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-DeleteMember");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateAcceptFrameType");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetAcceptFrameType");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateDefaultVID");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetDefaultVID");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-RunFlush");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetStatus");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateTPIDEntry");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-DumpTPIDTable");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateTPIDIndex");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetTPIDIndex");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-RunClearTPIDIndex");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-SetTunnelEnable");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetTunnelEnable");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateProtocolClass");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetProtocolClass");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-RunClearProtocolClass");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateProtocol");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetProtocol");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-RunClearProtocol");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateTranslationEnable");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetTranslationEnable");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-UpdateTranslationMapping");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-GetTranslationMapping");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Vlan-RunClearTranslationMapping");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Multicast-SetBridgeGroup");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Multicast-DeleteBridgeGroup");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Multicast-SetUnregisteredFlooding");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Multicast-RunClearUnregisteredFlooding");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Multicast-RunDump");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Multicast-RunFlush");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateSTPControl");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateLACPControl");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateDot1XControl");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateLoopControl");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateDHCPv4DiscoverControl");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateDHCPv4BroadcastOfferControl");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateDHCPv4UDPDestination68Control");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateDHCPv4UDPDestination67Control");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateARPControl");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateIGMPVlanControl");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateMLDVlanControl");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-UpdateGVRPControl");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PacketControl-GetStatus");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Policer-SetStormCountingEnable");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Policer-GetStormCountingEnable");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Policer-GetStormCountingCounter");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Port-SetEnable");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetEnable");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Port-SetSpeedDuplex");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetSpeedDuplex");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Port-SetFlowControl");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetFlowControl");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Port-SetEnableEEE");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetEnableEEE");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetCounter");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Port-RunClearCounter");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Port-SetIsolation");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetIsolation");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetIPG");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetFaultStatus");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-Port-GetStatus");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-SetMode");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-GetIngrTS");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-GetEgrTS");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-SetLinkDelay");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-GetLinkDelay");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-SetEnableSyncE");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-SetToD");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-GetToD");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-SetToDFrequency");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-SetPortDelay");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-PTP-GetPortDelay");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-SetQoSPortProfile");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-GetQoSPortProfile");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-SetQoSCoSProfile");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-GetQoSCoSProfile");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-SetQoSDSCPProfile");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-GetQoSDSCPProfile");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-SetQoSQueueProfile");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-QoS-GetQoSQueueProfile");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-RateLimiting-SetIngress");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-RateLimiting-GetIngress");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-RateLimiting-SetEgress");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-RateLimiting-GetEgress");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-STP-SetPortState");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-STP-GetPortState");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-STP-SetVlanBinding");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-STP-GetVlanBinding");
  agt_rpc_unregister_method(
      y_M_intri_cpss,
      "intri-cpss-STP-RunClearVlanBinding");
}
